{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red154\green154\blue154;\red191\green28\blue37;\red255\green255\blue254;\red154\green154\blue154;\red144\green1\blue18;
\red19\green120\blue72;\red14\green110\blue109;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c66667\c66667\c66667;\cssrgb\c80392\c19216\c19216;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;\cssrgb\c63922\c8235\c8235;
\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14320\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  sumAll = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \
\
// Two Sum
\f2\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf6 \cb5 \expnd0\expndtw0\kerning0
let\cf4  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf4 , \cf8 3\cf4 , \cf8 8\cf4 , \cf8 7\cf4 , \cf8 4\cf4 ], \cf8 9\cf4 ) \cf10 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f2\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf6 \cb5 \expnd0\expndtw0\kerning0
let\cf4  solution = \cf6 function\cf4 (isBadVersion) \{\cb1 \
\cb5     \cf6 return\cf4  \cf6 function\cf4 (n) \{\cb1 \
\cb5         \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5         \cf6 let\cf4  right = n;\cb1 \
\cb5         \cb1 \
\cb5         \cf6 while\cf4  (left < right) \{\cb1 \
\cb5             \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\cb5             \cf6 if\cf4  (!isBadVersion(mid)) \{\cb1 \
\cb5                 left = mid + \cf8 1\cf4 ;\cb1 \
\cb5             \} \cf6 else\cf4  \{\cb1 \
\cb5                 right = mid;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\
\cb5         \cf6 return\cf4  left;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  mySqrt = num => \{\cf11 \'a0\cf4 \cb1 \
\cb5   \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5     \cf6 return\cf4  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  right = num;\cb1 \
\
\cb5   \cf6 while\cf4  (left < right) \{\cb1 \
\cb5     \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\
\cb5    \'a0\cf6 if\cf4  (mid * mid === num) \cf6 return\cf4  mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid < num) left = mid + \cf8 1\cf4 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  left;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  rob = nums => \{\cb1 \
\cb5     \cf6 if\cf4  (nums === \cf6 null\cf4  || nums.length === \cf8 0\cf4 ) \{ \cf10 // if there are no houses, the total is zero\cf4 \cb1 \
\cb5         \cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5     \} \cf6 else\cf4  \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  nums[\cf8 0\cf4 ]; \cf10 // if there is only one house, return its value\cf4 \cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 let\cf4  runningTotal = [];\cb1 \
\cb5      \cf10 /* the first index will be the same value as the first house since there are no decisions to make at this point */\cf4 \cb1 \
\cb5     runningTotal[\cf8 0\cf4 ] = nums[\cf8 0\cf4 ],\cb1 \
\cb5     \cf10 /* the second index will be the greater value of the first house or the second house */\cf4 \cb1 \
\cb5     runningTotal[\cf8 1\cf4 ] = \cf9 Math\cf4 .max(nums[\cf8 0\cf4 ], nums[\cf8 1\cf4 ]);\cb1 \
\
\cb5     \cf10 /* start at index 2 since we have already made our 0th and 1st decisions (which correspond to our first and second houses) */\cf4 \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 2\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf10 /* for each index, we choose the greater of (the current house's value plus the total from two houses ago) or (the total through the last house)  */\cf4 \cb1 \
\cb5         runningTotal[i] = \cf9 Math\cf4 .max(nums[i] + runningTotal[i - \cf8 2\cf4 ], runningTotal[i - \cf8 1\cf4 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf10 // return the last value in the array. this will be the optimal solution\cf4 \cb1 \
\cb5     \cf6 return\cf4  runningTotal[runningTotal.length - \cf8 1\cf4 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numberOfSteps = num => \{\cb1 \
\cb5     \cf6 let\cf4  count = \cf8 0\cf4 \cb1 \
\
\cb5     \cf6 while\cf4  (num > \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 if\cf4  (num % \cf8 2\cf4  === \cf8 1\cf4 ) \{\cb1 \
\cb5             num = num - \cf8 1\cf4 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5         num = num / \cf8 2\cf4 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numIslands = grid => \{\cb1 \
\cb5   \cf6 const\cf4  height = grid.length;\cb1 \
\cb5   \cf6 const\cf4  width = height && grid[\cf8 0\cf4 ].length;\cb1 \
\cb5   \cf6 let\cf4  count = \cf8 0\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < height; row++) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < width; col++) \{\cb1 \
\cb5       \cf6 if\cf4  (grid[row][col] === \cf7 '0'\cf4 ) \cf6 continue\cf4 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 function\cf4  dfs(row, col) \{\cb1 \
\cb5     \cf6 if\cf4  (row < \cf8 0\cf4  || col < \cf8 0\cf4  || row === height || col === width || grid[row][col] === \cf7 '0'\cf4 ) \cf6 return\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 '0'\cf4 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf4 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Largest Number in Array
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  largestNumber = nums => \{\cb1 \
\cb12   \cf6 \strokec6 const\cf4 \strokec4  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb12     \cf13 \strokec13 // -1 a goes before b\cf4 \cb1 \strokec4 \
\cb12     \cf13 \strokec13 // 0  no change\cf4 \cb1 \strokec4 \
\cb12     \cf13 \strokec13 // 1  b goes before a\cf4 \cb1 \strokec4 \
\cb12     \cf6 \strokec6 const\cf4 \strokec4  compareFunc = (a, b) => \cf14 \strokec14 `\cf4 \strokec4 $\{b\}$\{a\}\cf14 \strokec14 `\cf4 \strokec4  - \cf14 \strokec14 `\cf4 \strokec4 $\{a\}$\{b\}\cf14 \strokec14 `\cf4 \cb1 \strokec4 \
\
\cb12     finalNums.sort(compareFunc);\cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 if\cf4 \strokec4 (finalNums[\cf15 \strokec15 0\cf4 \strokec4 ] === \cf14 \strokec14 '0'\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf14 \strokec14 '0'\cf4 \strokec4 ;\cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  finalNums.join(\cf14 \strokec14 ''\cf4 \strokec4 );\cb1 \
\cb12 \};\cb1 \
\
\
\cf16 \cb12 \strokec16 Input\cf4 \strokec4 : [\cf15 \strokec15 3\cf4 \strokec4 ,\cf15 \strokec15 30\cf4 \strokec4 ,\cf15 \strokec15 34\cf4 \strokec4 ,\cf15 \strokec15 5\cf4 \strokec4 ,\cf15 \strokec15 9\cf4 \strokec4 ]\cb1 \
\cf16 \cb12 \strokec16 Output\cf4 \strokec4 : \cf14 \strokec14 "9534330"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Get All Permutations
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  getPermutations = arr => \{\cb1 \
\
\cb12   \cf6 \strokec6 const\cf4 \strokec4  output = [];\cb1 \
\
\cb12   \cf6 \strokec6 const\cf4 \strokec4  swap = (arrToSwap, indexA, indexB) => \{\cb1 \
\cb12     \cf6 \strokec6 const\cf4 \strokec4  temp = arrToSwap[indexA];\cb1 \
\cb12     arrToSwap[indexA] = arrToSwap[indexB];\cb1 \
\cb12     arrToSwap[indexB] = temp;\cb1 \
\cb12   \};\cb1 \
\
\cb12   \cf6 \strokec6 const\cf4 \strokec4  generate = (n, heapArr) => \{\cb1 \
\cb12     \cf6 \strokec6 if\cf4 \strokec4  (n === \cf15 \strokec15 1\cf4 \strokec4 ) \{\cb1 \
\cb12       output.push(heapArr.slice());\cb1 \
\cb12       \cf6 \strokec6 return\cf4 \strokec4 ;\cb1 \
\cb12     \}\cb1 \
\
\cb12     generate(n - \cf15 \strokec15 1\cf4 \strokec4 , heapArr);\cb1 \
\
\cb12     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf15 \strokec15 0\cf4 \strokec4 ; i < n - \cf15 \strokec15 1\cf4 \strokec4 ; i++) \{\cb1 \
\cb12       \cf6 \strokec6 if\cf4 \strokec4  (n % \cf15 \strokec15 2\cf4 \strokec4  === \cf15 \strokec15 0\cf4 \strokec4 ) \{\cb1 \
\cb12         swap(heapArr, i, n - \cf15 \strokec15 1\cf4 \strokec4 );\cb1 \
\cb12       \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb12         swap(heapArr, \cf15 \strokec15 0\cf4 \strokec4 , n - \cf15 \strokec15 1\cf4 \strokec4 );\cb1 \
\cb12       \}\cb1 \
\
\cb12       generate(n - \cf15 \strokec15 1\cf4 \strokec4 , heapArr);\cb1 \
\cb12     \}\cb1 \
\cb12   \};\cb1 \
\
\cb12   generate(arr.length, arr.slice());\cb1 \
\
\cb12   \cf6 \strokec6 return\cf4 \strokec4  output;\cb1 \
\cb12 \};\cb1 \
\
\cb12 getPermutations([\cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 2\cf4 \strokec4 , \cf15 \strokec15 3\cf4 \strokec4 ])\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two arrays of integers\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index
\f3\fs28 \cf17 \cb3 \strokec17 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 From left to right read nums[i] and index[i], insert at index\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index[i]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0the value\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums[i]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Repeat the previous step until there are no elements to read in\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index.
\f3\fs28 \cf17 \cb1 \strokec17 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  createTargetArray = (nums, idx) => \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  target = []\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 in\cf4 \strokec4  nums)target.splice(idx[num], \cf15 \strokec15 0\cf4 \strokec4 , nums[num])\cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  target\cb1 \
\cb12 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 let\cf4 \strokec4  nums = [\cf15 \strokec15 0\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 3\cf4 \strokec4 ,\cf15 \strokec15 4\cf4 \strokec4 ]\cb1 \
\cf6 \cb12 \strokec6 let\cf4 \strokec4  index = [\cf15 \strokec15 0\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf13 \cb12 \strokec13 //Output: [0,4,1,3,2]\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  climbStairs = n => \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  arr=[\cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 2\cf4 \strokec4 , \cf15 \strokec15 3\cf4 \strokec4 ];\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf15 \strokec15 3\cf4 \strokec4 ;i<n;i++)\{\cb1 \
\cb12         arr[i]=arr[i-\cf15 \strokec15 1\cf4 \strokec4 ] + arr[i-\cf15 \strokec15 2\cf4 \strokec4 ];\cb1 \
\cb12     \}\cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  arr[n-\cf15 \strokec15 1\cf4 \strokec4 ];\cb1 \
\cb12 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Transpose Matrix 
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  transpose = arr => \{\cb1 \
\cb12     \cf6 \strokec6 if\cf4 \strokec4 (arr.length === \cf15 \strokec15 0\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  [];\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  width = arr[\cf15 \strokec15 0\cf4 \strokec4 ].length \cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  height = arr.length;\cb1 \
\cb12     \cf6 \strokec6 var\cf4 \strokec4  result = [];\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 var\cf4 \strokec4  i = \cf15 \strokec15 0\cf4 \strokec4 ; i < width; i++) \{\cb1 \
\cb12         result[i] = [];\cb1 \
\cb12         \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 var\cf4 \strokec4  j = \cf15 \strokec15 0\cf4 \strokec4 ; j < height; j++)\{\cb1 \
\cb12             result[i][j] = arr[j][i];\cb1 \
\cb12         \}\cb1 \
\cb12     \}\cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb12 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 \strokec17 Input: 
\f1\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],[2,5,8],[3,6,9]]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm)
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an integer array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  maxSubArray = nums => \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  currentMax = nums[\cf15 \strokec15 0\cf4 \strokec4 ];\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  max = nums[\cf15 \strokec15 0\cf4 \strokec4 ];\cb1 \
\
\cb12   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 of\cf4 \strokec4  nums) \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  current = num;\cb1 \
\cb12     currentMax = \cf16 \strokec16 Math\cf4 \strokec4 .max(current, current + currentMax);\cb1 \
\cb12     max = \cf16 \strokec16 Math\cf4 \strokec4 .max(max, currentMax);\cb1 \
\cb12   \}\cb1 \
\cb12   \cf6 \strokec6 return\cf4 \strokec4  max;\cb1 \
\cb12 \};\cb1 \
\
\cb12 maxSubArray([\cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 3\cf4 \strokec4 , -\cf15 \strokec15 4\cf4 \strokec4 , \cf15 \strokec15 4\cf4 \strokec4 , -\cf15 \strokec15 6\cf4 \strokec4 , \cf15 \strokec15 3\cf4 \strokec4 , \cf15 \strokec15 9\cf4 \strokec4 , -\cf15 \strokec15 11\cf4 \strokec4 , \cf15 \strokec15 10\cf4 \strokec4 ])\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Knight Probability
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 On an\'a0
\f4\fs26 \cf18 \cb19 \strokec18 N
\f3\fs28 \cf17 \cb3 \strokec17 x
\f4\fs26 \cf18 \cb19 \strokec18 N
\f3\fs28 \cf17 \cb3 \strokec17 \'a0chessboard, a knight starts at the\'a0
\f4\fs26 \cf18 \cb19 \strokec18 r
\f3\fs28 \cf17 \cb3 \strokec17 -th row and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 c
\f3\fs28 \cf17 \cb3 \strokec17 -th column and attempts to make exactly\'a0
\f4\fs26 \cf18 \cb19 \strokec18 K
\f3\fs28 \cf17 \cb3 \strokec17 \'a0moves. The rows and columns are 0 indexed, so the top-left square is\'a0
\f4\fs26 \cf18 \cb19 \strokec18 (0, 0)
\f3\fs28 \cf17 \cb3 \strokec17 , and the bottom-right square is\'a0
\f4\fs26 \cf18 \cb19 \strokec18 (N-1, N-1)
\f3\fs28 \cf17 \cb3 \strokec17 .\
A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\
The knight continues moving until it has made exactly\'a0
\f4\fs26 \cf18 \cb19 \strokec18 K
\f3\fs28 \cf17 \cb3 \strokec17 \'a0moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  3, 2, 0, 0\

\f0\b Output:
\f1\b0  0.0625\

\f0\b Explanation:
\f1\b0  There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\
From each of those positions, there are also two moves that will keep the knight on the board.\
The total probability the knight stays on the board is 0.0625.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  knightProbability = (\cf16 \strokec16 N\cf4 \strokec4 , \cf16 \strokec16 K\cf4 \strokec4 , r, c) => \{\cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 const\cf4 \strokec4  dp = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Array\cf4 \strokec4 (\cf16 \strokec16 N\cf4 \strokec4 );\cb1 \
\cb12     \cf6 \strokec6 const\cf4 \strokec4  movesR = [\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,-\cf15 \strokec15 2\cf4 \strokec4 ,-\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ,-\cf15 \strokec15 1\cf4 \strokec4 ,-\cf15 \strokec15 1\cf4 \strokec4 ];\cb1 \
\cb12     \cf6 \strokec6 const\cf4 \strokec4  movesC = [\cf15 \strokec15 1\cf4 \strokec4 ,-\cf15 \strokec15 1\cf4 \strokec4 ,\cf15 \strokec15 1\cf4 \strokec4 ,-\cf15 \strokec15 1\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,-\cf15 \strokec15 2\cf4 \strokec4 ,\cf15 \strokec15 2\cf4 \strokec4 ,-\cf15 \strokec15 2\cf4 \strokec4 ]; \cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  col = \cf15 \strokec15 0\cf4 \strokec4 ; col < dp.length; col++) \{\cb1 \
\cb12         dp[col] = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Array\cf4 \strokec4 (\cf16 \strokec16 N\cf4 \strokec4 );\cb1 \
\cb12         \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  k = \cf15 \strokec15 0\cf4 \strokec4 ; k < dp[col].length; k++) \{\cb1 \
\cb12             dp[col][k] = [\cf15 \strokec15 1\cf4 \strokec4 ]; \cf13 \strokec13 // 0 move has 100% of staying on the board\cf4 \cb1 \strokec4 \
\cb12         \}\cb1 \
\cb12     \}\cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  s = \cf15 \strokec15 1\cf4 \strokec4 ; s < \cf16 \strokec16 K\cf4 \strokec4  + \cf15 \strokec15 1\cf4 \strokec4 ; s++) \{\cb1 \
\cb12         \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf15 \strokec15 0\cf4 \strokec4 ; i < \cf16 \strokec16 N\cf4 \strokec4 ; i++) \{\cb1 \
\cb12             \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  j = \cf15 \strokec15 0\cf4 \strokec4 ; j < \cf16 \strokec16 N\cf4 \strokec4 ; j++) \{\cb1 \
\cb12                 \cf6 \strokec6 let\cf4 \strokec4  probability = \cf15 \strokec15 0.0\cf4 \strokec4 ;\cb1 \
\cb12                 \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  m = \cf15 \strokec15 0\cf4 \strokec4 ; m < \cf15 \strokec15 8\cf4 \strokec4 ; m++) \{\cb1 \
\cb12                     \cf6 \strokec6 const\cf4 \strokec4  nextRow = i + movesR[m];\cb1 \
\cb12                     \cf6 \strokec6 const\cf4 \strokec4  nextCol = j + movesC[m];\cb1 \
\cb12                     \cf6 \strokec6 if\cf4 \strokec4 (nextRow >= \cf15 \strokec15 0\cf4 \strokec4  && nextRow < \cf16 \strokec16 N\cf4 \strokec4  && nextCol >= \cf15 \strokec15 0\cf4 \strokec4  && nextCol < \cf16 \strokec16 N\cf4 \strokec4 ) \{\cb1 \
\cb12                         probability += dp[nextRow][nextCol][s-\cf15 \strokec15 1\cf4 \strokec4 ]/\cf15 \strokec15 8.0\cf4 \strokec4 ; \cf13 \strokec13 // % of chance out of 8 moves\cf4 \cb1 \strokec4 \
\cb12                     \}\cb1 \
\cb12                 \}\cb1 \
\cb12                 dp[i][j][s] = probability;\cb1 \
\cb12             \}\cb1 \
\cb12         \}\cb1 \
\cb12     \}\cb1 \
\cb12     \cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  dp[r][c][\cf16 \strokec16 K\cf4 \strokec4 ];\cb1 \
\cb12 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Product Except Self
\f1\b0\fs28 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0of\'a0
\f5\i n
\f3\i0 \'a0integers where\'a0
\f5\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 output
\f3\fs28 \cf17 \cb3 \strokec17 \'a0such that\'a0
\f4\fs26 \cf18 \cb19 \strokec18 output[i]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0is equal to the product of all the elements of\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0except\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums[i]
\f3\fs28 \cf17 \cb3 \strokec17 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f6\b Note:\'a0
\f3\b0 Please solve it\'a0
\f6\b without division
\f3\b0 \'a0and in O(
\f5\i n
\f3\i0 ).
\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  productExceptSelf = nums => \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  length = nums.length;\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  result = [\cf15 \strokec15 1\cf4 \strokec4 ];\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  temp = \cf15 \strokec15 1\cf4 \strokec4 ;\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf15 \strokec15 1\cf4 \strokec4 ; i < length; i++) \{\cb1 \
\cb12         result[i] = result[i - \cf15 \strokec15 1\cf4 \strokec4 ] * nums[i - \cf15 \strokec15 1\cf4 \strokec4 ];\cb1 \
\cb12     \};\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = length - \cf15 \strokec15 1\cf4 \strokec4 ; i > -\cf15 \strokec15 1\cf4 \strokec4 ; i--) \{\cb1 \
\cb12         result[i] = result[i] * temp;\cb1 \
\cb12         temp = temp * nums[i];\cb1 \
\cb12     \};\cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb12 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Largest Square in Grid
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb12 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  largestSquare = grid => \{\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  rows = grid.length;\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  cols = rows ? grid[\cf15 \strokec15 0\cf4 \strokec4 ].length : \cf15 \strokec15 0\cf4 \strokec4 ;\cb1 \
\cb12     \cf6 \strokec6 let\cf4 \strokec4  max = \cf15 \strokec15 0\cf4 \strokec4 ;\cb1 \
\cb12     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  row = \cf15 \strokec15 0\cf4 \strokec4 ; row < rows; row++) \{\cb1 \
\cb12         \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  col = \cf15 \strokec15 0\cf4 \strokec4 ; col < cols; col++) \{\cb1 \
\cb12             \cf6 \strokec6 let\cf4 \strokec4  left = col === \cf15 \strokec15 0\cf4 \strokec4  ? \cf15 \strokec15 0\cf4 \strokec4  : grid[row][col - \cf15 \strokec15 1\cf4 \strokec4 ],\cb1 \
\cb12                 up = row === \cf15 \strokec15 0\cf4 \strokec4  ? \cf15 \strokec15 0\cf4 \strokec4  : grid[row - \cf15 \strokec15 1\cf4 \strokec4 ][col], \cb1 \
\cb12                 back = row && col ? grid[row - \cf15 \strokec15 1\cf4 \strokec4 ][col - \cf15 \strokec15 1\cf4 \strokec4 ] : \cf15 \strokec15 0\cf4 \strokec4 ;\cb1 \
\cb12             \cf6 \strokec6 if\cf4 \strokec4  (grid[row][col] == \cf15 \strokec15 1\cf4 \strokec4 ) \{\cb1 \
\cb12                 grid[row][col] = \cf16 \strokec16 Math\cf4 \strokec4 .min(left, up, back) + grid[row][col] * \cf15 \strokec15 1\cf4 \strokec4 ;\cb1 \
\cb12             \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb12                 grid[row][col] = \cf15 \strokec15 0\cf4 \strokec4 ;\cb1 \
\cb12             \};\cb1 \
\cb12             max = max > grid[row][col] ? max : grid[row][col];\cb1 \
\cb12         \};\cb1 \
\cb12     \};\cb1 \
\cb12     \cf6 \strokec6 return\cf4 \strokec4  max * max;\cb1 \
\cb12 \};\
\
\cf6 \strokec6 let\cf4 \strokec4  items = [\cb1 \
\cb12   [\cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 ],\cb1 \
\cb12   [\cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 ],\cb1 \
\cb12   [\cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 ],\cb1 \
\cb12   [\cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 ],\cb1 \
\cb12   [\cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 , \cf15 \strokec15 0\cf4 \strokec4 , \cf15 \strokec15 1\cf4 \strokec4 ]\cb1 \
\cb12 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Next Problem
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = arr => \{\cb1 \
\
\}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Next Problem
\f1\b0\fs28 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = arr => \{\cb1 \
\
\}\
\
}