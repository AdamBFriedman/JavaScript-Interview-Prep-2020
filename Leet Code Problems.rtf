{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red154\green154\blue154;\red255\green255\blue254;\red19\green120\blue72;\red14\green110\blue109;\red191\green28\blue37;
\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;\red154\green154\blue154;\red144\green1\blue18;
\red29\green38\blue42;\red245\green247\blue249;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c66667\c66667\c66667;\cssrgb\c100000\c100000\c99608;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;\cssrgb\c80392\c19216\c19216;
\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;\cssrgb\c66667\c66667\c66667;\cssrgb\c63922\c8235\c8235;
\cssrgb\c14902\c19608\c21961;\cssrgb\c96863\c97647\c98039;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14620\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\

\f0\b \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  sumAll = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \

\f0\b \cf2 \cb3 \
// Fibonacci O(2^n) or O(n) with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  fibonacci = (n, memo) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     memo = memo || \{\}\cb1 \
\cb5     \cf6 if\cf4  (n <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[n] = fibonacci(n - \cf8 1\cf4 , memo) + fibonacci(n - \cf8 2\cf4 , memo)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[n]\cb1 \
\cb5 \}
\f0\b \cf2 \cb3 \
\
// Two Sum
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
let\cf4  twoSum = (nums, target) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf4 , \cf8 3\cf4 , \cf8 8\cf4 , \cf8 7\cf4 , \cf8 4\cf4 ], \cf8 9\cf4 ) \cf10 //[0, 3]\
\

\f0\b \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb11 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 var\cf4 \strokec4  solution = \cf6 \strokec6 function\cf4 \strokec4 (isBadVersion) \{\cb1 \
\
\cb11     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 function\cf4 \strokec4 (n) \{\cb1 \
\cb11         \cf6 \strokec6 let\cf4 \strokec4  left = \cf12 \strokec12 1\cf4 \strokec4 ;\cb1 \
\cb11         \cf6 \strokec6 let\cf4 \strokec4  right = n;\cb1 \
\cb11         \cf6 \strokec6 while\cf4 \strokec4 (left <= right)\{\cb1 \
\cb11             \cf6 \strokec6 let\cf4 \strokec4  middle = left + \cf13 \strokec13 Math\cf4 \strokec4 .floor((right - left) / \cf12 \strokec12 2\cf4 \strokec4 );\cb1 \
\cb11             \cf6 \strokec6 if\cf4 \strokec4 (isBadVersion(middle))\{\cb1 \
\cb11                 \cf6 \strokec6 if\cf4 \strokec4  ((middle-\cf12 \strokec12 1\cf4 \strokec4  > \cf12 \strokec12 0\cf4 \strokec4  && !isBadVersion(middle-\cf12 \strokec12 1\cf4 \strokec4 )) || (middle === \cf12 \strokec12 1\cf4 \strokec4 ))\{\cb1 \
\cb11                     \cf6 \strokec6 return\cf4 \strokec4  middle;\cb1 \
\cb11                 \}\cf6 \strokec6 else\cf4 \strokec4 \{\cb1 \
\cb11                     right = middle - \cf12 \strokec12 1\cf4 \strokec4 ;\cb1 \
\cb11                 \}\cb1 \
\cb11             \}\cf6 \strokec6 else\cf4 \strokec4 \{\cb1 \
\cb11                 left = middle + \cf12 \strokec12 1\cf4 \strokec4 ;\cb1 \
\cb11             \}\cb1 \
\cb11         \}\cb1 \
\cb11         \cf6 \strokec6 return\cf4 \strokec4  -\cf12 \strokec12 1\cf4 \strokec4 ;\cb1 \
\cb11     \};\cb1 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\

\f0\b \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  mySqrt = num => \{\cf14 \cb5 \'a0\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5     \cf6 return\cf4  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  right = num;\cb1 \
\
\cb5   \cf6 while\cf4  (left < right) \{\cb1 \
\cb5     \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\
\cb5    \'a0\cf6 if\cf4  (mid * mid === num) \cf6 return\cf4  mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid < num) left = mid + \cf8 1\cf4 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  left;\cb1 \
\cb5 \};\cb1 \
\cb5 \

\f0\b \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  rob = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 if\cf4  (nums === \cf6 null\cf4  || nums.length === \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5     \} \cf6 else\cf4  \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  nums[\cf8 0\cf4 ];\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 let\cf4  runningTotal = [];\cb1 \
\cb5     runningTotal[\cf8 0\cf4 ] = nums[\cf8 0\cf4 ],\cb1 \
\cb5     runningTotal[\cf8 1\cf4 ] = \cf9 Math\cf4 .max(nums[\cf8 0\cf4 ], nums[\cf8 1\cf4 ]);\cb1 \
\
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 2\cf4 ; i < nums.length; i++) \{\cb1 \
\
\cb5        runningTotal[i] = \cf9 Math\cf4 .max(nums[i] + runningTotal[i - \cf8 2\cf4 ], runningTotal[i - \cf8 1\cf4 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  runningTotal[runningTotal.length - \cf8 1\cf4 ];\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numberOfSteps = num => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  count = \cf8 0\cf4 \cb1 \
\
\cb5     \cf6 while\cf4  (num > \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 if\cf4  (num % \cf8 2\cf4  === \cf8 1\cf4 ) \{\cb1 \
\cb5             num = num - \cf8 1\cf4 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5         num = num / \cf8 2\cf4 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  count\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numIslands = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 const\cf4  height = grid.length;\cb1 \
\cb5   \cf6 const\cf4  width = height && grid[\cf8 0\cf4 ].length;\cb1 \
\cb5   \cf6 let\cf4  count = \cf8 0\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < height; row++) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < width; col++) \{\cb1 \
\cb5       \cf6 if\cf4  (grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 continue\cf4 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 function\cf4  dfs(row, col) \{\cb1 \
\cb5     \cf6 if\cf4  (row < \cf8 0\cf4  || col < \cf8 0\cf4  || row === height || col === width || grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 return\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf4 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\
\

\f0\b \cf2 \cb3 // Largest Number in Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  largestNumber = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 const\cf4  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb5     \cf10 // -1 a goes before b\cf4 \cb1 \
\cb5     \cf10 // 0  no change\cf4 \cb1 \
\cb5     \cf10 // 1  b goes before a\cf4 \cb1 \
\cb5     \cf6 const\cf4  compareFunc = (a, b) => \cf7 \cb5 `\cf4 \cb5 $\{b\}$\{a\}\cf7 \cb5 `\cf4 \cb5  - \cf7 \cb5 `\cf4 \cb5 $\{a\}$\{b\}\cf7 \cb5 `\cf4 \cb1 \
\
\cb5     finalNums.sort(compareFunc);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4 (finalNums[\cf8 0\cf4 ] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 return\cf4  \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  finalNums.join(\cf7 \cb5 ''\cf4 \cb5 );\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb5 Input\cf4 : [\cf8 3\cf4 ,\cf8 30\cf4 ,\cf8 34\cf4 ,\cf8 5\cf4 ,\cf8 9\cf4 ]\cb1 \
\cf9 \cb5 Output\cf4 : \cf7 \cb5 "9534330"\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Get All Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  getPermutations = arr => \{\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 const\cf4  output = [];\cb1 \
\
\cb5   \cf6 const\cf4  swap = (arrToSwap, indexA, indexB) => \{\cb1 \
\cb5     \cf6 const\cf4  temp = arrToSwap[indexA];\cb1 \
\cb5     arrToSwap[indexA] = arrToSwap[indexB];\cb1 \
\cb5     arrToSwap[indexB] = temp;\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 const\cf4  generate = (n, heapArr) => \{\cb1 \
\cb5     \cf6 if\cf4  (n === \cf8 1\cf4 ) \{\cb1 \
\cb5       output.push(heapArr.slice());\cb1 \
\cb5       \cf6 return\cf4 ;\cb1 \
\cb5     \}\cb1 \
\
\cb5     generate(n - \cf8 1\cf4 , heapArr);\cb1 \
\
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < n - \cf8 1\cf4 ; i++) \{\cb1 \
\cb5       \cf6 if\cf4  (n % \cf8 2\cf4  === \cf8 0\cf4 ) \{\cb1 \
\cb5         swap(heapArr, i, n - \cf8 1\cf4 );\cb1 \
\cb5       \} \cf6 else\cf4  \{\cb1 \
\cb5         swap(heapArr, \cf8 0\cf4 , n - \cf8 1\cf4 );\cb1 \
\cb5       \}\cb1 \
\
\cb5       generate(n - \cf8 1\cf4 , heapArr);\cb1 \
\cb5     \}\cb1 \
\cb5   \};\cb1 \
\
\cb5   generate(arr.length, arr.slice());\cb1 \
\
\cb5   \cf6 return\cf4  output;\cb1 \
\cb5 \};\cb1 \
\
\cb5 getPermutations([\cf8 1\cf4 , \cf8 2\cf4 , \cf8 3\cf4 ])\cb1 \
\

\f0\b \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 Given two arrays of integers\'a0
\f4 \cf16 \cb17 nums
\f3 \cf15 \cb3 \'a0and\'a0
\f4 \cf16 \cb17 index
\f3 \cf15 \cb3 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf15 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
From left to right read nums[i] and index[i], insert at index\'a0
\f4 \cf16 \cb17 index[i]
\f3 \cf15 \cb3 \'a0the value\'a0
\f4 \cf16 \cb17 nums[i]
\f3 \cf15 \cb3 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Repeat the previous step until there are no elements to read in\'a0
\f4 \cf16 \cb17 nums
\f3 \cf15 \cb3 \'a0and\'a0
\f4 \cf16 \cb17 index.
\f3 \cf15 \cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf15 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  createTargetArray = (nums, idx) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  target = []\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  num \cf6 in\cf4  nums)target.splice(idx[num], \cf8 0\cf4 , nums[num])\cb1 \
\cb5     \cf6 return\cf4  target\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4  nums = [\cf8 0\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 3\cf4 ,\cf8 4\cf4 ]\cb1 \
\cf6 \cb5 let\cf4  index = [\cf8 0\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 2\cf4 ,\cf8 1\cf4 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 //Output: [0,4,1,3,2]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  climbStairs = n => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  arr=[\cf8 1\cf4 , \cf8 2\cf4 , \cf8 3\cf4 ];\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 3\cf4 ;i<n;i++)\{\cb1 \
\cb5         arr[i]=arr[i-\cf8 1\cf4 ] + arr[i-\cf8 2\cf4 ];\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  arr[n-\cf8 1\cf4 ];\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Rotate Image 90deg
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 You are given an\'a0
\f5\i n
\f3\i0 \'a0x\'a0
\f5\i n
\f3\i0 \'a02D matrix representing an image.\
Rotate the image by 90 degrees (clockwise).\

\f6\b Note:
\f3\b0 \
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.\'a0
\f6\b DO NOT
\f3\b0 \'a0allocate another 2D matrix and do the rotation.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  rotate = grid => \{\cb1 \
\
\cf6 \cb5 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ;i < grid.length; i++)\{\cb1 \
\cf6 \cb5 for\cf4 (\cf6 let\cf4  j = \cf8 0\cf4 ;j < i; j++)\{\cb1 \
\
\cf6 \cb5 let\cf4  temp = grid[i][j];\cb1 \
\cb5 grid[i][j] = grid[j][i];\cb1 \
\cb5 grid[j][i] = temp;\cb1 \
\
\cb5 \}\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 for\cf4  (\cf6 let\cf4  g \cf6 of\cf4  grid) g.reverse()\cb1 \
\
\cf6 \cb5 return\cf4  grid\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  x = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 3\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 4\cf4 \cb5 ,\cf8 \cb5 5\cf4 \cb5 ,\cf8 \cb5 6\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 7\cf4 \cb5 ,\cf8 \cb5 8\cf4 \cb5 ,\cf8 \cb5 9\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 // [\cf4 \cb1 \
\cf10 \cb5 //  [7,4,1],\cf4 \cb1 \
\cf10 \cb5 //  [8,5,2],\cf4 \cb1 \
\cf10 \cb5 //  [9,6,3]\cf4 \cb1 \
\cf10 \cb5 // ]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Transpose Matrix 
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  transpose = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5 (arr.length === \cf8 \cb5 0\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  width = arr[\cf8 \cb5 0\cf4 \cb5 ].length \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  height = arr.length;\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  result = [];\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < width; i++) \{\cb1 \
\cb5         result[i] = [];\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < height; j++)\{\cb1 \
\cb5             result[i][j] = arr[j][i];\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf15 \cb3 Input: 
\f1\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],[2,5,8],[3,6,9]]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm.  Dynamic Programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf15 \cb3 Given an integer array\'a0
\f4 \cf16 \cb17 nums
\f3 \cf15 \cb3 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  maxSubArray = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  currentMax = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  num \cf6 \cb5 of\cf4 \cb5  nums) \{\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  current = num;\cb1 \
\cb5     currentMax = \cf9 \cb5 Math\cf4 \cb5 .max(current, current + currentMax);\cb1 \
\cb5     max = \cf9 \cb5 Math\cf4 \cb5 .max(max, currentMax);\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  max;\cb1 \
\cb5 \};\cb1 \
\
\cb5 maxSubArray([\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , -\cf8 \cb5 4\cf4 \cb5 , \cf8 \cb5 4\cf4 \cb5 , -\cf8 \cb5 6\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , \cf8 \cb5 9\cf4 \cb5 , -\cf8 \cb5 11\cf4 \cb5 , \cf8 \cb5 10\cf4 \cb5 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Knight Probability
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 On an\'a0
\f4 \cf16 \cb17 N
\f3 \cf15 \cb3 x
\f4 \cf16 \cb17 N
\f3 \cf15 \cb3 \'a0chessboard, a knight starts at the\'a0
\f4 \cf16 \cb17 r
\f3 \cf15 \cb3 -th row and\'a0
\f4 \cf16 \cb17 c
\f3 \cf15 \cb3 -th column and attempts to make exactly\'a0
\f4 \cf16 \cb17 K
\f3 \cf15 \cb3 \'a0moves. The rows and columns are 0 indexed, so the top-left square is\'a0
\f4 \cf16 \cb17 (0, 0)
\f3 \cf15 \cb3 , and the bottom-right square is\'a0
\f4 \cf16 \cb17 (N-1, N-1)
\f3 \cf15 \cb3 .\
A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\
The knight continues moving until it has made exactly\'a0
\f4 \cf16 \cb17 K
\f3 \cf15 \cb3 \'a0moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf15 \cb17 Input:
\f1\b0  3, 2, 0, 0\

\f0\b Output:
\f1\b0  0.0625\

\f0\b Explanation:
\f1\b0  There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\
From each of those positions, there are also two moves that will keep the knight on the board.\
The total probability the knight stays on the board is 0.0625.\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  knightProbability = (\cf9 \cb5 N\cf4 \cb5 , \cf9 \cb5 K\cf4 \cb5 , r, c) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  dp = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesR = [\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesC = [\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ]; \cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < dp.length; col++) \{\cb1 \
\cb5         dp[col] = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  k = \cf8 \cb5 0\cf4 \cb5 ; k < dp[col].length; k++) \{\cb1 \
\cb5             dp[col][k] = [\cf8 \cb5 1\cf4 \cb5 ]; \cf10 \cb5 // 0 move has 100% of staying on the board\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  s = \cf8 \cb5 1\cf4 \cb5 ; s < \cf9 \cb5 K\cf4 \cb5  + \cf8 \cb5 1\cf4 \cb5 ; s++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf9 \cb5 N\cf4 \cb5 ; i++) \{\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < \cf9 \cb5 N\cf4 \cb5 ; j++) \{\cb1 \
\cb5                 \cf6 \cb5 let\cf4 \cb5  probability = \cf8 \cb5 0.0\cf4 \cb5 ;\cb1 \
\cb5                 \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  m = \cf8 \cb5 0\cf4 \cb5 ; m < \cf8 \cb5 8\cf4 \cb5 ; m++) \{\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextRow = i + movesR[m];\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextCol = j + movesC[m];\cb1 \
\cb5                     \cf6 \cb5 if\cf4 \cb5 (nextRow >= \cf8 \cb5 0\cf4 \cb5  && nextRow < \cf9 \cb5 N\cf4 \cb5  && nextCol >= \cf8 \cb5 0\cf4 \cb5  && nextCol < \cf9 \cb5 N\cf4 \cb5 ) \{\cb1 \
\cb5                         probability += dp[nextRow][nextCol][s-\cf8 \cb5 1\cf4 \cb5 ]/\cf8 \cb5 8.0\cf4 \cb5 ; \cf10 \cb5 // % of chance out of 8 moves\cf4 \cb1 \
\cb5                     \}\cb1 \
\cb5                 \}\cb1 \
\cb5                 dp[i][j][s] = probability;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  dp[r][c][\cf9 \cb5 K\cf4 \cb5 ];\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Product Except Self
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 Given an array\'a0
\f4 \cf16 \cb17 nums
\f3 \cf15 \cb3 \'a0of\'a0
\f5\i n
\f3\i0 \'a0integers where\'a0
\f5\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f4 \cf16 \cb17 output
\f3 \cf15 \cb3 \'a0such that\'a0
\f4 \cf16 \cb17 output[i]
\f3 \cf15 \cb3 \'a0is equal to the product of all the elements of\'a0
\f4 \cf16 \cb17 nums
\f3 \cf15 \cb3 \'a0except\'a0
\f4 \cf16 \cb17 nums[i]
\f3 \cf15 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf15 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf15 \cb17 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf15 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f6\b Note:\'a0
\f3\b0 Please solve it\'a0
\f6\b without division
\f3\b0 \'a0and in O(
\f5\i n
\f3\i0 ).
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  productExceptSelf = nums => \{\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  result = [\cf12 \strokec12 1\cf4 \strokec4 ];\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  temp = \cf12 \strokec12 1\cf4 \strokec4 ;\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf12 \strokec12 1\cf4 \strokec4 ; i < nums.length; i++) \{\cb1 \
\cb11         result[i] = result[i - \cf12 \strokec12 1\cf4 \strokec4 ] * nums[i - \cf12 \strokec12 1\cf4 \strokec4 ];\cb1 \
\cb11     \};\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = nums.length - \cf12 \strokec12 1\cf4 \strokec4 ; i > -\cf12 \strokec12 1\cf4 \strokec4 ; i--) \{\cb1 \
\cb11         result[i] *= temp;\cb1 \
\cb11         temp *= nums[i];\cb1 \
\cb11     \};\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Square in Grid
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  largestSquare = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  rows = grid.length;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  cols = rows ? grid[\cf8 \cb5 0\cf4 \cb5 ].length : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  row = \cf8 \cb5 0\cf4 \cb5 ; row < rows; row++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < cols; col++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  left = col === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row][col - \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5                 up = row === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row - \cf8 \cb5 1\cf4 \cb5 ][col], \cb1 \
\cb5                 back = row && col ? grid[row - \cf8 \cb5 1\cf4 \cb5 ][col - \cf8 \cb5 1\cf4 \cb5 ] : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \cf6 \cb5 if\cf4 \cb5  (grid[row][col] == \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5                 grid[row][col] = \cf9 \cb5 Math\cf4 \cb5 .min(left, up, back) + grid[row][col] * \cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5             \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5                 grid[row][col] = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \};\cb1 \
\cb5             max = max > grid[row][col] ? max : grid[row][col];\cb1 \
\cb5         \};\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  max * max;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  items = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Tower of Hanoi (Recursion)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  hanoiTower = (height, srcP, destP, bufferP) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (height >= \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\
\cb5     \cf10 \cb5 // Move a tower of height-1 to the buffer peg, using the destination peg.\cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , srcP, bufferP, destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the remaining disk to the destination peg.\cf4 \cb1 \
\cb5     console.log(\cf7 \cb5 'Move disk from Tower '\cf4 \cb5 , srcP, \cf7 \cb5 ' to Tower '\cf4 \cb5 , destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.        \cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , bufferP, destP, srcP);\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5 \}\cb1 \
\
\cb5 hanoiTower(\cf8 \cb5 3\cf4 \cb5 , \cf7 \cb5 "A"\cf4 \cb5 , \cf7 \cb5 "C"\cf4 \cb5 , \cf7 \cb5 "B"\cf4 \cb5 );\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  permute = (nums, memo = \cf12 \strokec12 0\cf4 \strokec4 ) => \{\cb1 \
\cb11     \cf6 \strokec6 if\cf4 \strokec4  (memo >= nums.length) \cf6 \strokec6 return\cf4 \strokec4  [[]];\cb1 \
\cb11     \cf6 \strokec6 const\cf4 \strokec4  result = [];\cb1 \
\cb11     \cf6 \strokec6 const\cf4 \strokec4  prevs = permute(nums, memo + \cf12 \strokec12 1\cf4 \strokec4 );  \cf18 \strokec18 // permutations of elements after n\cf4 \cb1 \strokec4 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  prev \cf6 \strokec6 of\cf4 \strokec4  prevs) \{\cb1 \
\cb11         \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf12 \strokec12 0\cf4 \strokec4 ; i <= prev.length; i++) \{\cb1 \
\cb11             \cf6 \strokec6 let\cf4 \strokec4  p = prev.slice(\cf12 \strokec12 0\cf4 \strokec4 );\cb1 \
\cb11             p.splice(i, \cf12 \strokec12 0\cf4 \strokec4 , nums[memo]);  \cf18 \strokec18 // successively insert element n\cf4 \cb1 \strokec4 \
\cb11             result.push(p); \cb1 \
\cb11         \}\cb1 \
\cb11     \}\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations 2 (Unique)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf15 \cb3 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0
\cf6 const\cf4  permuteUnique = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  permU = \cf6 \cb5 function\cf4 \cb5 (nums) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (nums.length == \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [nums];\cb1 \
\cb5         \cf6 \cb5 let\cf4 \cb5  result = []\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < nums.length; i++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  temp = [...nums.slice(\cf8 \cb5 0\cf4 \cb5 , i), ...nums.slice(i+\cf8 \cb5 1\cf4 \cb5 )];\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  c \cf6 \cb5 of\cf4 \cb5  permU(temp)) \{\cb1 \
\cb5                 result.push([nums[i], ...c]); \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 \cb5 while\cf4 \cb5 (nums[i+\cf8 \cb5 1\cf4 \cb5 ]==nums[i])i++; \cf10 \cb5 // skip\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  permU(nums);\cb1 \
\cb5 \};\cb1 \
\cb5 nums = [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ]\cb1 \
\cb5 permuteUnique(nums) \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 //[ [ 1, 1, 2 ], [ 1, 2, 1 ], [ 2, 1, 1 ] ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Range Sum of BST
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 Given the\'a0
\f4\fs26 \cf16 \cb17 root
\f3\fs28 \cf15 \cb3 \'a0node of a binary search tree, return the sum of values of all nodes with value between\'a0
\f4\fs26 \cf16 \cb17 L
\f3\fs28 \cf15 \cb3 \'a0and\'a0
\f4\fs26 \cf16 \cb17 R
\f3\fs28 \cf15 \cb3 \'a0(inclusive).\
The binary search tree is guaranteed to have unique values.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rangeSumBST = (root, \cf9 \cb5 L\cf4 \cb5 , \cf9 \cb5 R\cf4 \cb5 ) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf10 \cb5 // check if value is in the given range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  isInBetween = val => val >= \cf9 \cb5 L\cf4 \cb5  && val <= \cf9 \cb5 R\cf4 \cb5 ;\cb1 \
\cb5     \cf10 \cb5 // sum the value if it's in the range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  add = (val, sum) => isInBetween(val) ? sum += val : sum;\cb1 \
\cb5 \'a0\'a0\cf10 \cb5 // traverse through the nodes and sum the values in range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  preorder =(root, sum) => \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (!root) \cf6 \cb5 return\cf4 \cb5  sum;\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\cb1 \
\cb5     \} \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  preorder(root, \cf8 \cb5 0\cf4 \cb5 )\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shortest Path in Maze
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (x, y) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .x = x;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .y = y;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (pt, dist) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .pt = pt;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .dist = dist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  d = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: \cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: -\cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: -\cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \}\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  bfs(maze, src, dest) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 var\cf4 \cb5  minDist = -\cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (maze[src.x][src.y] != \cf8 \cb5 1\cf4 \cb5  || maze[dest.x][dest.y] != \cf8 \cb5 1\cf4 \cb5 )\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  h = maze.length;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  w = maze[\cf8 \cb5 0\cf4 \cb5 ].length;\cb1 \
\cb5   visited = [];\cb1 \
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < h; i++) \{\cb1 \
\cb5     visited.push([]);\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < w; j++) \{\cb1 \
\cb5       visited[i].push(\cf6 \cb5 false\cf4 \cb5 );\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  queue = [];\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  s = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (src, \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cb5   queue.push(s);\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (queue.length>\cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  curr = queue.pop();\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  pt = curr.pt;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (pt.x == dest.x && pt.y == dest.y)\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  curr.dist;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf8 \cb5 4\cf4 \cb5 ; i++) \{\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  row = pt.x + d[i].x;\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  col = pt.y + d[i].y;\cb1 \
\cb5       \cf6 \cb5 if\cf4 \cb5  (isValid(maze, visited, h, w, row, col)) \{\cb1 \
\cb5         visited[row][col] = \cf6 \cb5 true\cf4 \cb5 ;\cb1 \
\cb5         \cf6 \cb5 var\cf4 \cb5  adjCell = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (\cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (row, col), curr.dist + \cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5         queue.push(adjCell);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  isValid(maze, visited, width, height, row, col) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 return\cf4 \cb5  (row >= \cf8 \cb5 0\cf4 \cb5 ) && (row < width) && (col >= \cf8 \cb5 0\cf4 \cb5 ) && (col < height) && maze[row][col] == \cf8 \cb5 1\cf4 \cb5  && !visited[row][col];\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  maze = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ]\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  source = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dest = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 7\cf4 \cb5 , \cf8 \cb5 5\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dist = bfs(maze, source, dest);\cb1 \
\
\cf6 \cb5 if\cf4 \cb5  (dist != -\cf8 \cb5 1\cf4 \cb5 )\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `The shortest path from (\cf4 \cb5 $\{source.x\}\cf7 \cb5 , \cf4 \cb5 $\{source.y\}\cf7 \cb5 ) to (\cf4 \cb5 $\{dest.x\}\cf7 \cb5 , \cf4 \cb5 $\{dest.y\}\cf7 \cb5 ) has length \cf4 \cb5 $\{dist\}\cf7 \cb5 \\n`\cf4 \cb5 );\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 else\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `Shortest path from \cf4 \cb5 $\{(source.x, source.y)\}\cf7 \cb5  to \cf4 \cb5 $\{(dest.x, dest.y)\}\cf7 \cb5  does not exist`\cf4 \cb5 );\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Repeated Substring Pattern
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf15 \cb3 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  repeatedSubstringPattern = string => \{\cb1 \
\cb5     \cf6 if\cf4  (string.length === \cf8 0\cf4  || string.length === \cf8 1\cf4 ) \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i <= string.length / \cf8 2\cf4 ; i++) \{\cb1 \
\cb5         \cf6 if\cf4  (string.length % i === \cf8 0\cf4  && string.slice(\cf8 0\cf4 , i).repeat(string.length / i) === string) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  merge = (arr1, arr2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted = [];\cb1 \
\
\cb5   \cf6 while\cf4  (arr1.length && arr2.length) \{\cb1 \
\cb5     \cf6 if\cf4  (arr1[\cf8 0\cf4 ] < arr2[\cf8 0\cf4 ]) sorted.push(arr1.shift());\cb1 \
\cb5     \cf6 else\cf4  sorted.push(arr2.shift());\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 return\cf4  sorted.concat(arr1.slice().concat(arr2.slice()));\cb1 \
\cb5 \};\cb1 \
\
\cf6 \cb5 const\cf4  mergeSort = arr => \{\cb1 \
\cb5   \cf6 if\cf4  (arr.length <= \cf8 1\cf4 ) \cf6 return\cf4  arr;\cb1 \
\cb5   \cf6 let\cf4  mid = \cf9 Math\cf4 .floor(arr.length / \cf8 2\cf4 ),\cb1 \
\cb5       left = mergeSort(arr.slice(\cf8 0\cf4 , mid)),\cb1 \
\cb5       right = mergeSort(arr.slice(mid));\cb1 \
\
\cb5   \cf6 return\cf4  merge(left, right);\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Quick Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  quickSort = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 if\cf4  (arr.length <=\cf8 1\cf4  || arr === \cf6 null\cf4 ) \cf6 return\cf4  arr;\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  pivot = arr[arr.length - \cf8 1\cf4 ];\cb1 \
\cb5   \cf6 let\cf4  leftArr = [];\cb1 \
\cb5   \cf6 let\cf4  rightArr = [];\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  el \cf6 of\cf4  arr.slice(\cf8 0\cf4 , arr.length -\cf8 1\cf4 )) \{\cb1 \
\cb5     \cf6 if\cf4  (el < pivot) \{\cb1 \
\cb5       leftArr.push(el);\cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       rightArr.push(el);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  [...quickSort(leftArr), pivot, ...quickSort(rightArr)]\cb1 \
\cb5 \}\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Verifying an Alien Dictionary
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isAlienSorted = (words, order) => \{\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  charPosition = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Map\cf4 \strokec4 ()\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  position = \cf12 \strokec12 0\cf4 \strokec4 ; position < order.length; position++)\{\cb1 \
\cb11         \cf6 \strokec6 let\cf4 \strokec4  char = order[position]\cb1 \
\cb11         charPosition.\cf6 \strokec6 set\cf4 \strokec4 (char, position)\cb1 \
\cb11     \}\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf12 \strokec12 1\cf4 \strokec4 ; i < words.length; i++)\{\cb1 \
\cb11         \cf6 \strokec6 let\cf4 \strokec4  prev = words[i-\cf12 \strokec12 1\cf4 \strokec4 ], curr = words[i]\cb1 \
\cb11         \cf6 \strokec6 if\cf4 \strokec4 (charPosition.\cf6 \strokec6 get\cf4 \strokec4 (prev[\cf12 \strokec12 0\cf4 \strokec4 ]) > charPosition.\cf6 \strokec6 get\cf4 \strokec4 (curr[\cf12 \strokec12 0\cf4 \strokec4 ]))\cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb11         \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4 (prev[\cf12 \strokec12 0\cf4 \strokec4 ] === curr[\cf12 \strokec12 0\cf4 \strokec4 ])\{\cb1 \
\cb11             \cf6 \strokec6 let\cf4 \strokec4  pointer = \cf12 \strokec12 1\cf4 \cb1 \strokec4 \
\cb11             \cf6 \strokec6 while\cf4 \strokec4 (prev[pointer] === curr[pointer])pointer++\cb1 \
\cb11             \cf6 \strokec6 if\cf4 \strokec4 (curr[pointer] === \cf6 \strokec6 undefined\cf4 \strokec4 )\cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb11             \cf6 \strokec6 if\cf4 \strokec4 (charPosition.\cf6 \strokec6 get\cf4 \strokec4 (prev[pointer]) > charPosition.\cf6 \strokec6 get\cf4 \strokec4 (curr[pointer]))\cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb11         \}\cb1 \
\cb11     \}\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Destination City
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  destCity = paths => \{\cb1 \
\cb11     \cf6 \strokec6 const\cf4 \strokec4  result = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Set\cf4 \strokec4 (paths.map((path) => path[\cf12 \strokec12 0\cf4 \strokec4 ]));\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  paths.filter((path) => !result.has(path[\cf12 \strokec12 1\cf4 \strokec4 ])).pop()[\cf12 \strokec12 1\cf4 \strokec4 ]\cb1 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Parentheses
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isValid = str => \{\cb1 \
\cb11     \cf6 \strokec6 const\cf4 \strokec4  stack = []\cb1 \
\cb11     \cf6 \strokec6 const\cf4 \strokec4  keys = \{\cb1 \
\cb11         \cf19 \strokec19 '('\cf4 \strokec4 : \cf19 \strokec19 ')'\cf4 \strokec4 ,\cb1 \
\cb11         \cf19 \strokec19 '\{'\cf4 \strokec4 : \cf19 \strokec19 '\}'\cf4 \strokec4 ,\cb1 \
\cb11         \cf19 \strokec19 '['\cf4 \strokec4 : \cf19 \strokec19 ']'\cf4 \strokec4 ,\cb1 \
\cb11     \}\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 const\cf4 \strokec4  char \cf6 \strokec6 of\cf4 \strokec4  str) \{\cb1 \
\cb11         \cf6 \strokec6 if\cf4 \strokec4  (char \cf6 \strokec6 in\cf4 \strokec4  keys) \{\cb1 \
\cb11             stack.push(keys[char])\cb1 \
\cb11         \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb11             \cf6 \strokec6 if\cf4 \strokec4  (stack.length === \cf12 \strokec12 0\cf4 \strokec4  || stack.pop() !== char) \{\cb1 \
\cb11                 \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb11             \}\cb1 \
\cb11         \}\cb1 \
\cb11     \}\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  stack.length === \cf12 \strokec12 0\cf4 \cb1 \strokec4 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb11 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  maxProfit = prices => \{\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  length = prices.length;\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  bestBuy = prices[\cf12 \strokec12 0\cf4 \strokec4 ];\cb1 \
\cb11     \cf6 \strokec6 let\cf4 \strokec4  profit = \cf12 \strokec12 0\cf4 \strokec4 ;\cb1 \
\cb11     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf12 \strokec12 1\cf4 \strokec4 ; i < length; i++) \{\cb1 \
\cb11         bestBuy = \cf13 \strokec13 Math\cf4 \strokec4 .min(bestBuy, prices[i])\cb1 \
\cb11         profit = \cf13 \strokec13 Math\cf4 \strokec4 .max(profit, prices[i] - bestBuy);\cb1 \
\cb11     \};\cb1 \
\cb11     \cf6 \strokec6 return\cf4 \strokec4  profit;\cb1 \
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf20 \cb21 \outl0\strokewidth0 \strokec20 Input:
\f1\b0  [7,1,5,3,6,4]\

\f0\b Output:
\f1\b0  5\

\f0\b Explanation:
\f1\b0  Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\
\'a0            Not 7-1 = 6, as selling price needs to be larger than buying price.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Next Problem
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  functionName = arr => \{\cb1 \
\
\}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Next Problem
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  functionName = arr => \{\cb1 \
\
\}\
}