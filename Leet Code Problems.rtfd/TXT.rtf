{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fnil\fcharset0 HelveticaNeue-Italic;\f5\fnil\fcharset0 HelveticaNeue-Bold;
\f6\fmodern\fcharset0 Courier;\f7\fnil\fcharset0 Menlo-Italic;\f8\fnil\fcharset0 HelveticaNeue-BoldItalic;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red127\green127\blue127;\red154\green154\blue154;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
\red78\green106\blue120;\red78\green78\blue78;\red107\green0\blue1;\red253\green128\blue8;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c57046\c57047\c57046;\cssrgb\c66667\c66667\c66667;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
\cssrgb\c37647\c49020\c54510;\cssrgb\c38039\c38039\c38039;\cssrgb\c50196\c0\c0;\cssrgb\c100000\c57637\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\margl1440\margr1440\vieww33500\viewh19880\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  sumAll = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \
// Fibonacci O(2^n) or O(n) with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  fibonacci = (num, memo = \{\}) => \{\cb1 \
\cb5     \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[num] = fibonacci(num - \cf8 1\cf4 , memo) + fibonacci(num - \cf8 2\cf4 , memo)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[num]\cb1 \
\cb5 \}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Factorial with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  factorial = (num, memo = \{\}) => \{\cb1 \
\cb5     \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[num] = factorial(num - \cf8 1\cf4 , memo) * num\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[num]\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \
\
// Two Sum
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \expnd0\expndtw0\kerning0
1. Create idx variable\
2. Create result variable\
3. nums.forEach(num, i)\
4. Create complement variable\
5. Check if idx.has(complement). If so, set result[0] and result[1]\
6. Set idx
\f2 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
const\cf4  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cf10 \cb5 twoSum([2, 3, 8, 7, 4], 9) \cf11 \
Output: [0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Three Sum
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  threeSum = nums => \{\cb1 \
\cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf6 let\cf4  t = -nums[i];\cb1 \
\cb5         \cf6 let\cf4  left = i+\cf8 1\cf4 , right = nums.length-\cf8 1\cf4 ;\cb1 \
\cb5         \cf6 while\cf4 (left < right) \{\cb1 \
\cb5             \cf6 if\cf4  (nums[left] + nums[right] == t) \{\cb1 \
\cb5                 result.push([nums[i], nums[left], nums[right]]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[left+\cf8 1\cf4 ] == nums[left++]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[right-\cf8 1\cf4 ] == nums[right--]);\cb1 \
\cb5             \} \cf6 else\cf4  \cf6 if\cf4  (nums[left]+nums[right] < t) left++;\cb1 \
\cb5             \cf6 else\cf4  right--;\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 while\cf4 (nums[i+\cf8 1\cf4 ]==nums[i]) i++\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5     \cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  mySqrt = num => \{\cb1 \
\cb5   \cf6 let\cf4  start = \cf8 0\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  end = num;\cb1 \
\cb5   \cf6 while\cf4  (start <= end) \{\cb1 \
\cb5 	\cf6 const\cf4  mid = \cf9 Math\cf4 .floor(start + (end - start) / \cf8 2\cf4 );\cb1 \
\cb5 	\cf6 const\cf4  mid2 = mid * mid;\cb1 \
\cb5 	  \cf6 if\cf4  (num === mid2) \{\cb1 \
\cb5 		\cf6 return\cf4  mid;\cb1 \
\cb5 	  \} \
	  \cf6 else\cf4  \cf6 if\cf4  (num < mid2) \{\cb1 \
\cb5 		end = mid - \cf8 1\cf4 ;\cb1 \
\cb5 	  \} \
	  \cf6 else\cf4  \{\cb1 \
\cb5 		start = mid + \cf8 1\cf4 ;\cb1 \
\cb5 	  \}\cb1 \
\cb5   \}\
\cb1   \cf6 \cb5 return\cf4  end;\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 1. Create runningTotal variable\
2. Set runningTotal[0] and runningTotal[1]\
3. forLoop(i=2)\
4. Set runningTotal[i]\cf6 \
\
const\cf4  rob = nums => \{\cb1 \
\cb5   \cf6 if\cf4  (nums.length === \cf8 0\cf4  || nums === \cf6 null\cf4 ) \{\cb1 \
\cb5 	\cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5   \} \cf6 else\cf4  \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \{\cb1 \
\cb5 	\cf6 return\cf4  nums[\cf8 0\cf4 ];\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 let\cf4  runningTotal = [];\cb1 \
\cb5   runningTotal[\cf8 0\cf4 ] = nums[\cf8 0\cf4 ],\cb1 \
\cb5   runningTotal[\cf8 1\cf4 ] = \cf9 Math\cf4 .max(nums[\cf8 0\cf4 ], nums[\cf8 1\cf4 ]);\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 2\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5 	runningTotal[i] = \cf9 Math\cf4 .max(nums[i] + runningTotal[i - \cf8 2\cf4 ], runningTotal[i - \cf8 1\cf4 ]);\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  runningTotal[runningTotal.length - \cf8 1\cf4 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numberOfSteps = num => \{\cb1 \
\cb5   \cf6 let\cf4  count = \cf8 0\cf4 \cb1 \
\
\cb5   \cf6 while\cf4  (num > \cf8 0\cf4 ) \{\cb1 \
\cb5 	\cf6 if\cf4  (num % \cf8 2\cf4  === \cf8 1\cf4 ) \{\cb1 \
\cb5 	  num = num - \cf8 1\cf4 \cb1 \
\cb5 	  count ++\cb1 \
\cb5 	\} \cf6 else\cf4  \{\cb1 \
\cb5 		num = num / \cf8 2\cf4 \cb1 \
\cb5 		count ++\cb1 \
\cb5 	\}\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numIslands = grid => \{\cb1 \
\cb5   \cf6 const\cf4  height = grid.length;\cb1 \
\cb5   \cf6 const\cf4  width = height && grid[\cf8 0\cf4 ].length;\
\cb1 \
\cb5   \cf6 let\cf4  count = \cf8 0\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < height; row++) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < width; col++) \{\cb1 \
\cb5       \cf6 if\cf4  (grid[row][col] === \cf7 '0'\cf4 ) \cf6 continue\cf4 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\
\cb1 \
\cb5   \cf6 return\cf4  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 function\cf4  dfs(row, col) \{\cb1 \
\cb5     \cf6 if\cf4  (row < \cf8 0\cf4  || col < \cf8 0\cf4  || row === height || col === width || grid[row][col] === \cf7 '0'\cf4 ) \cf6 return\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 '0'\cf4 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf4 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Max Area of Island\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0 \cf4 \cb5 \
\cf6 const\cf4  maxAreaOfIsland = (grid) => \{\cb1 \
\cb5     \cf6 const\cf4  res = \{ count: \cf8 0\cf4  \}\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  r = \cf8 0\cf4 ; r < grid.length; r++) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  c = \cf8 0\cf4 ; c < grid[\cf8 0\cf4 ].length; c++) \{\cb1 \
\cb5             dfs(grid, r, c, res)\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  res.count\cb1 \
\cb5 \};\cb1 \
\
\cf6 \cb5 const\cf4  dfs = (grid, r, c, res, area = \{ count: \cf8 0\cf4  \}) => \{\cb1 \
\cb5     \cf6 if\cf4  (!grid[r] || !grid[r][c]) \cf6 return\cf4 \cb1 \
\cb5     res.count = \cf9 Math\cf4 .max(res.count, area.count += grid[r][c])\cb1 \
\cb5     grid[r][c] = \cf8 0\cf4 \cb1 \
\cb5     dfs(grid, r, c - \cf8 1\cf4 , res, area)\cb1 \
\cb5     dfs(grid, r, c + \cf8 1\cf4 , res, area)\cb1 \
\cb5     dfs(grid, r - \cf8 1\cf4 , c, res, area)\cb1 \
\cb5     dfs(grid, r + \cf8 1\cf4 , c, res, area)\cb1 \
\cb5 \};\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Number in Array
\f1\b0 \cf4 \cb5 \
1. Create finalNums variable with map\
2. Sort finalNums\
3. Check if(finalNums[0]===\'910\'92)\
4. Return finalNums.join()\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  largestNumber = nums => \{\cb1 \
\cb5     \cf6 const\cf4  finalNums = nums.map(num => num.toString());\cb1 \
\
\cb5     finalNums.sort((a, b) => \cf7 `\cf4 $\{b\}$\{a\}\cf7 `\cf4  - \cf7 `\cf4 $\{a\}$\{b\}\cf7 `\cf4 );\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4 (finalNums[\cf8 0\cf4 ] === \cf7 '0'\cf4 ) \cf6 return\cf4  \cf7 '0'\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  finalNums.join(\cf7 ''\cf4 );\cb1 \
\cb5 \};\cb1 \
\
\
\cf10 \cb5 Input: [3,30,34,5,9]\cb1 \
\cb5 Output: "9534330"\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 1. Create target variable\
2. Create forInLoop\
3. Return target variable\
\
\cf6 const\cf4  createTargetArray = (nums, idx) => \{\cb1 \
\cb5   \cf6 let\cf4  target = []\cb1 \
\cb5   \cf6 for\cf4 (\cf6 let\cf4  num \cf6 in\cf4  nums)target.splice(idx[num], \cf8 0\cf4 , nums[num])\cb1 \
\cb5   \cf6 return\cf4  target\cb1 \
\cb5 \};\cb1 \
\
\
\cf10 \cb5 let nums = [0,1,2,3,4]\cb1 \
\cb5 let index = [0,1,2,2,1]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf11 \cb5 Output: [0,4,1,3,2]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  climbStairs = num => \{\cb1 \
\cb5   \cf6 let\cf4  arr = [\cf8 1\cf4 , \cf8 2\cf4 , \cf8 3\cf4 ];\cb1 \
\cb5   \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 3\cf4 ; i < num; i++)\{\cb1 \
\cb5 	arr[i] = arr[i - \cf8 1\cf4 ] + arr[i - \cf8 2\cf4 ];\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  arr[num - \cf8 1\cf4 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Image 90deg
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 You are given an\'a0
\f4\i n
\f3\i0 \'a0x\'a0
\f4\i n
\f3\i0 \'a02D matrix representing an image.\
Rotate the image by 90 degrees (clockwise).\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.\'a0
\f5\b DO NOT
\f3\b0 \'a0allocate another 2D matrix and do the rotation.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\cf6 const\cf4  rotate = grid => \{\cb1 \
\
\cf6 \cb5   for \cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < grid.length; i++) \{\cb1 \
\cf6 \cb5 	for \cf4 (\cf6 let\cf4  j = \cf8 0\cf4 ; j < i; j++) \{\cb1 \
\
\cf6 \cb5 	let\cf4  temp = grid[i][j];\cb1 \
\cb5 	grid[i][j] = grid[j][i];\cb1 \
\cb5 	grid[j][i] = temp;\cb1 \
\
\cb5 	\}\cb1 \
\cb5   \}\cb1 \
\
\cf6 \cb5   for\cf4  (\cf6 let\cf4  g \cf6 of\cf4  grid) g.reverse()\cb1 \
\
\cf6 \cb5   return\cf4  grid\cb1 \
\cb5 \};\cb1 \
\
\
\cf6 \cb5 let\cf4  x = [\cb1 \
\cb5   [\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 3\cf4 ],\cb1 \
\cb5   [\cf8 4\cf4 ,\cf8 5\cf4 ,\cf8 6\cf4 ],\cb1 \
\cb5   [\cf8 7\cf4 ,\cf8 8\cf4 ,\cf8 9\cf4 ]\cb1 \
\cb5 ]\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf11 \cb5 // [\cf4 \cb1 \
\cf11 \cb5 //  [7,4,1],\cf4 \cb1 \
\cf11 \cb5 //  [8,5,2],\cf4 \cb1 \
\cf11 \cb5 //  [9,6,3]\cf4 \cb1 \
\cf11 \cb5 // ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Square in Grid
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  largestSquare = grid => \{\cb1 \
\cb5     \cf6 let\cf4  height = grid.length;\cb1 \
\cb5     \cf6 let\cf4  width = height ? grid[\cf8 0\cf4 ].length : \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 let\cf4  max = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < height; row++) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < width; col++) \{\cb1 \
\cb5             \cf6 let\cf4  left = col === \cf8 0\cf4  ? \cf8 0\cf4  : grid[row][col - \cf8 1\cf4 ];\cb1 \
\cb5             \cf6 let\cf4  up = row === \cf8 0\cf4  ? \cf8 0\cf4  : grid[row - \cf8 1\cf4 ][col];\cb1 \
\cb5             \cf6 let\cf4  back = row && col ? grid[row - \cf8 1\cf4 ][col - \cf8 1\cf4 ] : \cf8 0\cf4 ;\cb1 \
\cb5             \cf6 if\cf4  (grid[row][col] == \cf8 1\cf4 ) \{\cb1 \
\cb5                 grid[row][col] = \cf9 \cb5 Math\cf4 \cb5 .min(left, up, back) + grid[row][col] * \cf8 1\cf4 ;\cb1 \
\cb5             \} \cf6 else\cf4  \{\cb1 \
\cb5                 grid[row][col] = \cf8 0\cf4 ;\cb1 \
\cb5             \};\cb1 \
\cb5             max = \cf9 \cb5 Math\cf4 \cb5 .max(max, grid[row][col])\cb1 \
\cb5 ;\cb1 \
\cb5         \};\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  max * max;\cb1 \
\cb5 \};\
\
\cf10 let items = [\cb1 \
\cb5   [0, 1, 1, 0, 1],\cb1 \
\cb5   [1, 0, 1, 0, 1],\cb1 \
\cb5   [1, 1, 1, 1, 1],\cb1 \
\cb5   [0, 1, 1, 1, 1],\cb1 \
\cb5   [0, 0, 1, 0, 1]\cb1 \
\cb5 ]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Transpose Matrix 
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  transpose = arr => \{\cb1 \
\cb5   \cf6 if\cf4 (arr.length === \cf8 0\cf4 ) \cf6 return\cf4  [];\cb1 \
\cb5   \cf6 let\cf4  width = arr[\cf8 0\cf4 ].length \cb1 \
\cb5   \cf6 let\cf4  height = arr.length;\cb1 \
\cb5   \cf6 let\cf4  result = [];\cb1 \
\cb5   \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < width; i++) \{\cb1 \
\cb5 	result[i] = [];\cb1 \
\cb5 	  \cf6 for\cf4 (\cf6 let\cf4  j = \cf8 0\cf4 ; j < height; j++) \{\cb1 \
\cb5 		result[i][j] = arr[j][i];\cb1 \
\cb5 	  \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  result;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf10 \cb3 Input: 
\f1\b0 [[1,2,3],\
	    [4,5,6],\
	    [7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],\
		[2,5,8],\
		[3,6,9]]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm.  Dynamic Programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given an integer array\'a0
\f6 \cf13 \cb14 nums
\f3 \cf12 \cb3 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  maxSubArray = nums => \{\cb1 \
\cb5     \cf6 let\cf4  currentMax = nums[\cf8 0\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  max = nums[\cf8 0\cf4 ];\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  num \cf6 of\cf4  nums) \{\cb1 \
\cb5     currentMax = \cf9 Math\cf4 .max(num, num + currentMax);\cb1 \
\cb5     max = \cf9 Math\cf4 .max(max, currentMax);\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  max;\cb1 \
\cb5 \};\cb1 \
\
\cb5 maxSubArray([\cf8 1\cf4 , \cf8 3\cf4 , -\cf8 4\cf4 , \cf8 4\cf4 , -\cf8 6\cf4 , \cf8 3\cf4 , \cf8 9\cf4 , -\cf8 11\cf4 , \cf8 10\cf4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Product Except Self
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array\'a0
\f6 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0of\'a0
\f4\i n
\f3\i0 \'a0integers where\'a0
\f4\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f6 \cf13 \cb14 output
\f3 \cf12 \cb3 \'a0such that\'a0
\f6 \cf13 \cb14 output[i]
\f3 \cf12 \cb3 \'a0is equal to the product of all the elements of\'a0
\f6 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0except\'a0
\f6 \cf13 \cb14 nums[i]
\f3 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb14 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f5\b Note:\'a0
\f3\b0 Please solve it\'a0
\f5\b without division
\f3\b0 \'a0and in O(
\f4\i n
\f3\i0 ).
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\cf6 const\cf4  productExceptSelf = nums => \{\cb1 \
\cb5     \cf6 let\cf4  result = [\cf8 1\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  temp = \cf8 1\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         result[i] = result[i - \cf8 1\cf4 ] * nums[i - \cf8 1\cf4 ];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = nums.length - \cf8 1\cf4 ; i >= \cf8 0\cf4 ; i--) \{\cb1 \
\cb5         result[i] *= temp;\cb1 \
\cb5         temp *= nums[i];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Tower of Hanoi (Recursion)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  hanoiTower = (height, srcP, destP, bufferP) => \{\cb1 \
\cb5   \cf6 if\cf4  (height >= \cf8 1\cf4 ) \{\cb1 \
\
\cb5     \cf11 // Move a tower of height-1 to the buffer peg, using the destination peg.\cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 1\cf4 , srcP, bufferP, destP);\cb1 \
\
\cb5     \cf11 // Move the remaining disk to the destination peg.\cf4 \cb1 \
\cb5     console.log(\cf7 'Move disk from Tower '\cf4 , srcP, \cf7 ' to Tower '\cf4 , destP);\cb1 \
\
\cb5     \cf11 // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.        \cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 1\cf4 , bufferP, destP, srcP);\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 return\cf4 ;\cb1 \
\cb5 \}\cb1 \
\
\cb5 hanoiTower(\cf8 3\cf4 , \cf7 "A"\cf4 , \cf7 "C"\cf4 , \cf7 "B"\cf4 );\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  permute = (nums, memo = \cf8 0\cf4 ) => \{\cb1 \
\cb5     \cf6 if\cf4  (memo >= nums.length) \cf6 return\cf4  [[]];\cb1 \
\cb5     \cf6 const\cf4  result = [];\cb1 \
\cb5     \cf6 const\cf4  prevs = permute(nums, memo + \cf8 1\cf4 );  \cf11 // permutations of elements after n\cf4 \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  prev \cf6 of\cf4  prevs) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i <= prev.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  p = prev.slice(\cf8 0\cf4 );\cb1 \
\cb5             p.splice(i, \cf8 0\cf4 , nums[memo]);  \cf11 // successively insert element n\cf4 \cb1 \
\cb5             result.push(p); \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations 2 (Unique)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0
\cf6 const\cf4  permuteUnique = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  permU = \cf6 function\cf4 (nums) \{\cb1 \
\cb5         \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \cf6 return\cf4  [nums];\cb1 \
\cb5         \cf6 let\cf4  result = []\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  temp = [...nums.slice(\cf8 0\cf4 , i), ...nums.slice(i+\cf8 1\cf4 )];\cb1 \
\cb5             \cf6 for\cf4  (\cf6 let\cf4  c \cf6 of\cf4  permU(temp)) \{\cb1 \
\cb5                 result.push([nums[i], ...c]); \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 while\cf4 (nums[i+\cf8 1\cf4 ]==nums[i])i++; \cf11 // skip\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  permU(nums);\cb1 \
\cb5 \};\cb1 \
\cb5 nums = [\cf8 1\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ]\cb1 \
\cb5 permuteUnique(nums) \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf11 \cb5 //[ [ 1, 1, 2 ], [ 1, 2, 1 ], [ 2, 1, 1 ] ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Range Sum of BST
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given the\'a0
\f6\fs26 \cf13 \cb14 root
\f3\fs28 \cf12 \cb3 \'a0node of a binary search tree, return the sum of values of all nodes with value between\'a0
\f6\fs26 \cf13 \cb14 L
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f6\fs26 \cf13 \cb14 R
\f3\fs28 \cf12 \cb3 \'a0(inclusive).\
The binary search tree is guaranteed to have unique values.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  rangeSumBST = (root, \cf9 L\cf4 , \cf9 R\cf4 ) => \{\cb1 \
\cb5     \cf11 // check if value is in the given range\cf4 \cb1 \
\cb5     \cf6 const\cf4  isInBetween = val => val >= \cf9 L\cf4  && val <= \cf9 R\cf4 ;\cb1 \
\cb5     \cf11 // sum the value if it's in the range\cf4 \cb1 \
\cb5     \cf6 const\cf4  add = (val, sum) => isInBetween(val) ? sum += val : sum;\cb1 \
\cb5 \'a0\'a0\cf11 // traverse through the nodes and sum the values in range\cf4 \cb1 \
\cb5     \cf6 const\cf4  preorder =(root, sum) => \{\cb1 \
\cb5         \cf6 if\cf4  (!root) \cf6 return\cf4  sum;\cb1 \
\cb5         \cf6 return\cf4  add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\cb1 \
\cb5     \} \cb1 \
\cb5     \cf6 return\cf4  preorder(root, \cf8 0\cf4 )\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shortest Path in Maze
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 function\cf4  \cf9 Point\cf4 (x, y) \{\cb1 \
\cb5   \cf6 this\cf4 .x = x;\cb1 \
\cb5   \cf6 this\cf4 .y = y;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 function\cf4  \cf9 Node\cf4 (pt, dist) \{\cb1 \
\cb5   \cf6 this\cf4 .pt = pt;\cb1 \
\cb5   \cf6 this\cf4 .dist = dist;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 var\cf4  d = [\cb1 \
\cb5   \{x: \cf8 0\cf4 , y: \cf8 1\cf4 \},\cb1 \
\cb5   \{x: \cf8 1\cf4 , y: \cf8 0\cf4 \},\cb1 \
\cb5   \{x: \cf8 0\cf4 , y: -\cf8 1\cf4 \},\cb1 \
\cb5   \{x: -\cf8 1\cf4 , y: \cf8 0\cf4 \}\cb1 \
\cb5 ];\cb1 \
\
\cf6 \cb5 function\cf4  bfs(maze, src, dest) \{\cb1 \
\cb5   \cf6 var\cf4  minDist = -\cf8 1\cf4 ;\cb1 \
\cb5     \cf6 if\cf4  (maze[src.x][src.y] != \cf8 1\cf4  || maze[dest.x][dest.y] != \cf8 1\cf4 )\cb1 \
\cb5       \cf6 return\cf4  minDist;\cb1 \
\cb5   \cf6 var\cf4  h = maze.length;\cb1 \
\cb5   \cf6 var\cf4  w = maze[\cf8 0\cf4 ].length;\cb1 \
\cb5   visited = [];\cb1 \
\cb5   \cf6 for\cf4  (\cf6 var\cf4  i = \cf8 0\cf4 ; i < h; i++) \{\cb1 \
\cb5     visited.push([]);\cb1 \
\cb5     \cf6 for\cf4  (\cf6 var\cf4  j = \cf8 0\cf4 ; j < w; j++) \{\cb1 \
\cb5       visited[i].push(\cf6 false\cf4 );\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 var\cf4  queue = [];\cb1 \
\cb5   \cf6 var\cf4  s = \cf6 new\cf4  \cf9 Node\cf4 (src, \cf8 0\cf4 );\cb1 \
\cb5   queue.push(s);\cb1 \
\
\cb5   \cf6 while\cf4  (queue.length>\cf8 0\cf4 ) \{\cb1 \
\cb5     \cf6 var\cf4  curr = queue.pop();\cb1 \
\cb5     \cf6 var\cf4  pt = curr.pt;\cb1 \
\cb5     \cf6 if\cf4  (pt.x == dest.x && pt.y == dest.y)\cb1 \
\cb5       \cf6 return\cf4  curr.dist;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 var\cf4  i = \cf8 0\cf4 ; i < \cf8 4\cf4 ; i++) \{\cb1 \
\cb5       \cf6 var\cf4  row = pt.x + d[i].x;\cb1 \
\cb5       \cf6 var\cf4  col = pt.y + d[i].y;\cb1 \
\cb5       \cf6 if\cf4  (isValid(maze, visited, h, w, row, col)) \{\cb1 \
\cb5         visited[row][col] = \cf6 true\cf4 ;\cb1 \
\cb5         \cf6 var\cf4  adjCell = \cf6 new\cf4  \cf9 Node\cf4 (\cf6 new\cf4  \cf9 Point\cf4 (row, col), curr.dist + \cf8 1\cf4 );\cb1 \
\cb5         queue.push(adjCell);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  minDist;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 function\cf4  isValid(maze, visited, width, height, row, col) \{\cb1 \
\cb5   \cf6 return\cf4  (row >= \cf8 0\cf4 ) && (row < width) && (col >= \cf8 0\cf4 ) && (col < height) && maze[row][col] == \cf8 1\cf4  && !visited[row][col];\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 var\cf4  maze = [\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ]\cb1 \
\cb5 ];\cb1 \
\
\cf6 \cb5 var\cf4  source = \cf6 new\cf4  \cf9 Point\cf4 (\cf8 0\cf4 , \cf8 0\cf4 );\cb1 \
\cf6 \cb5 var\cf4  dest = \cf6 new\cf4  \cf9 Point\cf4 (\cf8 7\cf4 , \cf8 5\cf4 );\cb1 \
\cf6 \cb5 var\cf4  dist = bfs(maze, source, dest);\cb1 \
\
\cf6 \cb5 if\cf4  (dist != -\cf8 1\cf4 )\cb1 \
\cb5   console.log(\cf7 `The shortest path from (\cf4 $\{source.x\}\cf7 , \cf4 $\{source.y\}\cf7 ) to (\cf4 $\{dest.x\}\cf7 , \cf4 $\{dest.y\}\cf7 ) has length \cf4 $\{dist\}\cf7 \\n`\cf4 );\cb1 \
\cf6 \cb5 else\cf4 \cb1 \
\cb5   console.log(\cf7 `Shortest path from \cf4 $\{(source.x, source.y)\}\cf7  to \cf4 $\{(dest.x, dest.y)\}\cf7  does not exist`\cf4 );\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Repeated Substring Pattern
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  repeatedSubstringPattern = string => \{\cb1 \
\cb5     \cf6 if\cf4  (string.length === \cf8 0\cf4  || string.length === \cf8 1\cf4 ) \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i <= string.length / \cf8 2\cf4 ; i++) \{\cb1 \
\cb5         \cf6 if\cf4  (string.length % i === \cf8 0\cf4  && string.slice(\cf8 0\cf4 , i).repeat(string.length / i) === string) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  merge = (arr1, arr2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted = [];\cb1 \
\
\cb5   \cf6 while\cf4  (arr1.length && arr2.length) \{\cb1 \
\cb5     \cf6 if\cf4  (arr1[\cf8 0\cf4 ] < arr2[\cf8 0\cf4 ]) sorted.push(arr1.shift());\cb1 \
\cb5     \cf6 else\cf4  sorted.push(arr2.shift());\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 return\cf4  sorted.concat(arr1.slice().concat(arr2.slice()));\cb1 \
\cb5 \};\cb1 \
\
\cf6 \cb5 const\cf4  mergeSort = arr => \{\cb1 \
\cb5   \cf6 if\cf4  (arr.length <= \cf8 1\cf4 ) \cf6 return\cf4  arr;\cb1 \
\cb5   \cf6 let\cf4  mid = \cf9 Math\cf4 .floor(arr.length / \cf8 2\cf4 ),\cb1 \
\cb5       left = mergeSort(arr.slice(\cf8 0\cf4 , mid)),\cb1 \
\cb5       right = mergeSort(arr.slice(mid));\cb1 \
\
\cb5   \cf6 return\cf4  merge(left, right);\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Quick Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  quickSort = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 if\cf4  (arr.length <= \cf8 1\cf4  || arr === \cf6 null\cf4 ) \cf6 return\cf4  arr;\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  pivot = arr[arr.length - \cf8 1\cf4 ];\cb1 \
\cb5   \cf6 let\cf4  leftArr = [];\cb1 \
\cb5   \cf6 let\cf4  rightArr = [];\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  el \cf6 of\cf4  arr.slice(\cf8 0\cf4 , arr.length - \cf8 1\cf4 )) \{\cb1 \
\cb5     \cf6 if\cf4  (el < pivot) \{\cb1 \
\cb5       leftArr.push(el);\cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       rightArr.push(el);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  [...quickSort(leftArr), pivot, ...quickSort(rightArr)]\cb1 \
\cb5 \}\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Verifying an Alien Dictionary
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isAlienSorted = (words, order) => \{\cb1 \
\cb5     \cf6 let\cf4  charPosition = \cf6 new\cf4  \cf9 Map\cf4 ()\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  position = \cf8 0\cf4 ; position < order.length; position++)\{\cb1 \
\cb5         \cf6 let\cf4  char = order[position]\cb1 \
\cb5         charPosition.\cf6 set\cf4 (char, position)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 1\cf4 ; i < words.length; i++)\{\cb1 \
\cb5         \cf6 let\cf4  prev = words[i-\cf8 1\cf4 ], curr = words[i]\cb1 \
\cb5         \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[\cf8 0\cf4 ]) > charPosition.\cf6 get\cf4 (curr[\cf8 0\cf4 ]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \cf6 else\cf4  \cf6 if\cf4 (prev[\cf8 0\cf4 ] === curr[\cf8 0\cf4 ])\{\cb1 \
\cb5             \cf6 let\cf4  pointer = \cf8 1\cf4 \cb1 \
\cb5             \cf6 while\cf4 (prev[pointer] === curr[pointer])pointer++\cb1 \
\cb5             \cf6 if\cf4 (curr[pointer] === \cf6 undefined\cf4 )\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[pointer]) > charPosition.\cf6 get\cf4 (curr[pointer]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 true\cf4 \cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Destination City
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 You are given the array\'a0
\f6\fs26 \cf13 \cb14 paths
\f3\fs28 \cf12 \cb3 , where\'a0
\f6\fs26 \cf13 \cb14 paths[i] = [cityA
\fs19\fsmilli9750 i
\fs26 , cityB
\fs19\fsmilli9750 i
\fs26 ]
\f3\fs28 \cf12 \cb3 \'a0means there\'a0exists a direct path going from\'a0
\f6\fs26 \cf13 \cb14 cityA
\fs19\fsmilli9750 i
\f3\fs28 \cf12 \cb3 \'a0to\'a0
\f6\fs26 \cf13 \cb14 cityB
\fs19\fsmilli9750 i
\f3\fs28 \cf12 \cb3 .\'a0
\f4\i Return the destination city, that is, the city without any path outgoing to another city.
\f3\i0 \
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]\

\f0\b Output:
\f1\b0  "Sao Paulo" \

\f0\b Explanation:
\f1\b0  Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  destCity = paths => \{\cb1 \
\cb5     \cf6 const\cf4  result = \cf6 new\cf4  \cf9 Set\cf4 (paths.map((path) => path[\cf8 0\cf4 ]));\cb1 \
\cb5     \cf6 return\cf4  paths.filter((path) => !result.has(path[\cf8 1\cf4 ])).pop()[\cf8 1\cf4 ]\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Parentheses
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a string containing just the characters\'a0
\f6\fs26 \cf13 \cb14 '('
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 ')'
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 '\{'
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 '\}'
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 '['
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f6\fs26 \cf13 \cb14 ']'
\f3\fs28 \cf12 \cb3 , determine if the input string is valid.\
An input string is valid if:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Open brackets must be closed by the same type of brackets.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Open brackets must be closed in the correct order.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 Note that an empty string is\'a0also considered valid.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  "()"\

\f0\b Output:
\f1\b0  true\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  isValid = str => \{\cb1 \
\cb5     \cf6 const\cf4  stack = []\cb1 \
\cb5     \cf6 const\cf4  keys = \{\cb1 \
\cb5         \cf7 '('\cf4 : \cf7 ')'\cf4 ,\cb1 \
\cb5         \cf7 '\{'\cf4 : \cf7 '\}'\cf4 ,\cb1 \
\cb5         \cf7 '['\cf4 : \cf7 ']'\cf4 ,\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  char \cf6 of\cf4  str) \{\cb1 \
\cb5         \cf6 if\cf4  (char \cf6 in\cf4  keys) \{\cb1 \
\cb5             stack.push(keys[char])\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             \cf6 if\cf4  (stack.length === \cf8 0\cf4  || stack.pop() !== char) \{\cb1 \
\cb5                 \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  stack.length === \cf8 0\cf4 \cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Say you have an array for which the\'a0
\f4\i i
\f3\i0\fs21 th
\fs28 \'a0element is the price of a given stock on day\'a0
\f4\i i
\f3\i0 .\
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\
Note that you cannot sell a stock before you buy one.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [7,1,5,3,6,4]\

\f0\b Output:
\f1\b0  5\

\f0\b Explanation:
\f1\b0  Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\
\'a0            Not 7-1 = 6, as selling price needs to be larger than buying price.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  bestBuy = prices[\cf8 0\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < prices.length; i++) \{\cb1 \
\cb5         bestBuy = \cf9 Math\cf4 .min(bestBuy, prices[i])\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit, prices[i] - bestBuy);\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock II
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Say you have an array\'a0
\f6\fs26 \cf13 \cb14 prices
\f3\fs28 \cf12 \cb3 \'a0for which the\'a0
\f4\i i
\f3\i0\fs21 th
\fs28 \'a0element is the price of a given stock on day\'a0
\f4\i i
\f3\i0 .\
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \'a0You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\

\f5\b Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [7,1,5,3,6,4]\

\f0\b Output:
\f1\b0  7\

\f0\b Explanation:
\f1\b0  Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\
\'a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < prices.length - \cf8 1\cf4 ; i++) \{\cb1 \
\cb5         \cf6 const\cf4  possibleProfit = prices[i + \cf8 1\cf4 ] - prices[i];\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit + possibleProfit, profit);\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Integer
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a 32-bit signed integer, reverse digits of an integer.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  123\

\f0\b Output:
\f1\b0  321\
\pard\pardeftab720\partightenfactor0

\f5\b\fs28 \cf12 \cb3 \
Note:
\f3\b0 \
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\uc0\u8722 2
\fs21 31
\fs28 ,\'a0 2
\fs21 31\'a0
\fs28 \uc0\u8722  1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  reverseInt = x => \{\cb1 \
\cb5     \cf6 const\cf4  max = \cf9 Math\cf4 .pow(\cf8 2\cf4 , \cf8 31\cf4 ) - \cf8 1\cf4 \cb1 \
\cb5     \cf6 const\cf4  min = \cf9 Math\cf4 .pow(-\cf8 2\cf4 , \cf8 31\cf4 )\cb1 \
\cb5     \cf6 const\cf4  sign = \cf9 Math\cf4 .sign(x)\cb1 \
\cb5     \cf6 const\cf4  num = (x * sign).toString().split(\cf7 ''\cf4 ).reverse().join(\cf7 ''\cf4 )\cb1 \
\cb5     \cf6 const\cf4  result = \cf9 Number\cf4 (num) * sign\cb1 \
\cb5     \cf6 return\cf4  result > min && result < max ? result : \cf8 0\cf4 \cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Longest Common Prefix\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf12 Write a function to find the longest common prefix string amongst an array of strings.\
If there is no common prefix, return an empty string\'a0
\f6\fs26 \cf13 \cb14 ""
\f3\fs28 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 ["flower","flow","flight"]\

\f0\b Output:
\f1\b0  "fl"\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  longestCommonPrefix = strs => \{\cb1 \
\cb5   \cf6 if\cf4  (!strs.length) \cf6 return\cf4  \cf7 ''\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < strs[\cf8 0\cf4 ].length; i++) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  str \cf6 of\cf4  strs) \{\cb1 \
\cb5       \cf6 if\cf4  (str[i] !== strs[\cf8 0\cf4 ][i]) \{\cb1 \
\cb5         \cf6 return\cf4  str.slice(\cf8 0\cf4 , i);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 return\cf4  strs[\cf8 0\cf4 ];\cb1 \
\cb5 \}\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Duplicate Numbers from Sorted Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a sorted array\'a0
\f4\i nums
\f3\i0 , remove the duplicates\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/In-place_algorithm"}}{\fldrslt 
\f5\b \cf15 in-place}}\'a0such that each element appear only\'a0
\f4\i once
\f3\i0 \'a0and return the new length.\
Do not allocate extra space for another array, you must do this by\'a0
\f5\b modifying the input array\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/In-place_algorithm"}}{\fldrslt \cf15 in-place}}
\f3\b0 \'a0with O(1) extra memory.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 Given 
\f7\i nums
\f1\i0  = 
\f0\b [1,1,2]
\f1\b0 ,\
\
Your function should return length = 
\f0\b 2
\f1\b0 , with the first two elements of 
\f7\i nums
\f1\i0  being 
\f0\b 1
\f1\b0  and 
\f0\b 2
\f1\b0  respectively.\
\
It doesn't matter what you leave beyond the returned length.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  removeDuplicates = nums => \{\cb1 \
\cb5     \cf6 let\cf4  i = \cf8 0\cf4 ;\cb1 \
\cb5     nums.forEach(num => \{\cb1 \
\cb5         \cf6 if\cf4  (num !== nums[i]) \{\cb1 \
\cb5             nums[++i] = num;\cb1 \
\cb5         \}\cb1 \
\cb5     \});\cb1 \
\cb5     \cf6 return\cf4  i + \cf8 1\cf4 ;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Element from Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  removeElement = (nums, val) => \{\cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5     \cf6 if\cf4  (nums[i] === val) \{\cb1 \
\cb5       nums.splice(i, \cf8 1\cf4 );\cb1 \
\cb5       i--;\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  nums.length;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // strStr (Needle and Haystack)
\f3\b0 \cf12 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 Return the index of the first occurrence of needle in haystack, or\'a0
\f5\b -1
\f3\b0 \'a0if needle is not part of haystack.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  haystack = "hello", needle = "ll"\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  haystack = "aaaaa", needle = "bba"\

\f0\b Output:
\f1\b0  -1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  strStr = (haystack, needle) => \{\cb1 \
\
\cb5   \cf6 if\cf4 (needle === \cf7 ''\cf4  && haystack === \cf7 ''\cf4  )\{\cb1 \
\cb5     \cf6 return\cf4  \cf8 0\cf4 \cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < haystack.length; i++)\{\cb1 \
\cb5     \cf6 if\cf4  (haystack.substr(i, needle.length) === needle)\{\cb1 \
\cb5       \cf6 return\cf4  i\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  -\cf8 1\cf4 \cb1 \
\cb5 \}\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Search Insert Position
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\
You may assume no duplicates in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [1,3,5,6], 5\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  searchInsert = (nums, target) => \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++)\{\cb1 \
\cb5         \cf6 if\cf4  (nums[i] >= target)\{\cb1 \
\cb5             \cf6 return\cf4  i;\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  nums.length;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Length of Last Word
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a string\'a0
\f4\i s
\f3\i0 \'a0consists of upper/lower-case alphabets and empty space characters\'a0
\f6\fs26 \cf13 \cb14 ' '
\f3\fs28 \cf12 \cb3 , return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\
If the last word does not exist, return 0.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \'a0A word is defined as a\'a0
\f5\b maximal substring
\f3\b0 \'a0consisting\'a0of non-space characters only.\

\f5\b Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  "Hello World"\

\f0\b Output:
\f1\b0  5\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  lengthOfLastWord = str => \{\cb1 \
\cb5     \cf6 const\cf4  result = str.trim().split(\cf7 ' '\cf4 );\cb1 \
\cb5     \cf6 return\cf4  result[result.length - \cf8 1\cf4 ].length;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Plus One
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a\'a0
\f5\b non-empty
\f3\b0 \'a0array of digits\'a0representing a non-negative integer, plus one to the integer.\
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\
You may assume the integer does not contain any leading zero, except the number 0 itself.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [1,2,3]\

\f0\b Output:
\f1\b0  [1,2,4]\

\f0\b Explanation:
\f1\b0  The array represents the integer 123.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  plusOne = digits => \{\cb1 \
\cb5   \cf6 for\cf4 (\cf6 let\cf4  i = digits.length - \cf8 1\cf4 ; i >= \cf8 0\cf4 ; i--)\{\cb1 \
\cb5     \cf6 if\cf4 (digits[i] === \cf8 9\cf4 )\{\cb1 \
\cb5       digits[i] = \cf8 0\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 else\cf4  \{\cb1 \
\cb5       digits[i]++;\cb1 \
\cb5       \cf6 return\cf4  digits;\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  [\cf8 1\cf4 , ...digits];\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sorted Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two sorted integer arrays\'a0
\f4\i nums1
\f3\i0 \'a0and\'a0
\f4\i nums2
\f3\i0 , merge\'a0
\f4\i nums2
\f3\i0 \'a0into\'a0
\f4\i nums1
\f3\i0 \'a0as one sorted array.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
The number of elements initialized in\'a0
\f4\i nums1
\f3\i0 \'a0and\'a0
\f4\i nums2
\f3\i0 \'a0are\'a0
\f4\i m
\f3\i0 \'a0and\'a0
\f4\i n
\f3\i0 \'a0respectively.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
You may assume that\'a0
\f4\i nums1
\f3\i0 \'a0has enough space (size that is greater or equal to\'a0
\f4\i m
\f3\i0 \'a0+\'a0
\f4\i n
\f3\i0 ) to hold additional elements from\'a0
\f4\i nums2
\f3\i0 .\cb1 \
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 \cb3 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0 \
nums1 = [1,2,3,0,0,0], m = 3\
nums2 = [2,5,6],       n = 3\
\

\f0\b Output:
\f1\b0 \'a0[1,2,2,3,5,6]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  merge = (nums1, m, nums2, n) => \{\cb1 \
\cb5     \cb1 \
\cb5    \cf6 let\cf4  len = nums1.length - \cf8 1\cf4 \cb1 \
\cb5    m--;\cb1 \
\cb5    n--;\cb1 \
\cb5     \cb1 \
\cb5    \cf6 while\cf4  (n >= \cf8 0\cf4 ) \{\cb1 \
\cb5        \cf6 if\cf4  (nums1[m] > nums2[n]) \{\cb1 \
\cb5            nums1[len] = nums1[m], m--\cb1 \
\cb5        \} \cf6 else\cf4  \{\cb1 \
\cb5            nums1[len] = nums2[n], n--\cb1 \
\cb5        \}\cb1 \
\cb5        len--\cb1 \
\cb5    \cb1 \
\cb5    \}\cb1 \
\cb5    \cf6 return\cf4  nums1\cb1 \
\cb5     \cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find the Town Judge
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 In a town, there are\'a0
\f6\fs26 \cf13 \cb14 N
\f3\fs28 \cf12 \cb3 \'a0people labelled from\'a0
\f6\fs26 \cf13 \cb14 1
\f3\fs28 \cf12 \cb3 \'a0to\'a0
\f6\fs26 \cf13 \cb14 N
\f3\fs28 \cf12 \cb3 .\'a0 There is a rumor that one of these people is secretly the town judge.\
If the\'a0town judge exists, then:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
The town judge trusts nobody.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Everybody (except for the town judge) trusts the town judge.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
There is exactly one person that satisfies properties 1 and 2.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 You are given\'a0
\f6\fs26 \cf13 \cb14 trust
\f3\fs28 \cf12 \cb3 , an array of pairs\'a0
\f6\fs26 \cf13 \cb14 trust[i] = [a, b]
\f3\fs28 \cf12 \cb3 \'a0representing that the person labelled\'a0
\f6\fs26 \cf13 \cb14 a
\f3\fs28 \cf12 \cb3 \'a0trusts the person labelled\'a0
\f6\fs26 \cf13 \cb14 b
\f3\fs28 \cf12 \cb3 .\
If the town judge exists and can be identified, return the label of the town judge.\'a0 Otherwise, return\'a0
\f6\fs26 \cf13 \cb14 -1
\f3\fs28 \cf12 \cb3 .\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  N = 2, trust = [[1,2]]\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  findJudge = (\cf9 N\cf4 , trust) => \{\cb1 \
\cb5   \cf6 var\cf4  graph = \cf6 new\cf4  \cf9 Map\cf4  ()\cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i <= \cf9 N\cf4 ; i++) \{\cb1 \
\cb5     graph.\cf6 set\cf4 (i, \cf8 1\cf4 )\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  [v, e] \cf6 of\cf4  trust) \{\cb1 \
\cb5     graph.\cf6 set\cf4 (v, graph.\cf6 get\cf4 (v) - \cf8 1\cf4 ) \cf11 // the node which is not trusted -1\cf4 \cb1 \
\cb5     graph.\cf6 set\cf4 (e, graph.\cf6 get\cf4 (e) + \cf8 1\cf4 ) \cf11 // the node which is trusted + 1\cf4 \cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  [key, value] \cf6 of\cf4  graph) \{\cb1 \
\cb5     \cf6 if\cf4  (value === \cf9 N\cf4 ) \cf6 return\cf4  key\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  -\cf8 1\cf4 \cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Partition Equal Subset Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a\'a0
\f5\b non-empty
\f3\b0 \'a0array containing\'a0
\f5\b only positive integers
\f3\b0 , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Each of the array element will not exceed 100.\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
The array size will not exceed 200.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 Input: [1, 5, 11, 5]\
\
Output: true\
\
Explanation: The array can be partitioned as [1, 5, 5] and [11].\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  canPartition = nums => \{\cb1 \
\cb5     \cf6 if\cf4 (!nums) \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5     \cf6 let\cf4  total = nums.reduce((a,b) => a + b, \cf8 0\cf4 )\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4 (total % \cf8 2\cf4  != \cf8 0\cf4 ) \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  target = total / \cf8 2\cf4 \cb1 \
\cb5     \cf6 let\cf4  result = \cf6 new\cf4  \cf9 Array\cf4 (target + \cf8 1\cf4 ).fill(\cf6 false\cf4 )\cb1 \
\cb5     result[\cf8 0\cf4 ] = \cf6 true\cf4 \cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  el \cf6 of\cf4  nums) \{\cb1 \
\cb5         \cb1 \
\cb5         \cf6 for\cf4 (\cf6 let\cf4  i = target; i >= \cf8 0\cf4 ; i--) \{            \cb1 \
\cb5             \cf6 let\cf4  complement = i - el\cb1 \
\cb5             \cb1 \
\cb5             \cf6 if\cf4 (!result[i] && result[complement])\{\cb1 \
\cb5                 result[i] = \cf6 true\cf4 \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 if\cf4 (result[target] == \cf6 true\cf4 ) \cf6 return\cf4  \cf6 true\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5 \};\cb1 \
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Balanced Binary Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a binary tree, determine if it is height-balanced.\
For this problem, a height-balanced binary tree is defined as:\
\pard\pardeftab720\sa280\partightenfactor0
\cf16 a binary tree in which the left and right subtrees of\'a0
\f4\i every
\f3\i0 \'a0node differ in height by no more than 1.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
Given the following tree\'a0
\f6\fs26 \cf13 \cb14 [3,9,20,null,null,15,7]
\f3\fs28 \cf12 \cb3 :\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14     3\
   / \\\
  9  20\
    /  \\\
   15   7\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 Return true.\cb1 \uc0\u8232 \u8232 
\f5\b \cb3 Example 2:
\f3\b0 \
Given the following tree\'a0
\f6\fs26 \cf13 \cb14 [1,2,2,3,3,null,null,4,4]
\f3\fs28 \cf12 \cb3 :\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14        1\
      / \\\
     2   2\
    / \\\
   3   3\
  / \\\
 4   4\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 Return false.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{TreeNode\} root\
 * @return \{boolean\}\
 */\
\
\cf6 const\cf4  isBalanced = root => \{\cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  dfs = node => \{\cb1 \
\cb5         \cf6 if\cf4  (!node) \cf6 return\cf4  \cf8 0\cf4 ;\
\cb1 \
\cb5         \cf6 let\cf4  left = \cf8 1\cf4  + dfs(node.left);\cb1 \
\cb5         \cf6 let\cf4  right = \cf8 1\cf4  + dfs(node.right);\
\cb1 \
\cb5         \cf6 if\cf4  (\cf9 Math\cf4 .abs(left - right) > \cf8 1\cf4 ) \cf6 return\cf4  \cf9 Infinity\cf4 ;\
\cb1 \
\cb5         \cf6 return\cf4  \cf9 Math\cf4 .max(left, right);\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  dfs(root) == \cf9 Infinity \cf4 ? \cf6 false \cf4 : \cf6 true\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Same Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two binary trees, write a function to check if they are the same or not.\
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0      1         1\
          / \\       / \\\
         2   3     2   3\
\
        [1,2,3],   [1,2,3]\
\

\f0\b Output:
\f1\b0  true\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0      1         1\
          /           \\\
         2             2\
\
        [1,2],     [1,null,2]\
\

\f0\b Output:
\f1\b0  false\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{TreeNode\} p\
 * @param \{TreeNode\} q\
 * @return \{boolean\}\
 */\
\
\cf6 const\cf4  isSameTree = (p, q) => \{\cb1 \
\cb5     \cf6 if\cf4  (!p && !q) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 true\cf4 ; \cf11 // Both nodes are null, ok\cf4 \cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 if\cf4  (!p || !q || p.val !== q.val) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 false\cf4 ; \cf11 // Found a mismatch\cf4 \cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Symmetric Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\
For example, this binary tree\'a0
\f6\fs26 \cf13 \cb14 [1,2,2,3,4,4,3]
\f3\fs28 \cf12 \cb3 \'a0is symmetric:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14     1\
   / \\\
  2   2\
 / \\ / \\\
3  4 4  3\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 \'a0\
But the following\'a0
\f6\fs26 \cf13 \cb14 [1,2,2,null,3,null,3]
\f3\fs28 \cf12 \cb3 \'a0is not:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14     1\
   / \\\
  2   2\
   \\   \\\
   3    3\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Follow up:
\f3\b0 \'a0Solve it both recursively and iteratively.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\cf6 const\cf4  isSymmetric = root => \{\cb1 \
\cb5     \cf6 if\cf4  (!root) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf11 // Check if tree s & t are mirroring each other\cf4 \cb1 \
\cb5     \cf6 function\cf4  isMirror(p, q) \{\cb1 \
\cb5         \cf6 if\cf4  (!p && !q) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 true\cf4 ; \cf11 // Both nodes are null, ok\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 if\cf4  (!p || !q || p.val !== q.val) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 false\cf4 ; \cf11 // Found a mismatch\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf11 // Compare the left subtree of `s` with the right subtree of `t`\cf4 \cb1 \
\cb5         \cf11 // and the right subtree of `s` with the left subtree of `t`\cf4 \cb1 \
\cb5         \cf6 return\cf4  isMirror(p.left, q.right) && isMirror(p.right, q.left);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  isMirror(root.left, root.right);\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Convert Sorted Array to BST\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf12 Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of\'a0
\f4\i every
\f3\i0 \'a0node never differ by more than 1.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 Given the sorted array: [-10,-3,0,5,9],\
\
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\
\
      0\
     / \\\
   -3   9\
   /   /\
 -10  5\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{number[]\} nums\
 * @return \{TreeNode\}\
 */\
\
\cf6 const\cf4  sortedArrayToBST = nums => \{\cb1 \
\cb5     \cf6 if\cf4  (!nums.length) \cf6 return\cf4  \cf6 null\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  mid = \cf9 Math\cf4 .floor(nums.length / \cf8 2\cf4 );\cb1 \
\cb5     \cf6 const\cf4  root = \cf6 new\cf4  \cf9 TreeNode\cf4 (nums[mid]);\cb1 \
\cb5     \cb1 \
\cb5     \cf11 // subtrees are BSTs as well\cf4 \cb1 \
\cb5     root.left = sortedArrayToBST(nums.slice(\cf8 0\cf4 , mid));\cb1 \
\cb5     root.right = sortedArrayToBST(nums.slice(mid + \cf8 1\cf4 ));\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  root;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Path Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \'a0A leaf is a node with no children.\

\f5\b Example:
\f3\b0 \
Given the below binary tree and\'a0
\f6\fs26 \cf13 \cb14 sum = 22
\f3\fs28 \cf12 \cb3 ,\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14       
\f0\b 5
\f1\b0 \
     
\f0\b /
\f1\b0  \\\
    
\f0\b 4
\f1\b0    8\
   
\f0\b /
\f1\b0    / \\\
  
\f0\b 11
\f1\b0   13  4\
 /  
\f0\b \\
\f1\b0       \\\
7    
\f0\b 2
\f1\b0       1\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 return true, as there exist a root-to-leaf path\'a0
\f6\fs26 \cf13 \cb14 5->4->11->2
\f3\fs28 \cf12 \cb3 \'a0which sum is 22.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\cf6 const\cf4  hasPathSum = (root, sum) => \{\cb1 \
\cb5     \cf6 if\cf4  (!root) \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \cf6 if\cf4  (!root.left && !root.right) \cf6 return\cf4  sum - root.val == \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 return\cf4  hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);    \cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Kids With the Greatest Number of Candies
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  kidsWithCandies = (candies, extraCandies) => \{\cb1 \
\cb5 \'a0\'a0\cf6 const\cf4  max = \cf9 Math\cf4 .max(...candies)\cb1 \
\cb5 \'a0\'a0\cf6 const\cf4  result = candies.map(candy => candy + extraCandies >= max)\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  result\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse String
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  reverseString = str => \{\cb1 \
\cb5   \cf6 if\cf4  (str.length < \cf8 2\cf4 ) \cf6 return\cf4  str;\cb1 \
\cb5   \cf6 let\cf4  start = \cf8 0\cf4 ; \
  \cf6 let \cf4 end = str.length - \cf8 1\cf4 ;\cb1 \
\cb5   \cf6 while\cf4  (end > start) \{\cb1 \
\cb5     [str[start], str[end]] = [str[end], str[start]]; \cf11 // es6 swap trick\cf4 \cb1 \
\cb5     end--;\cb1 \
\cb5     start++;\cb1 \
\cb5   \}\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Max Depth of Binary Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  maxDepth = root => \{\cb1 \
\cb5     \cf6 if\cf4  (root === \cf6 null\cf4 ) \cf6 return\cf4  \cf8 0\cf4 \cb1 \
\cb5     \cf6 return\cf4  \cf9 Math\cf4 .max(maxDepth(root.left), maxDepth(root.right)) + \cf8 1\cf4 \cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Single Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a\'a0
\f5\b non-empty
\f3\b0 \'a0array of integers, every element appears\'a0
\f4\i twice
\f3\i0 \'a0except for one. Find that single one.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Note:
\f3\b0 \
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\

\f5\b Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [2,2,1]\

\f0\b Output:
\f1\b0  1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  singleNumber = nums => \{\cb1 \
\cb5   \cf6 const\cf4  map = \{\};\cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  num \cf6 of\cf4  nums) \{\cb1 \
\cb5     \cf6 if\cf4  (map[num] == \cf6 null\cf4 ) map[num] = \cf8 0\cf4 ;\cb1 \
\cb5     map[num]++;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  num \cf6 in\cf4  map) \{\cb1 \
\cb5     \cf6 if\cf4  (map[num] === \cf8 1\cf4 ) \cf6 return\cf4  \cf9 Number\cf4 (num);\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // FizzBuzz
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Write a program that outputs the string representation of numbers from 1 to\'a0
\f4\i n
\f3\i0 .\
But for multiples of three it should output \'93Fizz\'94 instead of the number and for the multiples of five output \'93Buzz\'94. For numbers which are multiples of both three and five output \'93FizzBuzz\'94.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 n = 15,\
\
Return:\
[\
    "1",\
    "2",\
    "Fizz",\
    "4",\
    "Buzz",\
    "Fizz",\
    "7",\
    "8",\
    "Fizz",\
    "Buzz",\
    "11",\
    "Fizz",\
    "13",\
    "14",\
    "FizzBuzz"\
]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  fizzBuzz = num => \{\cb1 \
\cb5     \cf6 const\cf4  result = \cf6 new\cf4  \cf9 Array\cf4 (num);\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i <= num ; i++)\{\cb1 \
\cb5         \cf6 if\cf4 (i % \cf8 15\cf4  === \cf8 0\cf4 ) result[i-\cf8 1\cf4 ] = \cf7 'FizzBuzz'\cf4 ;\cb1 \
\cb5         \cf6 else\cf4  \cf6 if\cf4 (i % \cf8 3\cf4  === \cf8 0\cf4 ) result[i-\cf8 1\cf4 ] = \cf7 'Fizz'\cf4 ;\cb1 \
\cb5         \cf6 else\cf4  \cf6 if\cf4 (i % \cf8 5\cf4  === \cf8 0\cf4 ) result[i-\cf8 1\cf4 ] = \cf7 'Buzz'\cf4 ;\cb1 \
\cb5         \cf6 else\cf4  result[i-\cf8 1\cf4 ] = i.toString();\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  reverseList = head => \{\cb1 \
\cb5     \cf6 let\cf4  prev = \cf6 null\cf4 ;\cb1 \
\cb5     \cf6 while\cf4 (head) \{\cb1 \
\cb5         \cf6 let\cf4  temp = head.next;\cb1 \
\cb5         head.next = prev;\cb1 \
\cb5         prev = head;\cb1 \
\cb5         head = temp;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  prev;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Delete Node in Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  deleteNode = node => \{\cb1 \
\cb5     node.val = node.next.val;\cb1 \
\cb5     node.next = node.next.next;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Two Sorted Lists
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  1->2->4, 1->3->4\

\f0\b Output:
\f1\b0  1->1->2->3->4->4\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 /**\
 * Definition for singly-linked list.\
 * function ListNode(val, next) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.next = (next===undefined ? null : next)\
 * \}\
 */\
/**\
 * @param \{ListNode\} l1\
 * @param \{ListNode\} l2\
 * @return \{ListNode\}\
 */\
\
\cf6 const\cf4  mergeTwoLists = (l1, l2) => \{\cb1 \
\cb5     \cf6 let\cf4  list = \cf6 new\cf4  \cf9 ListNode\cf4 ()\cb1 \
\cb5     \cf6 let\cf4  head = list\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4  (l1 !== \cf6 null\cf4  && l2 !== \cf6 null\cf4 ) \{\cb1 \
\cb5 \'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf11 // Select the smallest value from either linked list,\cf4 \cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf11 // then increment that list forward.\cf4 \cb1 \
\cb5         \cf6 if\cf4  (l1.val < l2.val) \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l1.val)\cb1 \
\cb5             l1 = l1.next\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l2.val)\cb1 \
\cb5             l2 = l2.next\cb1 \
\cb5         \}\cb1 \
\cb5         \cb1 \
\cb5         list = list.next\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf11 // It's possible that one linked list is shorter than the other so we just\cf4 \cb1 \
\cb5 \'a0\'a0\cf11 // add on the remainder of the last linked list. It's already sorted :)\cf4 \cb1 \
\cb5     \cf6 if\cf4  (l1 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l1\cb1 \
\cb5     \cf6 if\cf4  (l2 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l2\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf11 // return .next because this first element in the linkedlist is empty\cf4 \cb1 \
\cb5     \cf6 return\cf4  head.next\cb1 \
\cb5 \};\cb1 \
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Majority Element
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array of size\'a0
\f4\i n
\f3\i0 , find the majority element. The majority element is the element that appears\'a0
\f5\b more than
\f3\b0 \'a0
\f1\fs26 \cf13 \cb14 \uc0\u8970 
\f6  n/2 
\f1 \uc0\u8971 
\f3\fs28 \cf12 \cb3 \'a0times.\
You may assume that the array is non-empty and the majority element always exist in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [3,2,3]\

\f0\b Output:
\f1\b0  3\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  majorityElement = nums => \{\cb1 \
\cb5     \cf6 const\cf4  hash = \{\}\cb1 \
\cb5     \cf6 let\cf4  max = \cf8 0;\cf4 \
	\cf6 let\cf4  val;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++)\{\cb1 \
\cb5         hash[nums[i]] ? hash[nums[i]]++ : hash[nums[i]] = \cf8 1\cf4 \cb1 \
\cb5         \cf6 if\cf4  (hash[nums[i]] > max)\{\cb1 \
\cb5             max = hash[nums[i]]\cb1 \
\cb5             val = nums[i]\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  val\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Move Zeroes
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array\'a0
\f6\fs26 \cf13 \cb14 nums
\f3\fs28 \cf12 \cb3 , write a function to move all\'a0
\f6\fs26 \cf13 \cb14 0
\f3\fs28 \cf12 \cb3 's to the end of it while maintaining the relative order of the non-zero elements.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [0,1,0,3,12]\

\f0\b Output:
\f1\b0  [1,3,12,0,0]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  moveZeroes = nums => \{\cb1 \
\cb5   \cf6 var\cf4  idx = \cf8 0\cf4 ;\cb1 \
\cb5   \cf6 for\cf4  (\cf6 var\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5     \cf6 if\cf4  (nums[i] !== \cf8 0\cf4 ) \{\cb1 \
\cb5       nums[idx] = nums[i];\cb1 \
\cb5       nums[i] = idx === i ? nums[i] : \cf8 0\cf4 ;\cb1 \
\cb5       idx++;\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Anagram 2
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 var\cf4  isAnagram = \cf6 function\cf4 (s, t) \{\cb1 \
\cb5     \cf6 if\cf4  (s.length !== t.length) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  map = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cb1 \
\cb5     s.split(\cf7 ''\cf4 ).map((char, i) => \{\cb1 \
\cb5         \cf11 // record character occurrences in s\cf4 \cb1 \
\cb5         map.\cf6 set\cf4 (char, map.has(char) ? map.\cf6 get\cf4 (char) + \cf8 1\cf4  : \cf8 1\cf4 );\cb1 \
\cb5         \cf11 // at the same time subtract the character occurrences from t\cf4 \cb1 \
\cb5         map.\cf6 set\cf4 (t[i], map.has(t[i]) ? map.\cf6 get\cf4 (t[i]) - \cf8 1\cf4  : -\cf8 1\cf4 );\cb1 \
\cb5     \});\cb1 \
\cb5     \cb1 \
\cb5     \cf11 // for an anagram, final count should be 0\cf4 \cb1 \
\cb5     \cf6 return\cf4  \cf9 Array\cf4 .\cf6 from\cf4 (map.values()).reduce((acc, cur) => acc && cur === \cf8 0\cf4 , \cf6 true\cf4 );\cb1 \
\cb5 \};\cb1 \
\cb5 \
\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Contains Duplicate
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  containsDuplicate = nums => \{\cb1 \
\cb5     \cf6 return\cf4  nums.length !== \cf6 new\cf4  \cf9 Set\cf4 (nums).size\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Roman to Integer
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Roman numerals are represented by seven different symbols:\'a0
\f6\fs26 \cf13 \cb14 I
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 V
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 X
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 L
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 C
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 D
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f6\fs26 \cf13 \cb14 M
\f3\fs28 \cf12 \cb3 .\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Symbol
\f1\b0        
\f0\b Value
\f1\b0 \
I             1\
V             5\
X             10\
L             50\
C             100\
D             500\
M             1000\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf12 \cb3 For example,\'a0two is written as\'a0
\f6\fs26 \cf13 \cb14 II
\f3\fs28 \cf12 \cb3 \'a0in Roman numeral, just two one's added together. Twelve is written as,\'a0
\f6\fs26 \cf13 \cb14 XII
\f3\fs28 \cf12 \cb3 , which is simply\'a0
\f6\fs26 \cf13 \cb14 X
\f3\fs28 \cf12 \cb3 \'a0+\'a0
\f6\fs26 \cf13 \cb14 II
\f3\fs28 \cf12 \cb3 . The number twenty seven is written as\'a0
\f6\fs26 \cf13 \cb14 XXVII
\f3\fs28 \cf12 \cb3 , which is\'a0
\f6\fs26 \cf13 \cb14 XX
\f3\fs28 \cf12 \cb3 \'a0+\'a0
\f6\fs26 \cf13 \cb14 V
\f3\fs28 \cf12 \cb3 \'a0+\'a0
\f6\fs26 \cf13 \cb14 II
\f3\fs28 \cf12 \cb3 .\
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not\'a0
\f6\fs26 \cf13 \cb14 IIII
\f3\fs28 \cf12 \cb3 . Instead, the number four is written as\'a0
\f6\fs26 \cf13 \cb14 IV
\f3\fs28 \cf12 \cb3 . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as\'a0
\f6\fs26 \cf13 \cb14 IX
\f3\fs28 \cf12 \cb3 . There are six instances where subtraction is used:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls5\ilvl0
\f6\fs26 \cf13 \cb14 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
I
\f3\fs28 \cf12 \cb3 \'a0can be placed before\'a0
\f6\fs26 \cf13 \cb14 V
\f3\fs28 \cf12 \cb3 \'a0(5) and\'a0
\f6\fs26 \cf13 \cb14 X
\f3\fs28 \cf12 \cb3 \'a0(10) to make 4 and 9.\'a0\cb1 \
\ls5\ilvl0
\f6\fs26 \cf13 \cb14 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
X
\f3\fs28 \cf12 \cb3 \'a0can be placed before\'a0
\f6\fs26 \cf13 \cb14 L
\f3\fs28 \cf12 \cb3 \'a0(50) and\'a0
\f6\fs26 \cf13 \cb14 C
\f3\fs28 \cf12 \cb3 \'a0(100) to make 40 and 90.\'a0\cb1 \
\ls5\ilvl0
\f6\fs26 \cf13 \cb14 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
C
\f3\fs28 \cf12 \cb3 \'a0can be placed before\'a0
\f6\fs26 \cf13 \cb14 D
\f3\fs28 \cf12 \cb3 \'a0(500) and\'a0
\f6\fs26 \cf13 \cb14 M
\f3\fs28 \cf12 \cb3 \'a0(1000) to make 400 and 900.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0 \'a0"III"\

\f0\b Output:
\f1\b0  3\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  romanToInt = str => \{\cb1 \
\cb5   \cf6 if\cf4  (!str || str.length === \cf8 0\cf4 ) \{\cb1 \
\cb5     \cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 const\cf4  map = \cf6 new\cf4  \cf9 Map\cf4 ([[\cf7 'I'\cf4 , \cf8 1\cf4 ], [\cf7 'V'\cf4 , \cf8 5\cf4 ], [\cf7 'X'\cf4 , \cf8 10\cf4 ], [\cf7 'L'\cf4 , \cf8 50\cf4 ], [\cf7 'C'\cf4 , \cf8 100\cf4 ], [\cf7 'D'\cf4 , \cf8 500\cf4 ], [\cf7 'M'\cf4 , \cf8 1000\cf4 ]]);\cb1 \
\
\cb5   \cf6 let\cf4  last = str.length - \cf8 1\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  result = map.\cf6 get\cf4 (str[i]);\cb1 \
\
\cb5   \cf6 while\cf4  (last > \cf8 0\cf4 ) \{\cb1 \
\cb5     \cf6 const\cf4  curr = map.\cf6 get\cf4 (str[last]);\cb1 \
\cb5     \cf6 const\cf4  prev = map.\cf6 get\cf4 (str[last - \cf8 1\cf4 ]);\cb1 \
\
\cb5     \cf6 if\cf4  (prev >= curr) \{\cb1 \
\cb5       result += prev;\cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       result -= prev;\cb1 \
\cb5     \}\cb1 \
\
\cb5     last\'97;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Excel Sheet Column Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a column title as appear in an Excel sheet, return its corresponding column number.\
For example:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14     A -> 1\
    B -> 2\
    C -> 3\
    ...\
    Z -> 26\
    AA -> 27\
    AB -> 28 \
    ...\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  "A"\

\f0\b Output:
\f1\b0  1\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 "AB"\

\f0\b Output:
\f1\b0  28\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  titleToNumber = str => \{\cb1 \
\cb5   \cf6 const\cf4  letterToNumber = char => char.charCodeAt(\cf8 0\cf4 ) - \cf8 64\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 return\cf4  [...str]\cb1 \
\cb5     .reverse()\cb1 \
\cb5     .map((char, i) => letterToNumber(char) * \cf9 Math\cf4 .pow(\cf8 26\cf4 , i))\cb1 \
\cb5     .reduce((acc, cur) => acc + cur, \cf8 0\cf4 );\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // First Unique Character
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Examples:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 s = "leetcode"\
return 0.\
\
s = "loveleetcode",\
return 2.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  firstUniqChar = str => \{\cb1 \
\cb5    \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < str.length; i++)\{\cb1 \
\cb5        \cf6 if\cf4  (str.indexOf(str[i]) === str.lastIndexOf(str[i]))\{\cb1 \
\cb5           \cf6 return\cf4  i;\cb1 \
\cb5       \} \cb1 \
\cb5    \}\cb1 \
\cb5    \cf6 return\cf4  -\cf8 1\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Pascal\'92s Triangle
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a non-negative integer\'a0
\f4\i numRows
\f3\i0 , generate the first\'a0
\f4\i numRows
\f3\i0 \'a0of Pascal's triangle.\
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb1 \uc0\u8232 
\fs22\fsmilli11200 \cb3 In Pascal's triangle, each number is the sum of the two numbers directly above it.
\fs28 \
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  5\

\f0\b Output:
\f1\b0 \
[\
     [1],\
    [1,1],\
   [1,2,1],\
  [1,3,3,1],\
 [1,4,6,4,1]\
]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  generate = numRows => \{\cb1 \
\cb5     \cf6 if\cf4  (numRows === \cf8 0\cf4 ) \cf6 return\cf4  [];\cb1 \
\
\cb5     \cf6 const\cf4  result = [];\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < numRows; i++) \{\cb1 \
\cb5         \cf6 let\cf4  currRow = [];\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  j = \cf8 0\cf4 ; j <= i; j++) \{\cb1 \
\cb5             \cf6 if\cf4  (j === \cf8 0\cf4  || j === i)\{\cb1 \
\cb5                 currRow.push(\cf8 1\cf4 );\cb1 \
\cb5             \} \cf6 else\cf4  \{\cb1 \
\cb5                 currRow.push(result[i - \cf8 1\cf4 ][j - \cf8 1\cf4 ] + result[i - \cf8 1\cf4 ][j]);\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5         result.push(currRow);\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Missing Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array containing\'a0
\f4\i n
\f3\i0 \'a0distinct numbers taken from\'a0
\f6\fs26 \cf13 \cb14 0, 1, 2, ..., n
\f3\fs28 \cf12 \cb3 , find the one that is missing from the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [3,0,1]\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  [9,6,4,2,3,5,7,0,1]\

\f0\b Output:
\f1\b0  8\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  missingNumber = nums => \{\cb1 \
\cb5     \cf6 const\cf4  numsLength = nums.length;\cb1 \
\cb5     \cf6 const\cf4  expectedSum = (numsLength * (numsLength + \cf8 1\cf4 )) / \cf8 2\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  sum = nums.reduce((acc, cur) => acc += cur, \cf8 0\cf4 );\cb1 \
\cb5     \cf6 return\cf4  expectedSum - sum;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Intersection of Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two arrays, write a function to compute their intersection.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 nums1 = [1,2,2,1], nums2 = [2,2]\

\f0\b Output: 
\f1\b0 [2,2]\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 nums1 = [4,9,5], nums2 = [9,4,9,8,4]\

\f0\b Output: 
\f1\b0 [4,9]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  intersect = (nums1, nums2) => \{\cb1 \
\cb5     \cf6 const\cf4  hash = \{\}, result = []\cb1 \
\cb5     \cb1 \
\cb5     nums2.forEach(num => \{\cb1 \
\cb5         hash[num] ? hash[num]++ : hash[num] = \cf8 1\cf4 \cb1 \
\cb5     \})\cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums1.length; i++)\{\cb1 \
\cb5         \cf6 if\cf4  (hash[nums1[i]] > \cf8 0\cf4 )\{\cb1 \
\cb5             result.push(nums1[i])\cb1 \
\cb5             hash[nums1[i]]--\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Happy Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Write an algorithm to determine if a number\'a0
\f6\fs26 \cf13 \cb14 n
\f3\fs28 \cf12 \cb3 \'a0is "happy".\
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it\'a0
\f5\b loops endlessly in a cycle
\f3\b0 \'a0which does not include 1. Those numbers for which this process\'a0
\f5\b ends in 1
\f3\b0 \'a0are happy numbers.\
Return True if\'a0
\f6\fs26 \cf13 \cb14 n
\f3\fs28 \cf12 \cb3 \'a0is a happy number, and False if not.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:\'a0
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  19\

\f0\b Output:
\f1\b0  true\

\f0\b Explanation: \

\f1\b0 1
\fs19\fsmilli9750 2
\fs26  + 9
\fs19\fsmilli9750 2
\fs26  = 82\
8
\fs19\fsmilli9750 2
\fs26  + 2
\fs19\fsmilli9750 2
\fs26  = 68\
6
\fs19\fsmilli9750 2
\fs26  + 8
\fs19\fsmilli9750 2
\fs26  = 100\
1
\fs19\fsmilli9750 2
\fs26  + 0
\fs19\fsmilli9750 2
\fs26  + 0
\fs19\fsmilli9750 2
\fs26  = 1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  isHappy = num => \{\cb1 \
\cb5     \cf6 const\cf4  seen = \{\}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4  (num != \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 if\cf4  (num \cf6 in\cf4  seen) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 false\cf4  \cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             seen[num] = num\cb1 \
\cb5             num = num.toString().split(\cf7 ''\cf4 ).reduce((acc, cur) => acc + (cur * cur), \cf8 0\cf4 )\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 true\cf4  \cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of 1 Bits (Hamming Weight)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Write a function that takes an unsigned integer and return\'a0the number of '1'\'a0bits it has (also known as the\'a0{\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Hamming_weight"}}{\fldrslt \cf15 Hamming weight}}).\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  00000000000000000000000000001011\

\f0\b Output:
\f1\b0  3\

\f0\b Explanation: 
\f1\b0 The input binary string 
\f0\b 00000000000000000000000000001011
\f1\b0 \'a0has a total of three '1' bits.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  hammingWeight = num => \{\cb1 \
\cb5     \cf6 return\cf4  num.toString(\cf8 2\cf4 ).replace(\cf17 \cb5 /0/\cf6 \cb5 g\cf4 , \cf7 ''\cf4 ).length;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Power of 3
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isPowerOfThree = num => \{\cb1 \
\cb5     \cf6 if\cf4  (num <= \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 while\cf4  (num % \cf8 3\cf4  === \cf8 0\cf4 ) \{\cb1 \
\cb5         num /= \cf8 3\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  num === \cf8 1\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Linked List Cycle
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  hasCycle = head => \{\cb1 \
\cb5   \cf6 let\cf4  fast = head;\cb1 \
\cb5   \cf6 let\cf4  slow = head;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 while\cf4  (fast && fast.next) \{\cb1 \
\cb5     fast = fast.next.next;\cb1 \
\cb5     slow = slow.next;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4  (fast === slow) \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Palindrome Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isPalindrome = head => \{\cb1 \
\cb5     \cf6 let\cf4  fast = head;\
	\cf6 let \cf4 slow = head;\
	\cf6 let \cf4 last = \cf6 null\cf4 ;\
\cb1 \
\cb5     \cf6 while\cf4 (fast && fast.next) [fast, slow] = [fast.next.next, slow.next]; \cf11 // get middle node\cf4 \cb1 \
\cb5     \cf6 while\cf4 (slow) [slow.next, last, slow] = [last, slow, slow.next]; \cf11 //reverse right half link list\cf4 \cb1 \
\cb5     \cf6 while\cf4 (last && last.val === head.val) [last, head] = [last.next, head.next]; \cf11 // check \cf4 \cb1 \
\cb5     \cf6 return\cf4  !last;\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Intersection of Two Linked Lists
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  getIntersectionNode = (headA, headB) => \{\cb1 \
\cb5     \cf6 if\cf4  (!headA || !headB) \cf6 return\cf4  \cf6 null\cf4 ;\cb1 \
\cb5     \cf6 var\cf4  curA = headA;\cb1 \
\cb5     \cf6 var\cf4  curB = headB;\cb1 \
\cb5     \cf6 while\cf4  (curA != curB) \{\cb1 \
\cb5         curA = curA == \cf6 null\cf4  ? headB : curA.next;\cb1 \
\cb5         curB = curB == \cf6 null\cf4  ? headA : curB.next;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  curA;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Count Primes
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  countPrimes = num => \{\cb1 \
\cb5     \cf6 let\cf4  hash = \cf6 new\cf4  \cf9 Array\cf4 (num).fill(\cf6 true\cf4 );\cb1 \
\cb5     hash[\cf8 0\cf4 ] = \cf6 false\cf4 ;\cb1 \
\cb5     hash[\cf8 1\cf4 ] = \cf6 false\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 2\cf4 ; i*i < num; i++) \{\cb1 \
\cb5         \cf6 if\cf4  (hash[i]) \{\cb1 \
\cb5             \cf6 for\cf4 (\cf6 let\cf4  j=i*i; j < num; j+=i)\{\cb1 \
\cb5                 hash[j] = \cf6 false\cf4 ;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  hash.filter((val)=>val).length;\cb1 \
\cb5 \};\cb1 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Palindrome
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isPalindrome = str => \{\cb1 \
\cb5     \cf6 if\cf4  (str === \cf7 ""\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf11 // 1. Remove non-alphanumeric chars from the string\cf4 \cb1 \
\cb5     \cf6 const\cf4  alphanum = str.toLowerCase().replace(\cf17 \cb5 /[\\W]/\cf6 \cb5 g\cf4 , \cf7 ""\cf4 );\cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  front = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 let\cf4  back = alphanum.length - \cf8 1\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4  (front < back) \{\cb1 \
\cb5         \cf6 if\cf4  (alphanum[front] != alphanum[back]) \{\cb1 \
\cb5             \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5         \}\
\cb1 \
\cb5         front++;\cb1 \
\cb5         back--;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Palindrome II
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  validPalindrome = (str, corrections = \cf8 1\cf4 ) => \{\cb1 \
\cb5   \cf6 let\cf4  front = \cf8 0\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  back = str.length - \cf8 1\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 while\cf4  (front < back) \{\cb1 \
\cb5     \cf6 if\cf4  (str[front] === str[back]) \{\cb1 \
\cb5       front++;\cb1 \
\cb5       back--;\cb1 \
\cb5       \cf6 continue\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4  (corrections === \cf8 0\cf4 ) \{\cb1 \
\cb5       \cf6 return\cf4  \cf6 false\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  validPalindrome(str.slice(front, back), \cf8 0\cf4 ) \cb1 \
\cb5       || validPalindrome(str.slice(front + \cf8 1\cf4 , back + \cf8 1\cf4 ), \cf8 0\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 return\cf4  \cf6 true\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Bits
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  reverseBits = num => \{\cb1 \
\cb5   \cf6 let\cf4  ret = \cf8 0\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  i = \cf8 0\cf4 ;\cb1 \
\
\cb5   \cf6 while\cf4 (num)\{\cb1 \
\cb5       i++;\cb1 \
\cb5       ret = (ret<<\cf8 1\cf4 ) | (num&\cf8 1\cf4 );\cb1 \
\cb5       num=(num>>>\cf8 1\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 if\cf4 (i<\cf8 32\cf4 )\{\cb1 \
\cb5       ret = ret << (\cf8 32\cf4 -i);\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  ret >>> \cf8 0\cf4 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Factorial Trailing Zeroes
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an integer\'a0
\f4\i n
\f3\i0 , return the number of trailing zeroes in\'a0
\f4\i n
\f3\i0 !.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  3\

\f0\b Output:
\f1\b0  0\

\f0\b Explanation:
\f1\b0 \'a03! = 6, no trailing zero.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  5\

\f0\b Output:
\f1\b0  1\

\f0\b Explanation:
\f1\b0 \'a05! = 120, one trailing zero.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  trailingZeroes = num => \{\cb1 \
\cb5     \cf6 if\cf4  (num < \cf8 5\cf4 ) \cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 return\cf4  \cf9 Math\cf4 .floor(num / \cf8 5\cf4 ) + trailingZeroes(num / \cf8 5\cf4 );\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array, rotate the array to the right by\'a0
\f4\i k
\f3\i0 \'a0steps, where\'a0
\f4\i k
\f3\i0 \'a0is non-negative.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  nums = [1,2,3,4,5,6,7], k = 3\

\f0\b Output:
\f1\b0  [5,6,7,1,2,3,4]\

\f0\b Explanation:
\f1\b0 \
rotate 1 steps to the right: [7,1,2,3,4,5,6]\
rotate 2 steps to the right: [6,7,1,2,3,4,5]\
rotate 3 steps to the right: [5,6,7,1,2,3,4]\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  nums = [-1,-100,3,99], k = 2\

\f0\b Output:
\f1\b0  [3,99,-1,-100]\

\f0\b Explanation:
\f1\b0  \
rotate 1 steps to the right: [99,-1,-100,3]\
rotate 2 steps to the right: [3,99,-1,-100]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  rotate = (nums, k) => \{\cb1 \
\cb5     \cf6 let\cf4  result = [...nums];\cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf6 let\cf4  idx = (i + k) % nums.length;\cb1 \
\cb5         nums[idx] = result[i];\cb1 \
\cb5     \};\cb1 \
\
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Binary Tree InOrder Traversal
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  inOrderTraversal = (root, result = []) => \{\cb1 \
\cb5   \cf6 if\cf4  (root) \{    \cb1 \
\cb5     inOrderTraversal(root.left, result);\cb1 \
\cb5     result.push(root.val);\cb1 \
\cb5     inOrderTraversal(root.right, result);\cb1 \
\cb5   \}\cb1 \
\cb5     \cb1 \
\cb5   \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Get Sum (Cannot use + or -)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  getSum = (num1, num2) => \{\cb1 \
\cb5     \cf6 let\cf4  carry;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4 (num2) \{\cb1 \
\cb5         carry = num1 & num2;\cb1 \
\cb5         num1 ^= num2;\cb1 \
\cb5         num2 = carry << \cf8 1\cf4 ;\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  num1;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Backspace String Compare\
\pard\pardeftab720\sl420\partightenfactor0
\cf18 (Other Idea - use a Stack and pop when you reach a #)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two\'a0strings\'a0
\f6\fs26 \cf13 \cb14 S
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f6\fs26 \cf13 \cb14 T
\f3\fs28 \cf12 \cb3 ,\'a0return if they are equal when both are typed into empty text editors.\'a0
\f6\fs26 \cf13 \cb14 #
\f3\fs28 \cf12 \cb3 \'a0means a backspace character.\
Note that after\'a0backspacing an empty text, the text will continue empty.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 S = "ab#c", T = "ad#c"\

\f0\b Output: 
\f1\b0 true\

\f0\b Explanation
\f1\b0 : Both S and T become "ac".\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  backspaceCompare = (\cf9 S\cf4 , \cf9 T\cf4 ) => \{\cb1 \
\cb5     \cf6 const\cf4  buildString = str => \cf9 Array\cf4 .\cf6 from\cf4 (str).reduce((acc, cur) => \{\cb1 \
\cb5         \cf6 if\cf4 (cur === \cf7 '#'\cf4 ) \{\cb1 \
\cb5             \cf6 return\cf4  acc.slice(\cf8 0\cf4 , acc.length - \cf8 1\cf4 );\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 return\cf4  [...acc, cur];\cb1 \
\cb5     \}, []).join(\cf7 ''\cf4 );\
\cb1 \
\cb5     \cf6 return\cf4  buildString(\cf9 S\cf4 ) === buildString(\cf9 T\cf4 )\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find Peak Element\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf12 A peak element is an element that is greater than its neighbors.\
Given an input array\'a0
\f6\fs26 \cf13 \cb14 nums
\f3\fs28 \cf12 \cb3 , where\'a0
\f6\fs26 \cf13 \cb14 nums[i] \uc0\u8800  nums[i+1]
\f3\fs28 \cf12 \cb3 , find a peak element and return its index.\
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\
You may imagine that\'a0
\f6\fs26 \cf13 \cb14 nums[-1] = nums[n] = -\uc0\u8734 
\f3\fs28 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  
\f0\b nums
\f1\b0  = [1,2,3,1]\

\f0\b Output:
\f1\b0  2\

\f0\b Explanation:
\f1\b0  3 is a peak element and your function should return the index number 2.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input:
\f1\b0  
\f0\b nums
\f1\b0  = [1,2,1,3,5,6,4]\

\f0\b Output:
\f1\b0  1 or 5 \

\f0\b Explanation:
\f1\b0  Your function can return either index number 1 where the peak element is 2, \
\'a0            or index number 5 where the peak element is 6.\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Follow up:
\f3\b0 \'a0Your solution should be in logarithmic complexity.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\cf6 const\cf4  findPeakElement = nums => \{\cb1 \
\cb5   \cf6 let\cf4  left = \cf8 0\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  right = nums.length - \cf8 1\cf4 ;\cb1 \
\
\cb5   \cf6 while\cf4 (left + \cf8 1 \cf4 < right) \{\cb1 \
\cb5     \cf6 let\cf4  middle = \cf9 Math\cf4 .floor(left + (right-left)/\cf8 2\cf4 );\cb1 \
\
\cb5     \cf6 if\cf4  (nums[middle] > nums[middle - \cf8 1\cf4 ] \cb1 \
\cb5       && nums[middle] > nums[middle + \cf8 1\cf4 ] ) \cb1 \
\cb5     \{\cb1 \
\cb5       \cf6 return\cf4  middle;\cb1 \
\cb5     \} \cf6 else\cf4  \cf6 if\cf4  (nums[middle] > nums[middle - \cf8 1\cf4 ]) \{\cb1 \
\cb5       left = middle;\cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       right = middle;\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  nums[left] > nums[right] ? left : right;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find the Difference\
\pard\pardeftab720\sl420\partightenfactor0
\cf18 (You can also use a Hash map and check for the odd character)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two strings\'a0
\f8\i\b s
\f3\i0\b0 \'a0and\'a0
\f8\i\b t
\f3\i0\b0 \'a0which consist of only lowercase letters.\
String\'a0
\f8\i\b t
\f3\i0\b0 \'a0is generated by random shuffling string\'a0
\f8\i\b s
\f3\i0\b0 \'a0and then add one more letter at a random position.\
Find the letter that was added in\'a0
\f8\i\b t
\f3\i0\b0 .\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf12 \cb14 Input:\
s = "abcd"\
t = "abcde"\
\
Output:\
e\
\
Explanation:\
'e' is the letter that was added.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  findTheDifference = (s, t) => \{\cb1 \
\cb5     \cf6 let\cf4  sortedS = s.split(\cf7 ''\cf4 ).sort();\cb1 \
\cb5     \cf6 let\cf4  sortedT = t.split(\cf7 ''\cf4 ).sort();\cb1 \
\cb5     \cf6 let\cf4  i;\cb1 \
\cb5     \cf6 for\cf4 (i = \cf8 0\cf4 ; i < sortedS.length; i++) \{\cb1 \
\cb5         \cf6 if\cf4 (sortedT[i] !== sortedS[i]) \{\cb1 \
\cb5             \cf6 return\cf4  sortedT[i];\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  sortedT[i];\cb1 \
\cb5 \};\cb1 \
 \
\
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Minimum Area Rectangle
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.\
If there isn't any rectangle, return 0.\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 [[1,1],[1,3],[3,1],[3,3],[2,2]]\

\f0\b Output: 
\f1\b0 4\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b\fs28 \cf12 \cb3 Example 2:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\

\f0\b Output: 
\f1\b0 2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  minAreaRect = points => \{\cb1 \
\cb5   \cf6 const\cf4  map = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5   \cf6 for\cf4  (\cf6 const\cf4  [x, y] \cf6 of\cf4  points) \{\cb1 \
\cb5     \cf6 if\cf4  (!map.has(x)) map.\cf6 set\cf4 (x, \cf6 new\cf4  \cf9 Set\cf4 ());\cb1 \
\cb5     map.\cf6 get\cf4 (x).add(y);\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 let\cf4  min = \cf9 Infinity\cf4 ;\cb1 \
\cb5   \cf6 for\cf4  (\cf6 const\cf4  [x1, y1] \cf6 of\cf4  points) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 const\cf4  [x2, y2] \cf6 of\cf4  points) \{\cb1 \
\cb5       \cf6 if\cf4  (x1 === x2 || y1 === y2) \cf6 continue\cf4 ;\cb1 \
\
\cb5       \cf11 // Find other two diagonal points\cf4 \cb1 \
\cb5       \cf6 if\cf4  (map.\cf6 get\cf4 (x1).has(y2) && map.\cf6 get\cf4 (x2).has(y1)) \{\cb1 \
\cb5         min = \cf9 Math\cf4 .min(min, \cf9 Math\cf4 .abs(x1 - x2) * \cf9 Math\cf4 .abs(y1 - y2));\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  min === \cf9 Infinity\cf4  ? \cf8 0\cf4  : min;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Letter Combinations of a Phone Number
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  letterCombinations = digits => \{\cb1 \
\cb5     \cf6 if\cf4  (digits === \cf7 ''\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  [];\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  phone = \{\cb1 \
\cb5         \cf7 '2'\cf4 : \cf7 'abc'\cf4 ,\cb1 \
\cb5         \cf7 '3'\cf4 : \cf7 'def'\cf4 ,\cb1 \
\cb5         \cf7 '4'\cf4 : \cf7 'ghi'\cf4 ,\cb1 \
\cb5         \cf7 '5'\cf4 : \cf7 'jkl'\cf4 ,\cb1 \
\cb5         \cf7 '6'\cf4 : \cf7 'mno'\cf4 ,\cb1 \
\cb5         \cf7 '7'\cf4 : \cf7 'pqrs'\cf4 ,\cb1 \
\cb5         \cf7 '8'\cf4 : \cf7 'tuv'\cf4 ,\cb1 \
\cb5         \cf7 '9'\cf4 : \cf7 'wxyz'\cf4 ,\cb1 \
\cb5     \};\cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  prev = [\cf7 ''\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  curr = [];\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < digits.length; i++) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  j = \cf8 0\cf4 ; j < prev.length; j++) \{\cb1 \
\cb5             \cf6 for\cf4  (\cf6 let\cf4  k = \cf8 0\cf4 ; k < phone[digits[i]].length; k++) \{\cb1 \
\cb5                 curr.push(prev[j] + phone[digits[i]][k]);\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5         prev = curr;\cb1 \
\cb5         curr = [];\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  prev;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Flipping an Image
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given a binary matrix\'a0
\f6\fs26 \cf13 \cb14 A
\f3\fs28 \cf12 \cb3 , we want to flip the image horizontally, then invert it, and return the resulting image.\
To flip an image horizontally means that each row of the image is reversed.\'a0 For example, flipping\'a0
\f6\fs26 \cf13 \cb14 [1, 1, 0]
\f3\fs28 \cf12 \cb3 \'a0horizontally results in\'a0
\f6\fs26 \cf13 \cb14 [0, 1, 1]
\f3\fs28 \cf12 \cb3 .\
To invert an image means\'a0that each\'a0
\f6\fs26 \cf13 \cb14 0
\f3\fs28 \cf12 \cb3 \'a0is replaced by\'a0
\f6\fs26 \cf13 \cb14 1
\f3\fs28 \cf12 \cb3 , and each\'a0
\f6\fs26 \cf13 \cb14 1
\f3\fs28 \cf12 \cb3 \'a0is replaced by\'a0
\f6\fs26 \cf13 \cb14 0
\f3\fs28 \cf12 \cb3 .\'a0For example, inverting\'a0
\f6\fs26 \cf13 \cb14 [0, 1, 1]
\f3\fs28 \cf12 \cb3 \'a0results in\'a0
\f6\fs26 \cf13 \cb14 [1, 0, 0]
\f3\fs28 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 [[1,1,0],[1,0,1],[0,0,0]]\

\f0\b Output: 
\f1\b0 [[1,0,0],[0,1,0],[1,1,1]]\

\f0\b Explanation:
\f1\b0  First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  flipAndInvertImage = grid => \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i=\cf8 0\cf4 ; i<grid.length; i++) \{\cb1 \
\cb5         \cf6 let\cf4  start = \cf8 0\cf4 ;\cb1 \
\cb5         \cf6 let\cf4  end = grid.length - \cf8 1\cf4 ;\cb1 \
\cb5         \cb1 \
\cb5         \cf6 while\cf4  (start < end) \{\cb1 \
\cb5             \cf6 let\cf4  temp = grid[i][start];\cb1 \
\cb5             grid[i][start++] = grid[i][end]\cb1 \
\cb5             grid[i][end--] = temp\cb1 \
\cb5         \}\cb1 \
\cb5         \cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  j=\cf8 0\cf4 ; j<grid[i].length; j++) \{\cb1 \
\cb5             grid[i][j] = grid[i][j] === \cf8 1\cf4  ? \cf8 0\cf4  : \cf8 1\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  grid\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Kth Largest Element in Array
\f1\b0 \cf4 \cb5 \
1. Create minHeap\
2. Loop through array\
3. minHeap.add(i)\
4. if (minHeap.size() > k) minHeap.remove()\
\

\f0\b \cf2 \cb3 // Fruit Into Baskets
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  totalFruit = tree => \{\cb1 \
\cb5     \cf6 let\cf4  result = \cf8 0\cf4 \cb1 \
\cb5     \cf6 if\cf4  (!tree || !tree.length) \cf6 return\cf4  result\cb1 \
\cb5     \cf6 let\cf4  map = \cf6 new\cf4  \cf9 Map\cf4 ()\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 , j = \cf8 0\cf4 ; j < tree.length; j++) \{\cb1 \
\cb5         map.\cf6 set\cf4 (tree[j], (map.\cf6 get\cf4 (tree[j]) || \cf8 0\cf4 ) + \cf8 1\cf4 )\cb1 \
\cb5         \cf6 while\cf4  (map.size > \cf8 2\cf4 ) \{\cb1 \
\cb5             map.\cf6 set\cf4 (tree[i], map.\cf6 get\cf4 (tree[i]) - \cf8 1\cf4 )\cb1 \
\cb5             \cf6 if\cf4  (map.\cf6 get\cf4 (tree[i]) === \cf8 0\cf4 ) map.\cf6 delete\cf4 (tree[i])\cb1 \
\cb5             i++\cb1 \
\cb5         \}\cb1 \
\cb5         result = \cf9 Math\cf4 .max(result, j - i + \cf8 1\cf4 )\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Unique Emails
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Every email consists of a local name and a domain name, separated by the @ sign.\
For example, in\'a0
\f6\fs26 \cf13 \cb14 alice@leetcode.com
\f3\fs28 \cf12 \cb3 ,\'a0
\f6\fs26 \cf13 \cb14 alice
\f3\fs28 \cf12 \cb3 \'a0is the local name, and\'a0
\f6\fs26 \cf13 \cb14 leetcode.com
\f3\fs28 \cf12 \cb3 \'a0is the domain name.\
Besides lowercase letters, these emails may contain\'a0
\f6\fs26 \cf13 \cb14 '.'
\f3\fs28 \cf12 \cb3 s or\'a0
\f6\fs26 \cf13 \cb14 '+'
\f3\fs28 \cf12 \cb3 s.\
If you add periods (
\f6\fs26 \cf13 \cb14 '.'
\f3\fs28 \cf12 \cb3 ) between some characters in the\'a0
\f5\b local name
\f3\b0 \'a0part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\'a0 For example,\'a0
\f6\fs26 \cf13 \cb14 "alice.z@leetcode.com"
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f6\fs26 \cf13 \cb14 "alicez@leetcode.com"
\f3\fs28 \cf12 \cb3 \'a0forward to the same email address.\'a0 (Note that this rule does not apply for domain names.)\
If you add a plus (
\f6\fs26 \cf13 \cb14 '+'
\f3\fs28 \cf12 \cb3 ) in the\'a0
\f5\b local name
\f3\b0 , everything after the first plus sign will be\'a0
\f5\b ignored
\f3\b0 . This allows certain emails to be filtered, for example\'a0
\f6\fs26 \cf13 \cb14 m.y+name@email.com
\f3\fs28 \cf12 \cb3 \'a0will be forwarded to\'a0
\f6\fs26 \cf13 \cb14 my@email.com
\f3\fs28 \cf12 \cb3 .\'a0 (Again, this rule does not apply for domain names.)\
It is possible to use both of these rules at the same time.\
Given a list of\'a0
\f6\fs26 \cf13 \cb14 emails
\f3\fs28 \cf12 \cb3 , we send one email to each address in the list.\'a0\'a0How many different addresses actually receive mails?\'a0\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f5\b \cf12 Example 1:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf12 \cb14 Input: 
\f1\b0 ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]\

\f0\b Output: 
\f1\b0 2\

\f0\b Explanation:
\f1\b0 \'a0"testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive \
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \
\cf6 const\cf4  numUniqueEmails = emails => \{\cb1 \
\cb5     \cf6 return\cf4  \cf6 new\cf4  \cf9 Set\cf4 (emails.map((item, index) => \{\cb1 \
\cb5         \cf6 let\cf4  [name, domain] = item.split(\cf7 "@"\cf4 )\cb1 \
\cb5         \cf6 let\cf4  [nameNoPlus, namePlus] = name.split(\cf7 "+"\cf4 );\cb1 \
\cb5         \cf6 let\cf4  nameSimplified = nameNoPlus.split(\cf7 "."\cf4 ).join(\cf7 ""\cf4 )  \cb1 \
\cb5         \cf6 let\cf4  emailSimplified = nameSimplified + \cf7 "@"\cf4  + domain;\cb1 \
\cb5         \cf6 return\cf4  emailSimplified;\cb1 \
\cb5     \})).size;\cb1 \
\cb5     \cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shuffle Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  shuffle = (nums, n) => \{\cb1 \
\cb5     \cf6 let\cf4  res = [nums[\cf8 0\cf4 ], nums[n]];\cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < n; i++) \{\cb1 \
\cb5         res.push(nums[i]);\cb1 \
\cb5         res.push(nums[i+n]);\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  res;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\cb1 \
\
\
\
}