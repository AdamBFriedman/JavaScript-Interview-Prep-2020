{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red14\green110\blue109;\red19\green120\blue72;\red255\green255\blue254;\red255\green255\blue254;
\red14\green110\blue109;\red19\green120\blue72;\red154\green154\blue154;\red154\green154\blue154;\red0\green0\blue255;
\red49\green49\blue50;\red191\green28\blue37;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c100000\c100000\c99608;\cssrgb\c100000\c100000\c99608;
\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c66667\c66667\c66667;\cssrgb\c66667\c66667\c66667;\cssrgb\c1680\c19835\c100000;
\cssrgb\c25098\c25098\c25490;\cssrgb\c80392\c19216\c19216;\cssrgb\c0\c0\c0\c83922;}
\margl1440\margr1440\vieww16020\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// STACK (LIFO)\

\f1\b0\fs28 \cf4 \
\cf5 class\cf4  \cf6 Stack\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .storage = \{\}\
    \cf5 this\cf4 .size = \cf7 0\cf4 \
  \}\
\
  push(element) \{\
    \cf5 this\cf4 .size++\
    \cf5 this\cf4 .storage[\cf5 this\cf4 .size] = element\
  \}\
\
  pop() \{\
	if (this.size === 0) return undefined\
    \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 this\cf4 .size--\
    \cf5 return\cf4  removed\
  \}\
\
  peek() \{\
    \cf5 return\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// QUEUE (FIFO)
\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb8 \expnd0\expndtw0\kerning0
class\cf4  \cf6 Queue\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .storage = \{\}\cb1 \
\cb8     \cf5 this\cf4 .head = \cf7 0\cf4 \cb1 \
\cb8     \cf5 this\cf4 .tail = \cf7 0\cf4 \cb1 \
\cb8   \}\cb1 \
\
\cb8   enqueue(element) \{\cb1 \
\cb8     \cf5 this\cf4 .storage[\cf5 this\cf4 .tail] = element\cb1 \
\cb8     \cf5 this\cf4 .tail++\cb1 \
\cb8   \}\cb1 \
\
\cb8   dequeue() \{\cb1 \
\cb8     \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 this\cf4 .head++\cb1 \
\cb8     \cf5 return\cf4  removed\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \cb3 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// Priority Queue (FIFO)
\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 class\cf4 \strokec4  \cf10 \strokec10 PriorityQueue\cf4 \strokec4  \{\cb1 \
\cb9   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .collection = [];\cb1 \
\cb9   \}\cb1 \
\
\cb9   print() \{\cb1 \
\cb9       console.log(\cf5 \strokec5 this\cf4 \strokec4 .collection);\cb1 \
\cb9     \};\cb1 \
\
\cb9   enqueue(element)\{\cb1 \
\cb9       \cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .isEmpty())\{ \cb1 \
\cb9           \cf5 \strokec5 this\cf4 \strokec4 .collection.push(element);\cb1 \
\cb9       \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cb9           \cf5 \strokec5 var\cf4 \strokec4  added = \cf5 \strokec5 false\cf4 \strokec4 ;\cb1 \
\cb9           \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 var\cf4 \strokec4  i=\cf11 \strokec11 0\cf4 \strokec4 ; i<\cf5 \strokec5 this\cf4 \strokec4 .collection.length; i++)\{\cb1 \
\cb9                 \cf5 \strokec5 if\cf4 \strokec4  (element[\cf11 \strokec11 1\cf4 \strokec4 ] < \cf5 \strokec5 this\cf4 \strokec4 .collection[i][\cf11 \strokec11 1\cf4 \strokec4 ])\{ \cf12 \strokec12 //checking priorities\cf4 \cb1 \strokec4 \
\cb9                   \cf5 \strokec5 this\cf4 \strokec4 .collection.splice(i,\cf11 \strokec11 0\cf4 \strokec4 ,element);\cb1 \
\cb9                   added = \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb9                   \cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cb9               \}\cb1 \
\cb9           \}\cb1 \
\cb9           \cf5 \strokec5 if\cf4 \strokec4  (!added)\{\cb1 \
\cb9               \cf5 \strokec5 this\cf4 \strokec4 .collection.push(element);\cb1 \
\cb9           \}\cb1 \
\cb9       \}\cb1 \
\cb9   \};\cb1 \
\
\cb9   dequeue() \{\cb1 \
\cb9       \cf5 \strokec5 var\cf4 \strokec4  value = \cf5 \strokec5 this\cf4 \strokec4 .collection.shift();\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4  value[\cf11 \strokec11 0\cf4 \strokec4 ];\cb1 \
\cb9   \};\cb1 \
\
\cb9   front() \{\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .collection[\cf11 \strokec11 0\cf4 \strokec4 ];\cb1 \
\cb9   \};\cb1 \
\
\cb9   size() \{\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .collection.length; \cb1 \
\cb9   \};\cb1 \
\
\cb9   isEmpty() \{\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .collection.length === \cf11 \strokec11 0\cf4 \strokec4 ); \cb1 \
\cb9   \};\cb1 \
\cb9 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb9 \strokec12 // let pq = new PriorityQueue(); \cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // pq.enqueue(['PS4', 3]); \cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // pq.enqueue(['XBox', 2]);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // pq.enqueue(['Nintendo', 1])\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // pq.enqueue(['PC', 3])\cf4 \cb1 \strokec4 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// SINGLY LINKED LIST
\f1\b0\fs28 \cf4 \cb1 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb9 \strokec5 class\cf4 \strokec4  \cf10 \strokec10 Node\cf4 \strokec4  \{\cb1 \
\cb9   \cf5 \strokec5 constructor\cf4 \strokec4 (data, next = \cf5 \strokec5 null\cf4 \strokec4 ) \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .data = data;\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .next = next;\cb1 \
\cb9   \}\cb1 \
\cb9 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb9 \strokec12 // Create/Get/Remove Nodes From Linked List\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb9 \strokec5 class\cf4 \strokec4  \cf10 \strokec10 LinkedList\cf4 \strokec4  \{\cb1 \
\cb9   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .head = \cf5 \strokec5 null\cf4 \strokec4 ;\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Insert first node\cf4 \cb1 \strokec4 \
\cb9   insertFirst(data) \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .head = \cf5 \strokec5 new\cf4 \strokec4  \cf10 \strokec10 Node\cf4 \strokec4 (data, \cf5 \strokec5 this\cf4 \strokec4 .head);\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size++;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Insert last node\cf4 \cb1 \strokec4 \
\cb9   insertLast(data) \{\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  node = \cf5 \strokec5 new\cf4 \strokec4  \cf10 \strokec10 Node\cf4 \strokec4 (data);\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  current;\cb1 \
\
\cb9     \cf12 \strokec12 // If empty, make head\cf4 \cb1 \strokec4 \
\cb9     \cf5 \strokec5 if\cf4 \strokec4  (!\cf5 \strokec5 this\cf4 \strokec4 .head) \{\cb1 \
\cb9       \cf5 \strokec5 this\cf4 \strokec4 .head = node;\cb1 \
\cb9     \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cb9       current = \cf5 \strokec5 this\cf4 \strokec4 .head;\cb1 \
\
\cb9       \cf5 \strokec5 while\cf4 \strokec4  (current.next) \{\cb1 \
\cb9         current = current.next;\cb1 \
\cb9       \}\cb1 \
\
\cb9       current.next = node;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size++;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Insert at index\cf4 \cb1 \strokec4 \
\cb9   insertAt(data, index) \{\cb1 \
\cb9     \cf12 \strokec12 //  If index is out of range\cf4 \cb1 \strokec4 \
\cb9     \cf5 \strokec5 if\cf4 \strokec4  (index > \cf11 \strokec11 0\cf4 \strokec4  && index > \cf5 \strokec5 this\cf4 \strokec4 .size) \{\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4 ;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf12 \strokec12 // If first index\cf4 \cb1 \strokec4 \
\cb9     \cf5 \strokec5 if\cf4 \strokec4  (index === \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb9       \cf5 \strokec5 this\cf4 \strokec4 .insertFirst(data);\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4 ;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf5 \strokec5 const\cf4 \strokec4  node = \cf5 \strokec5 new\cf4 \strokec4  \cf10 \strokec10 Node\cf4 \strokec4 (data);\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  current, previous;\cb1 \
\
\cb9     \cf12 \strokec12 // Set current to first\cf4 \cb1 \strokec4 \
\cb9     current = \cf5 \strokec5 this\cf4 \strokec4 .head;\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  count = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\
\cb9     \cf5 \strokec5 while\cf4 \strokec4  (count < index) \{\cb1 \
\cb9       previous = current; \cf12 \strokec12 // Node before index\cf4 \cb1 \strokec4 \
\cb9       count++;\cb1 \
\cb9       current = current.next; \cf12 \strokec12 // Node after index\cf4 \cb1 \strokec4 \
\cb9     \}\cb1 \
\
\cb9     node.next = current;\cb1 \
\cb9     previous.next = node;\cb1 \
\
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size++;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Get at index\cf4 \cb1 \strokec4 \
\cb9   getAt(index) \{\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  current = \cf5 \strokec5 this\cf4 \strokec4 .head;\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  count = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\
\cb9     \cf5 \strokec5 while\cf4 \strokec4  (current) \{\cb1 \
\cb9       \cf5 \strokec5 if\cf4 \strokec4  (count == index) \{\cb1 \
\cb9         console.log(current.data);\cb1 \
\cb9       \}\cb1 \
\cb9       count++;\cb1 \
\cb9       current = current.next;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 null\cf4 \strokec4 ;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Remove at index\cf4 \cb1 \strokec4 \
\cb9   removeAt(index) \{\cb1 \
\cb9     \cf5 \strokec5 if\cf4 \strokec4  (index > \cf11 \strokec11 0\cf4 \strokec4  && index > \cf5 \strokec5 this\cf4 \strokec4 .size) \{\cb1 \
\cb9       \cf5 \strokec5 return\cf4 \strokec4 ;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf5 \strokec5 let\cf4 \strokec4  current = \cf5 \strokec5 this\cf4 \strokec4 .head;\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  previous;\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  count = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\
\cb9     \cf12 \strokec12 // Remove first\cf4 \cb1 \strokec4 \
\cb9     \cf5 \strokec5 if\cf4 \strokec4  (index === \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb9       \cf5 \strokec5 this\cf4 \strokec4 .head = current.next;\cb1 \
\cb9     \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cb9       \cf5 \strokec5 while\cf4 \strokec4  (count < index) \{\cb1 \
\cb9         count++;\cb1 \
\cb9         previous = current;\cb1 \
\cb9         current = current.next;\cb1 \
\cb9       \}\cb1 \
\
\cb9       previous.next = current.next;\cb1 \
\cb9     \}\cb1 \
\
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size--;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Clear list\cf4 \cb1 \strokec4 \
\cb9   clearList() \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .head = \cf5 \strokec5 null\cf4 \strokec4 ;\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb9   \}\cb1 \
\
\cb9   \cf12 \strokec12 // Print list data\cf4 \cb1 \strokec4 \
\cb9   printListData() \{\cb1 \
\cb9     \cf5 \strokec5 let\cf4 \strokec4  current = \cf5 \strokec5 this\cf4 \strokec4 .head;\cb1 \
\
\cb9     \cf5 \strokec5 while\cf4 \strokec4  (current) \{\cb1 \
\cb9       console.log(current.data);\cb1 \
\cb9       current = current.next;\cb1 \
\cb9     \}\cb1 \
\cb9   \}\cb1 \
\cb9 \}\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// DOUBLY LINKED LIST
\f1\b0\fs28 \cf4 \
\
\cf5 class\cf4  \cf6 LinkedList\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
  \}\
\
  \cf13 // add to the end of the list / tail\cf4 \
  append(value) \{\
    \cf13 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf13 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldTail = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldTail.next = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail.prev = oldTail\
    \}\
  \}\
\
  \cf13 //add to beginning of list / head\cf4 \
  prepend(value) \{\
    \cf13 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf13 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldHead = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldHead.prev = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head.next = oldHead\
    \}\
  \}\
\
  deleteHead() \{\
    \cf13 // if list is empty (no head)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf13 // if linkedlist has >= 1 node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedHead = \cf5 this\cf4 .head\
      \cf13 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
      \}\
      \cf13 //if list has >1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .head.next\
        \cf5 this\cf4 .head.prev = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedHead.value\
    \}\
  \}\
\
  deleteTail() \{\
    \cf13 // if list is empty (no tail)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf13 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedTail = \cf5 this\cf4 .tail\
      \cf13 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .head = \cf5 null\cf4 \
      \}\
      \cf13 //if list has >1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .tail.prev\
        \cf5 this\cf4 .tail.next = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedTail.value\
    \}\
  \}\
\
  search(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .head\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  currentNode\
      \}\
      currentNode = currentNode.next\
    \}\
\
    \cf5 return\cf4  \cf5 null\cf4 \
  \}\
\
reverse() \{\
    \cf14 if\cf4  (!\cf14 this\cf4 .head) \{\
      \cf14 return\cf4  null;\
    \}\
\
    \cf14 let\cf4  currentNode = 
\f0\b this
\f1\b0 .head;\
    \cf14 this\cf4 .tail = currentNode;\
\
    \cf14 while\cf4  (currentNode) \{\
      \cf14 let
\f0\b  
\f1\b0 \cf4 prev = currentNode.prev;\
      currentNode.prev = currentNode.next;\
      currentNode.next = prev;\
\
      \cf14 if\cf4  (currentNode.prev) \{\
        currentNode = currentNode.prev;\
      \} \cf14 else\cf4  \{\
        \cf14 this.\cf4 head = currentNode;\
        \cf14 break\cf4 ;\
      \}\
    \}\
\}\
\
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4  (value, prev, next) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .next = next || \cf5 null\cf4 \
    \cf5 this\cf4 .prev = prev || \cf5 null\cf4 \
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// HASH TABLE (store keys and values)
\f1\b0\fs28 \cf4 \
\
\cf5 const\cf4  hash = (key, size) => \{\
  \cf5 let\cf4  hashedKey = \cf7 0\cf4 \
  \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < key.length; i++) \{\
    hashedKey += key.charCodeAt(i)\
  \}\
  \cf5 return\cf4  hashedKey % size\
\}\
\
\cf5 class\cf4  \cf6 HashTable\cf4  \{\
  \cf5 constructor\cf4 () \{\
    \cf5 this\cf4 .size = \cf7 20\cf4 \
    \cf5 this\cf4 .buckets = \cf6 Array\cf4 (\cf5 this\cf4 .size) \
\
    \cf13 // populate each bucket with a Map()\cf4 \
    \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; \cf5 this\cf4 .buckets.length; i++) \{\
      \cf5 this\cf4 .buckets[i] = \cf5 new\cf4  \cf6 Map\cf4 ()\
    \}\
  \}\
\
  insert(key, value) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size) \
    \cf5 this\cf4 .buckets[idx].\cf5 set\cf4 (key, value)\
  \}\
\
  remove(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 let\cf4  deleted = \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key)\
    \cf5 this\cf4 .buckets[idx].\cf5 delete\cf4 (key)\
    \cf5 return\cf4  deleted \
  \}\
\
  search(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 return\cf4  \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key) || null\
  \}\
\}
\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// BINARY SEARCH TREE (Access and process large amounts of ordered data)
\f1\b0\fs28 \cf4 \
\
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .left = \cf5 null\cf4 \
    \cf5 this\cf4 .right = \cf5 null\cf4 \
  \}\
\}\
\
\cf5 class\cf4  \cf6 BST\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .root = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \cf5 this\cf4 .count = \cf7 1\cf4 \
  \}\
\
  size() \{\
    \cf5 return\cf4  \cf5 this\cf4 .count\
  \}\
\
  insert(value) \{\
    \cf5 this\cf4 .count++\
\
    \cf5 let\cf4  newNode = \cf5 new\cf4  \cf6 Node\cf4 (value)\
\
    \cf5 const\cf4  searchTree = node => \{\
      \cf13 // if value < node.value, go left\cf4 \
      \cf5 if\cf4  (value < node.value) \{\
        \cf13 // if no left child, append new node\cf4 \
        \cf5 if\cf4  (!node.left) \{\
          node.left = newNode\
        \} \
        \cf13 // if left child, look left again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.left)\
        \}\
      \}\
      \cf13 // if value > node.value, go right\cf4 \
      \cf5 else\cf4  \{\
        \cf13 // if no right child, append new node\cf4 \
        \cf5 if\cf4  (!node.right) \{\
          node.right = newNode\
        \}\
        \cf13 // if right child, look right again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.right)\
        \}\
      \}\
    \}\
\
    searchTree(\cf5 this\cf4 .root)\
  \}\
\
  min() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf13 // continue traversing left until no more children\cf4 \
    \cf5 while\cf4  (currentNode.left) \{\
      currentNode = currentNode.left\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  max() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf13 // continue traversing right until no more children\cf4 \
    \cf5 while\cf4  (currentNode.right) \{\
      currentNode = currentNode.right\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  contains(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  \cf5 true\cf4 \
      \} \cf14 else\cf4  \cf5 if\cf4  (value < currentNode.value) \{\
        currentNode = currentNode.left\
      \} \cf5 else\cf4  \{\
        currentNode = currentNode.right\
      \}\
    \}\
\
    \cf5 return\cf4  \cf5 false\cf4 \
  \}\
\
  \cf13 // depth first search - branch by branch\cf4 \
\
  \cf13 // in-order\cf4 \
  \cf13 // left, root, right\cf4 \
  \cf13 // 2, 3, 12, 15, 28, 36, 39\cf4 \
  dfsInOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf13 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)\
      \cf13 // capture root node value\cf4 \
      result.push(node.value)\
      \cf13 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result\
  \}\
\
  \cf13 // pre-order\cf4 \
  \cf13 // root, left, right\cf4 \
  \cf13 // 15, 3, 2, 12, 36, 28, 39\cf4 \
  dfsPreOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf13 // capture root node value\cf4 \
      result.push(node.value)\
      \cf13 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf13 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result    \
  \}\
\
  \cf13 // post-order\cf4 \
  \cf13 // left, right, root\cf4 \
  \cf13 // 2, 12, 3, 28, 39, 36, 15\cf4 \
  dfsPostOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf13 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf13 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
      \cf13 // capture root node value\cf4 \
      result.push(node.value)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result   \
  \}\
\
  \cf13 // breadth first search - level by level\cf4 \
\
  \cf13 // use a queue!\cf4 \
  \cf13 // 15, 3, 36, 2, 12, 28, 39\cf4 \
  \cb8 bfs() \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8     \cf5 \cb8 let\cf4  result = []\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8     \cf5 let\cf4  queue = []\cb1 \
\
\cb8     queue.push(\cf5 this\cf4 .root)\cb1 \
\
\cb8     \cf5 while\cf4 (queue.length) \{\cb1 \
\cb8       \cf5 let\cf4  currentNode = queue.shift()\cb1 \
\
\cb8       result.push(currentNode.value)\cb1 \
\
\cb8       \cf5 if\cf4  (currentNode.left) queue.push(currentNode.left)\cb1 \
\cb8       \cf5 if\cf4  (currentNode.right) queue.push(currentNode.right)\cb1 \
\cb8     \}\cb1 \
\cb8     \cf5 return\cf4  result\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // MIN HEAP (Used primarily for its sort method O(n log n))
\f2\b0\fs30 \cf15 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb9 \outl0\strokewidth0 \strokec5 class\cf4 \strokec4  \cf10 \strokec10 MinHeap\cf4 \strokec4  \{\cb1 \
\cb9   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .heap = [\cf5 \strokec5 null\cf4 \strokec4 ];\cb1 \
\cb9   \}\cb1 \
\
\cb9   insert(num) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.push(num);\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf11 \strokec11 2\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  idx = \cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[idx] < \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf10 \strokec10 Math\cf4 \strokec4 .floor(idx/\cf11 \strokec11 2\cf4 \strokec4 )]) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (idx >= \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9         \cf12 \strokec12 //swap\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf10 \strokec10 Math\cf4 \strokec4 .floor(idx/\cf11 \strokec11 2\cf4 \strokec4 )], \cf5 \strokec5 this\cf4 \strokec4 .heap[idx]] = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9           [\cf5 \strokec5 this\cf4 \strokec4 .heap[idx], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf10 \strokec10 Math\cf4 \strokec4 .floor(idx/\cf11 \strokec11 2\cf4 \strokec4 )]];\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf10 \strokec10 Math\cf4 \strokec4 .floor(idx/\cf11 \strokec11 2\cf4 \strokec4 ) > \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 idx = \cf10 \strokec10 Math\cf4 \strokec4 .floor(idx/\cf11 \strokec11 2\cf4 \strokec4 );\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \cb1 \strokec4 \
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \strokec4 remove() \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  smallest = \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 1\cf4 \strokec4 ];\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf11 \strokec11 2\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 1\cf4 \strokec4 ] = \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf11 \strokec11 1\cf4 \strokec4 ];\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.splice(\cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length == \cf11 \strokec11 3\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 1\cf4 \strokec4 ] > \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 2\cf4 \strokec4 ]) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9           \cf12 \strokec12 //swap\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 1\cf4 \strokec4 ], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 2\cf4 \strokec4 ]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 2\cf4 \strokec4 ], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf11 \strokec11 1\cf4 \strokec4 ]];\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  smallest;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  i = \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  left = \cf11 \strokec11 2\cf4 \strokec4  * i;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  right = \cf11 \strokec11 2\cf4 \strokec4  * i + \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[i] >= \cf5 \strokec5 this\cf4 \strokec4 .heap[left] || \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9             \cf5 \strokec5 this\cf4 \strokec4 .heap[i] >= \cf5 \strokec5 this\cf4 \strokec4 .heap[right]) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[left] < \cf5 \strokec5 this\cf4 \strokec4 .heap[right]) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[i], \cf5 \strokec5 this\cf4 \strokec4 .heap[left]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[left], \cf5 \strokec5 this\cf4 \strokec4 .heap[i]];\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 i = \cf11 \strokec11 2\cf4 \strokec4  * i\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[i], \cf5 \strokec5 this\cf4 \strokec4 .heap[right]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[right], \cf5 \strokec5 this\cf4 \strokec4 .heap[i]];\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 i = \cf11 \strokec11 2\cf4 \strokec4  * i + \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 left = \cf11 \strokec11 2\cf4 \strokec4  * i;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 right = \cf11 \strokec11 2\cf4 \strokec4  * i + \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[left] == \cf5 \strokec5 undefined\cf4 \strokec4  || \cf5 \strokec5 this\cf4 \strokec4 .heap[right] == \cf5 \strokec5 undefined\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length == \cf11 \strokec11 2\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.splice(\cf11 \strokec11 1\cf4 \strokec4 , \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 null\cf4 \strokec4 ;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  smallest;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9   \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \strokec4 sort() \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  result = \cf5 \strokec5 new\cf4 \strokec4  \cf10 \strokec10 Array\cf4 \strokec4 ();\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 result.push(\cf5 \strokec5 this\cf4 \strokec4 .remove());\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  result;\cb1 \
\cf16 \cb9 \strokec16 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb9 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb9 \strokec12 let heap = new MinHeap();\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(4);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(3);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(44);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(1);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(76);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.insert(7);\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // heap.sort()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl340\partightenfactor0

\f2\fs30 \cf15 \cb3 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // SET
\f2\b0\fs30 \cf15 \
\pard\pardeftab720\sl340\partightenfactor0
\cf15 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb8 class\cf4  \cf6 Set\cf4  \{\cb1 \
\cf5 \cb8 constructor\cf4 () \{\cb1 \
\cb8   \cf5 this\cf4 .collection = [];\cb1 \
\cb8 \}\cb1 \
\
\cb8   has(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 return\cf4  (\cf5 this\cf4 .collection.indexOf(element) !== -\cf7 1\cf4 );\cb1 \
\cb8 \};\cb1 \
\
\cb8   values() \{\cb1 \
\cb8 \'a0\'a0\cf5 return\cf4  \cf5 this\cf4 .collection;\cb1 \
\cb8 \};\cb1 \
\
\cb8   add(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 if\cf4  (!\cf5 this\cf4 .has(element)) \{\cb1 \
\cb8 \'a0\'a0  \cf5 this\cf4 .collection.push(element);\cb1 \
\cb8 \'a0\'a0  \cf5 return\cf4  \cf5 true\cf4 ;\cb1 \
\cb8 \'a0\'a0\}\cb1 \
\cb8 \'a0\'a0\cf5 return\cf4  \cf5 false\cf4 \cb1 \
\cb8 \};\cb1 \
\
\cb8   remove(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 if\cf4  (\cf5 this\cf4 .has(element)) \{\cb1 \
\cb8 \'a0\'a0  index = \cf5 this\cf4 .collection.indexOf(element);\cb1 \
\cb8 \'a0\'a0  \cf5 this\cf4 .collection.splice(index, \cf7 1\cf4 );\cb1 \
\cb8 \'a0\'a0  \cf5 return\cf4  \cf5 true\cf4 ;\cb1 \
\cb8 \'a0\'a0\}\cb1 \
\cb8 \'a0\'a0\cf5 return\cf4  \cf5 false\cf4 \cb1 \
\cb8 \};\cb1 \
\
\cb8   size () \{\cb1 \
\cb8     \cf5 return\cf4  \cf5 this\cf4 .collection.length;\cb1 \
\cb8 \}\cb1 \
\
\cb8 \}\cb1 \
\pard\pardeftab720\sl340\partightenfactor0

\f2\fs30 \cf15 \cb3 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Graph (used for BFS - social networks, GPS, flight paths)\
\pard\pardeftab720\sl500\sa200\partightenfactor0

\f2\b0\fs30 \cf15 Nearly all graph problems will somehow use a grid or network in the problem, but sometimes these will be well disguised. Secondly, if you are required to find a path of any sort, it is usually a graph problem as well. Some common keywords associated with graph problems are: vertices, nodes, edges, connections, connectivity, paths, cycles and direction. An example of a description of a simple problem that exhibits some of these characteristics is:\
"Bob has become lost in his neighborhood. He needs to get from his current position back to his home. Bob\'92s neighborhood is a 2 dimensional grid, that starts at (0, 0) and (width \'96 1, height \'96 1). There are empty spaces upon which bob can walk with no difficulty, and houses, which Bob cannot pass through. Bob may only move horizontally or vertically by one square at a time.\
Bob\'92s initial position will be represented by a \'91B\'92 and the house location will be represented by an \'91H\'92. Empty squares on the grid are represented by \'91.\'92 and houses are represented by \'91X\'92. Find the minimum number of steps it takes Bob to get back home, but if it is not possible for Bob to return home, return -1.\
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb9 \outl0\strokewidth0 \strokec5 class\cf4 \strokec4  \cf10 \strokec10 Graph\cf4 \strokec4  \{\cb1 \
\cb9   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .storage = \{\};\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb9   \}\cb1 \
\
\cb9   add(value) \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .storage[value] = \{\};\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size++;\cb1 \
\cb9   \}\cb1 \
\
\cb9   addConnection(fr, to) \{\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .storage[fr][to] = \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .storage[to][fr] = \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb9   \}\cb1 \
\
\cb9   removeConnection(fr, to) \{\cb1 \
\cb9     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[fr][to]\cb1 \
\cb9     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[to][fr]\cb1 \
\cb9   \}\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\cb8   hasConnection(fr, to) \{\cb1 \
\cb8     \cf5 return\cf4  \cf5 this\cf4 .storage[fr].hasOwnProperty(to);\cb1 \
\cb8   \}\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\cb9   contains(target) \{\cb1 \
\cb9     \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage.hasOwnProperty(target);\cb1 \
\cb9   \}\cb1 \
\
\cb9   remove(value) \{\cb1 \
\cb9     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[value];\cb1 \
\cb9     \cf5 \strokec5 this\cf4 \strokec4 .size--;\cb1 \
\cb9     \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 let\cf4 \strokec4  key \cf5 \strokec5 in\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage) \{\cb1 \
\cb9       \cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .storage[key][value]) \{\cb1 \
\cb9         \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[key][value];\cb1 \
\cb9       \}\cb1 \
\cb9     \}\cb1 \
\cb9   \}\cb1 \
\cb9 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb9 \outl0\strokewidth0 \strokec12 let graph = new Graph();\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Slytherin');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Gryffindor');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Hufflepuff');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Ravenclaw');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Harry Potter');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Ron Weasley');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Hermione Granger');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Draco Malfoy');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Bellatrix LeStrange');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Luna Lovegood');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Cho Chang');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.add('Adam Friedman');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Gryffindor', 'Harry Potter');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Gryffindor', 'Ron Weasley');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Gryffindor', 'Hermione Granger');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Ravenclaw', 'Adam Friedman');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Ravenclaw', 'Cho Chang');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Hufflepuff', 'Luna Lovegood');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Slytherin', 'Draco Malfoy');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Slytherin', 'Draco Malfoy');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.removeConnection('Ravenclaw', 'Adam Friedman');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.addConnection('Slytherin', 'Bellatrix LeStrange');\cf4 \cb1 \strokec4 \
\cf12 \cb9 \strokec12 // graph.contains('Luna Lovegood')\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl282\partightenfactor0

\f3\fs23\fsmilli11880 \cf17 \cb3 \
}