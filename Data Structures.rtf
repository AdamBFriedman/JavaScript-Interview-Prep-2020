{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red14\green110\blue109;\red19\green120\blue72;\red255\green255\blue254;\red154\green154\blue154;
\red0\green0\blue255;\red49\green49\blue50;\red191\green28\blue37;\red144\green1\blue18;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;
\cssrgb\c1680\c19835\c100000;\cssrgb\c25098\c25098\c25490;\cssrgb\c80392\c19216\c19216;\cssrgb\c63922\c8235\c8235;}
\margl1440\margr1440\vieww15720\viewh17160\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// STACK (LIFO.  Think of the \'93Undo\'94 button)\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0 \cf4 \
\cf5 class\cf4  \cf6 Stack\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .storage = \{\}\
    \cf5 this\cf4 .size = \cf7 0\cf4 \
  \}\
\
  push(element) \{\
    \cf5 this\cf4 .size++\
    \cf5 this\cf4 .storage[\cf5 this\cf4 .size] = element\
  \}\
\
  pop() \{\
	if (this.size === 0) return undefined\
    \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 this\cf4 .size--\
    \cf5 return\cf4  removed\
  \}\
\
  peek() \{\
    \cf5 return\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// QUEUE (FIFO)\
\pard\pardeftab720\sl420\partightenfactor0

\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf5 \cb8 \expnd0\expndtw0\kerning0
class\cf4  \cf6 Queue\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .storage = \{\}\cb1 \
\cb8     \cf5 this\cf4 .head = \cf7 0\cf4 \cb1 \
\cb8     \cf5 this\cf4 .tail = \cf7 0\cf4 \cb1 \
\cb8   \}\cb1 \
\
\cb8   enqueue(element) \{\cb1 \
\cb8     \cf5 this\cf4 .storage[\cf5 this\cf4 .tail] = element\cb1 \
\cb8     \cf5 this\cf4 .tail++\cb1 \
\cb8   \}\cb1 \
\
\cb8   dequeue() \{\cb1 \
\cb8     \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 this\cf4 .head++\cb1 \
\cb8     \cf5 return\cf4  removed\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2 \cf0 \cb3 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// Priority Queue (FIFO)
\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf5 \cb8 \expnd0\expndtw0\kerning0
class\cf4  \cf6 PriorityQueue\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .collection = [];\cb1 \
\cb8   \}\cb1 \
\
\cb8   print() \{\cb1 \
\cb8       console.log(\cf5 this\cf4 .collection);\cb1 \
\cb8     \};\cb1 \
\
\cb8   enqueue(element)\{\cb1 \
\cb8       \cf5 if\cf4  (\cf5 this\cf4 .isEmpty())\{ \cb1 \
\cb8           \cf5 this\cf4 .collection.push(element);\cb1 \
\cb8       \} \cf5 else\cf4  \{\cb1 \
\cb8           \cf5 var\cf4  added = \cf5 false\cf4 ;\cb1 \
\cb8           \cf5 for\cf4  (\cf5 var\cf4  i=\cf7 0\cf4 ; i<\cf5 this\cf4 .collection.length; i++)\{\cb1 \
\cb8                 \cf5 if\cf4  (element[\cf7 1\cf4 ] < \cf5 this\cf4 .collection[i][\cf7 1\cf4 ])\{ \cf9 //checking priorities\cf4 \cb1 \
\cb8                   \cf5 this\cf4 .collection.splice(i,\cf7 0\cf4 ,element);\cb1 \
\cb8                   added = \cf5 true\cf4 ;\cb1 \
\cb8                   \cf5 break\cf4 ;\cb1 \
\cb8               \}\cb1 \
\cb8           \}\cb1 \
\cb8           \cf5 if\cf4  (!added)\{\cb1 \
\cb8               \cf5 this\cf4 .collection.push(element);\cb1 \
\cb8           \}\cb1 \
\cb8       \}\cb1 \
\cb8   \};\cb1 \
\
\cb8   dequeue() \{\cb1 \
\cb8       \cf5 var\cf4  value = \cf5 this\cf4 .collection.shift();\cb1 \
\cb8       \cf5 return\cf4  value[\cf7 0\cf4 ];\cb1 \
\cb8   \};\cb1 \
\
\cb8   front() \{\cb1 \
\cb8       \cf5 return\cf4  \cf5 this\cf4 .collection[\cf7 0\cf4 ];\cb1 \
\cb8   \};\cb1 \
\
\cb8   size() \{\cb1 \
\cb8       \cf5 return\cf4  \cf5 this\cf4 .collection.length; \cb1 \
\cb8   \};\cb1 \
\
\cb8   isEmpty() \{\cb1 \
\cb8       \cf5 return\cf4  (\cf5 this\cf4 .collection.length === \cf7 0\cf4 ); \cb1 \
\cb8   \};\cb1 \
\cb8 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb8 // let pq = new PriorityQueue(); \cf4 \cb1 \
\cf9 \cb8 // pq.enqueue(['PS4', 3]); \cf4 \cb1 \
\cf9 \cb8 // pq.enqueue(['XBox', 2]);\cf4 \cb1 \
\cf9 \cb8 // pq.enqueue(['Nintendo', 1])\cf4 \cb1 \
\cf9 \cb8 // pq.enqueue(['PC', 3])\cf4 \cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2 \cf0 \cb3 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// SINGLY LINKED LIST\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0 \cf4 \cb1 \
\cf5 \cb8 class\cf4  \cf6 Node\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 (data, next = \cf5 null\cf4 ) \{\cb1 \
\cb8     \cf5 this\cf4 .data = data;\cb1 \
\cb8     \cf5 this\cf4 .next = next;\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb8 // Create/Get/Remove Nodes From Linked List\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 class\cf4  \cf6 LinkedList\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .head = \cf5 null\cf4 ;\cb1 \
\cb8     \cf5 this\cf4 .size = \cf7 0\cf4 ;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Insert first node\cf4 \cb1 \
\cb8   append (data) \{\cb1 \
\cb8     \cf5 this\cf4 .head = \cf5 new\cf4  \cf6 Node\cf4 (data, \cf5 this\cf4 .head);\cb1 \
\cb8     \cf5 this\cf4 .size++;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Insert last node\cf4 \cb1 \
\cb8   prepend (data) \{\cb1 \
\cb8     \cf5 let\cf4  node = \cf5 new\cf4  \cf6 Node\cf4 (data);\cb1 \
\cb8     \cf5 let\cf4  current;\cb1 \
\
\cb8     \cf9 // If empty, make head\cf4 \cb1 \
\cb8     \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\cb1 \
\cb8       \cf5 this\cf4 .head = node;\cb1 \
\cb8     \} \cf5 else\cf4  \{\cb1 \
\cb8       current = \cf5 this\cf4 .head;\cb1 \
\
\cb8       \cf5 while\cf4  (current.next) \{\cb1 \
\cb8         current = current.next;\cb1 \
\cb8       \}\cb1 \
\
\cb8       current.next = node;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 this\cf4 .size++;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Insert at index\cf4 \cb1 \
\cb8   insertAt (data, index) \{\cb1 \
\cb8     \cf9 //  If index is out of range\cf4 \cb1 \
\cb8     \cf5 if\cf4  (index > \cf7 0\cf4  && index > \cf5 this\cf4 .size) \{\cb1 \
\cb8       \cf5 return\cf4 ;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf9 // If first index\cf4 \cb1 \
\cb8     \cf5 if\cf4  (index === \cf7 0\cf4 ) \{\cb1 \
\cb8       \cf5 this\cf4 .insertFirst(data);\cb1 \
\cb8       \cf5 return\cf4 ;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 const\cf4  node = \cf5 new\cf4  \cf6 Node\cf4 (data);\cb1 \
\cb8     \cf5 let\cf4  current, previous;\cb1 \
\
\cb8     \cf9 // Set current to first\cf4 \cb1 \
\cb8     current = \cf5 this\cf4 .head;\cb1 \
\cb8     \cf5 let\cf4  count = \cf7 0\cf4 ;\cb1 \
\
\cb8     \cf5 while\cf4  (count < index) \{\cb1 \
\cb8       previous = current; \cf9 // Node before index\cf4 \cb1 \
\cb8       count++;\cb1 \
\cb8       current = current.next; \cf9 // Node after index\cf4 \cb1 \
\cb8     \}\cb1 \
\
\cb8     node.next = current;\cb1 \
\cb8     previous.next = node;\cb1 \
\
\cb8     \cf5 this\cf4 .size++;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Get at index\cf4 \cb1 \
\cb8   getAt (index) \{\cb1 \
\cb8     \cf5 let\cf4  current = \cf5 this\cf4 .head;\cb1 \
\cb8     \cf5 let\cf4  count = \cf7 0\cf4 ;\cb1 \
\
\cb8     \cf5 while\cf4  (current) \{\cb1 \
\cb8       \cf5 if\cf4  (count == index) \{\cb1 \
\cb8         console.log(current.data);\cb1 \
\cb8       \}\cb1 \
\cb8       count++;\cb1 \
\cb8       current = current.next;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 return\cf4  \cf5 null\cf4 ;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Remove at index\cf4 \cb1 \
\cb8   removeAt (index) \{\cb1 \
\cb8     \cf5 if\cf4  (index > \cf7 0\cf4  && index > \cf5 this\cf4 .size) \{\cb1 \
\cb8       \cf5 return\cf4 ;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 let\cf4  current = \cf5 this\cf4 .head;\cb1 \
\cb8     \cf5 let\cf4  previous;\cb1 \
\cb8     \cf5 let\cf4  count = \cf7 0\cf4 ;\cb1 \
\
\cb8     \cf9 // Remove first\cf4 \cb1 \
\cb8     \cf5 if\cf4  (index === \cf7 0\cf4 ) \{\cb1 \
\cb8       \cf5 this\cf4 .head = current.next;\cb1 \
\cb8     \} \cf5 else\cf4  \{\cb1 \
\cb8       \cf5 while\cf4  (count < index) \{\cb1 \
\cb8         count++;\cb1 \
\cb8         previous = current;\cb1 \
\cb8         current = current.next;\cb1 \
\cb8       \}\cb1 \
\
\cb8       previous.next = current.next;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 this\cf4 .size--;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Clear list\cf4 \cb1 \
\cb8   clear () \{\cb1 \
\cb8     \cf5 this\cf4 .head = \cf5 null\cf4 ;\cb1 \
\cb8     \cf5 this\cf4 .size = \cf7 0\cf4 ;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf9 // Print list data\cf4 \cb1 \
\cb8   print () \{\cb1 \
\cb8     \cf5 let\cf4  current = \cf5 this\cf4 .head;\cb1 \
\
\cb8     \cf5 while\cf4  (current) \{\cb1 \
\cb8       console.log(current.data);\cb1 \
\cb8       current = current.next;\cb1 \
\cb8     \}\cb1 \
\cb8   \}\cb1 \
\
\cb8   reverse() \{\cb1 \
\cb8   \cf5 let\cf4  node = \cf5 this\cf4 .head,\cb1 \
\cb8       previous,\cb1 \
\cb8       tmp;\cb1 \
\
\cb8   \cf5 while\cf4  (node) \{\cb1 \
\cb8     tmp = node.next;\cb1 \
\cb8     node.next = previous;\cb1 \
\cb8     previous = node;\cb1 \
\cb8     node = tmp;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf5 return\cf4  previous;\cb1 \
\cb8 \}\cb1 \
\cb8 \}\cb1 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2 \cf0 \cb3 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// DOUBLY LINKED LIST
\f1\b0 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 class\cf4  \cf6 LinkedList\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
  \}\
\
  \cf9 // add to the end of the list / tail\cf4 \
  append(value) \{\
    \cf9 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldTail = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldTail.next = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail.prev = oldTail\
    \}\
  \}\
\
  \cf9 //add to beginning of list / head\cf4 \
  prepend(value) \{\
    \cf9 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldHead = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldHead.prev = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head.next = oldHead\
    \}\
  \}\
\
  deleteHead() \{\
    \cf9 // if list is empty (no head)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf9 // if linkedlist has >= 1 node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedHead = \cf5 this\cf4 .head\
      \cf9 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
      \}\
      \cf9 //if list has >1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .head.next\
        \cf5 this\cf4 .head.prev = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedHead.value\
    \}\
  \}\
\
  deleteTail() \{\
    \cf9 // if list is empty (no tail)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedTail = \cf5 this\cf4 .tail\
      \cf9 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .head = \cf5 null\cf4 \
      \}\
      \cf9 //if list has > 1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .tail.prev\
        \cf5 this\cf4 .tail.next = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedTail.value\
    \}\
  \}\
\
  search(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .head\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  currentNode\
      \}\
      currentNode = currentNode.next\
    \}\
\
    \cf5 return\cf4  \cf5 null\cf4 \
  \}\
\
reverse() \{\
    \cf10 if\cf4  (!\cf10 this\cf4 .head) \{\
      \cf10 return\cf4  null;\
    \}\
\
    \cf10 let\cf4  currentNode = 
\f0\b this
\f1\b0 .head;\
    \cf10 this\cf4 .tail = currentNode;\
\
    \cf10 while\cf4  (currentNode) \{\
      \cf10 let
\f0\b  
\f1\b0 \cf4 prev = currentNode.prev;\
      currentNode.prev = currentNode.next;\
      currentNode.next = prev;\
\
      \cf10 if\cf4  (currentNode.prev) \{\
        currentNode = currentNode.prev;\
      \} \cf10 else\cf4  \{\
        \cf10 this.\cf4 head = currentNode;\
        \cf10 break\cf4 ;\
      \}\
    \}\
\}\
\
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4  (value, prev, next) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .next = next || \cf5 null\cf4 \
    \cf5 this\cf4 .prev = prev || \cf5 null\cf4 \
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// HASH TABLE (store keys and values) (Subarray problems)
\f1\b0 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 const\cf4  hash = (key, size) => \{\
  \cf5 let\cf4  hashedKey = \cf7 0\cf4 \
  \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < key.length; i++) \{\
    hashedKey += key.charCodeAt(i)\
  \}\
  \cf5 return\cf4  hashedKey % size\
\}\
\
\cf5 class\cf4  \cf6 HashTable\cf4  \{\
  \cf5 constructor\cf4 () \{\
    \cf5 this\cf4 .size = \cf7 20\cf4 \
    \cf5 this\cf4 .buckets = \cf6 Array\cf4 (\cf5 this\cf4 .size) \
\
    \cf9 // populate each bucket with a Map()\cf4 \
    \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < \cf5 this\cf4 .buckets.length; i++) \{\
      \cf5 this\cf4 .buckets[i] = \cf5 new\cf4  \cf6 Map\cf4 ()\
    \}\
  \}\
\
  insert(key, value) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size) \
    \cf5 this\cf4 .buckets[idx].\cf5 set\cf4 (key, value)\
  \}\
\
  remove(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 let\cf4  deleted = \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key)\
    \cf5 this\cf4 .buckets[idx].\cf5 delete\cf4 (key)\
    \cf5 return\cf4  deleted \
  \}\
\
  search(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 return\cf4  \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key) || null\
  \}\
\}
\f2 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// BINARY SEARCH TREE (Access and process large amounts of ordered data)
\f1\b0 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .left = \cf5 null\cf4 \
    \cf5 this\cf4 .right = \cf5 null\cf4 \
  \}\
\}\
\
\cf5 class\cf4  \cf6 BST\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .root = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \cf5 this\cf4 .count = \cf7 1\cf4 \
  \}\
\
  size() \{\
    \cf5 return\cf4  \cf5 this\cf4 .count\
  \}\
\
  insert(value) \{\
    \cf5 this\cf4 .count++\
\
    \cf5 let\cf4  newNode = \cf5 new\cf4  \cf6 Node\cf4 (value)\
\
    \cf5 const\cf4  searchTree = node => \{\
      \cf9 // if value < node.value, go left\cf4 \
      \cf5 if\cf4  (value < node.value) \{\
        \cf9 // if no left child, append new node\cf4 \
        \cf5 if\cf4  (!node.left) \{\
          node.left = newNode\
        \} \
        \cf9 // if left child, look left again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.left)\
        \}\
      \}\
      \cf9 // if value > node.value, go right\cf4 \
      \cf5 else\cf4  \{\
        \cf9 // if no right child, append new node\cf4 \
        \cf5 if\cf4  (!node.right) \{\
          node.right = newNode\
        \}\
        \cf9 // if right child, look right again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.right)\
        \}\
      \}\
    \}\
\
    searchTree(\cf5 this\cf4 .root)\
  \}\
\
  min() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf9 // continue traversing left until no more children\cf4 \
    \cf5 while\cf4  (currentNode.left) \{\
      currentNode = currentNode.left\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  max() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf9 // continue traversing right until no more children\cf4 \
    \cf5 while\cf4  (currentNode.right) \{\
      currentNode = currentNode.right\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  contains(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  \cf5 true\cf4 \
      \} \cf10 else\cf4  \cf5 if\cf4  (value < currentNode.value) \{\
        currentNode = currentNode.left\
      \} \cf5 else\cf4  \{\
        currentNode = currentNode.right\
      \}\
    \}\
\
    \cf5 return\cf4  \cf5 false\cf4 \
  \}\
\
  \cf9 // depth first search - branch by branch\cf4 \
\
  \cf9 // in-order\cf4 \
  \cf9 // left, root, right\cf4 \
  dfsInOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result\
  \}\
\
  \cf9 // pre-order\cf4 \
  \cf9 // root, left, right\cf4 \
  dfsPreOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result    \
  \}\
\
  \cf9 // post-order\cf4 \
  \cf9 // left, right, root\cf4 \
  dfsPostOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result   \
  \}\
\
  \cf9 // breadth first search - level by level\cf4 \
  \cf9 // use a queue!\cf4 \
  \cb8 bfs() \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8     \cf5 let\cf4  result = []\cb1 \
\cb8     \cf5 let\cf4  queue = []\cb1 \
\
\cb8     queue.push(\cf5 this\cf4 .root)\cb1 \
\
\cb8     \cf5 while\cf4 (queue.length) \{\cb1 \
\cb8       \cf5 let\cf4  currentNode = queue.shift()\cb1 \
\
\cb8       result.push(currentNode.value)\cb1 \
\
\cb8       \cf5 if\cf4  (currentNode.left) queue.push(currentNode.left)\cb1 \
\cb8       \cf5 if\cf4  (currentNode.right) queue.push(currentNode.right)\cb1 \
\cb8     \}\cb1 \
\cb8     \cf5 return\cf4  result\cb1 \
\cb8   \}\cb1 \
\cb8 \}\
//InOrder Successor\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 function\cf4  inOrderSuccessor(node) \{\cb1 \
\cb8   \cf5 if\cf4  (!node) \{\cb1 \
\cb8     \cf5 return\cf4  \cf5 null\cf4 ;\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf5 if\cf4  (node.right) \{\cb1 \
\cb8     \cf5 return\cf4  leftMostChild(node.right);\cb1 \
\cb8   \} \cf5 else\cf4  \{\cb1 \
\cb8     \cf5 var\cf4  currentNode = node;\cb1 \
\cb8     \cf9 // Assuming each node has a reference to its parent\cf4 \cb1 \
\cb8     \cf5 var\cf4  parentNode = currentNode.parent;\cb1 \
\
\cb8     \cf9 // Go up until we find deepest ancestor for which node would be in left sub tree\cf4 \cb1 \
\cb8     \cf5 while\cf4  (parentNode && parentNode.left !== currentNode) \{\cb1 \
\cb8       currentNode = parentNode;\cb1 \
\cb8       parentNode = parentNode.parent;\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 return\cf4  parentNode;\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\
\cf5 \cb8 function\cf4  leftMostChild(node) \{\cb1 \
\cb8   \cf5 if\cf4  (!node) \{\cb1 \
\cb8     \cf5 return\cf4  \cf5 null\cf4 ;\cb1 \
\cb8   \}\cb1 \
\cb8   \cf5 while\cf4  (node.left) \{\cb1 \
\cb8     node = node.left;\cb1 \
\cb8   \}\cb1 \
\cb8   \cf5 return\cf4  node;\cb1 \
\cb8 \}\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb8 let bst = new BST(3);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(4);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(6);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(14);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(16);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(44);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(63);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(24);\cf4 \cb1 \
\cf9 \cb8 // bst.insert(68);\cf4 \cb1 \
\cf9 \cb8 // bst.dfsInOrder()\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 // MIN HEAP (Used primarily for its sort method O(n log n))
\f2\b0 \cf11 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf5 \cb8 class\cf4 \cb8  \cf6 \cb8 MinHeap\cf4 \cb8  \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cf5 \cb8 constructor\cf4 \cb8 () \{\cb1 \
\cb8     \cf5 \cb8 this\cf4 \cb8 .heap = [\cf5 \cb8 null\cf4 \cb8 ];\cb1 \
\cb8   \}\cb1 \
\
\cb8   insert(num) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 this\cf4 \cb8 .heap.push(num);\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap.length > \cf7 \cb8 2\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  idx = \cf5 \cb8 this\cf4 \cb8 .heap.length - \cf7 \cb8 1\cf4 \cb8 ;\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 while\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap[idx] < \cf5 \cb8 this\cf4 \cb8 .heap[\cf6 \cb8 Math\cf4 \cb8 .floor(idx/\cf7 \cb8 2\cf4 \cb8 )]) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (idx >= \cf7 \cb8 1\cf4 \cb8 ) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8         \cf9 \cb8 //swap\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 [\cf5 \cb8 this\cf4 \cb8 .heap[\cf6 \cb8 Math\cf4 \cb8 .floor(idx/\cf7 \cb8 2\cf4 \cb8 )], \cf5 \cb8 this\cf4 \cb8 .heap[idx]] = \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8           [\cf5 \cb8 this\cf4 \cb8 .heap[idx], \cf5 \cb8 this\cf4 \cb8 .heap[\cf6 \cb8 Math\cf4 \cb8 .floor(idx/\cf7 \cb8 2\cf4 \cb8 )]];\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf6 \cb8 Math\cf4 \cb8 .floor(idx/\cf7 \cb8 2\cf4 \cb8 ) > \cf7 \cb8 1\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 idx = \cf6 \cb8 Math\cf4 \cb8 .floor(idx/\cf7 \cb8 2\cf4 \cb8 );\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 break\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\cf4 \cb1 \
\cf12 \cb8 \'a0\'a0\cf4 \cb8 remove() \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  smallest = \cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 1\cf4 \cb8 ];\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap.length > \cf7 \cb8 2\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 this\cf4 \cb8 .heap[\cf7 \cb8 1\cf4 \cb8 ] = \cf5 \cb8 this\cf4 \cb8 .heap[\cf5 \cb8 this\cf4 \cb8 .heap.length - \cf7 \cb8 1\cf4 \cb8 ];\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 this\cf4 \cb8 .heap.splice(\cf5 \cb8 this\cf4 \cb8 .heap.length - \cf7 \cb8 1\cf4 \cb8 );\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap.length == \cf7 \cb8 3\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 1\cf4 \cb8 ] > \cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 2\cf4 \cb8 ]) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8           \cf9 \cb8 //swap\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 [\cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 1\cf4 \cb8 ], \cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 2\cf4 \cb8 ]] = [\cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 2\cf4 \cb8 ], \cf5 \cb8 this\cf4 \cb8 .heap[\cf7 \cb8 1\cf4 \cb8 ]];\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 return\cf4 \cb8  smallest;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  i = \cf7 \cb8 1\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  left = \cf7 \cb8 2\cf4 \cb8  * i;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  right = \cf7 \cb8 2\cf4 \cb8  * i + \cf7 \cb8 1\cf4 \cb8 ;\cb1 \
\
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 while\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap[i] >= \cf5 \cb8 this\cf4 \cb8 .heap[left] || \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8             \cf5 \cb8 this\cf4 \cb8 .heap[i] >= \cf5 \cb8 this\cf4 \cb8 .heap[right]) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap[left] < \cf5 \cb8 this\cf4 \cb8 .heap[right]) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 [\cf5 \cb8 this\cf4 \cb8 .heap[i], \cf5 \cb8 this\cf4 \cb8 .heap[left]] = [\cf5 \cb8 this\cf4 \cb8 .heap[left], \cf5 \cb8 this\cf4 \cb8 .heap[i]];\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 i = \cf7 \cb8 2\cf4 \cb8  * i\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 [\cf5 \cb8 this\cf4 \cb8 .heap[i], \cf5 \cb8 this\cf4 \cb8 .heap[right]] = [\cf5 \cb8 this\cf4 \cb8 .heap[right], \cf5 \cb8 this\cf4 \cb8 .heap[i]];\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 i = \cf7 \cb8 2\cf4 \cb8  * i + \cf7 \cb8 1\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 left = \cf7 \cb8 2\cf4 \cb8  * i;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 right = \cf7 \cb8 2\cf4 \cb8  * i + \cf7 \cb8 1\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap[left] == \cf5 \cb8 undefined\cf4 \cb8  || \cf5 \cb8 this\cf4 \cb8 .heap[right] == \cf5 \cb8 undefined\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 break\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf4 \cb8 \} \cf5 \cb8 else\cf4 \cb8  \cf5 \cb8 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap.length == \cf7 \cb8 2\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 this\cf4 \cb8 .heap.splice(\cf7 \cb8 1\cf4 \cb8 , \cf7 \cb8 1\cf4 \cb8 );\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf4 \cb8 \} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 return\cf4 \cb8  \cf5 \cb8 null\cf4 \cb8 ;\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 return\cf4 \cb8  smallest;\cb1 \
\cf12 \cb8 \'a0\'a0\cf4 \cb8 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb8 \'a0\'a0\cf4 \cb8 sort() \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 let\cf4 \cb8  result = \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Array\cf4 \cb8 ();\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 while\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .heap.length > \cf7 \cb8 1\cf4 \cb8 ) \{\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \cb8 result.push(\cf5 \cb8 this\cf4 \cb8 .remove());\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf4 \cb8 \};\cb1 \
\cf12 \cb8 \'a0\'a0\'a0\'a0\cf5 return\cf4 \cb8  result;\cb1 \
\cf12 \cb8 \'a0\'a0\cf4 \cb8 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb8 let heap = new MinHeap();\cf4 \cb1 \
\cf9 \cb8 // heap.insert(4);\cf4 \cb1 \
\cf9 \cb8 // heap.insert(3);\cf4 \cb1 \
\cf9 \cb8 // heap.insert(44);\cf4 \cb1 \
\cf9 \cb8 // heap.insert(1);\cf4 \cb1 \
\cf9 \cb8 // heap.insert(76);\cf4 \cb1 \
\cf9 \cb8 // heap.insert(7);\cf4 \cb1 \
\cf9 \cb8 // heap.sort()\cf4 \cb1 \
\
\pard\pardeftab720\sl340\partightenfactor0

\f2 \cf11 \cb3 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 // SET
\f2\b0 \cf11 \
\pard\pardeftab720\sl340\partightenfactor0
\cf11 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf5 \cb8 class\cf4 \cb8  \cf6 \cb8 Set\cf4 \cb8  \{\cb1 \
\cf5 \cb8 constructor\cf4 \cb8 () \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cf5 \cb8 this\cf4 \cb8 .collection = [];\cb1 \
\cb8 \}\cb1 \
\
\cb8   has(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 return\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .collection.indexOf(element) !== -\cf7 \cb8 1\cf4 \cb8 );\cb1 \
\cb8 \};\cb1 \
\
\cb8   values() \{\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 this\cf4 \cb8 .collection;\cb1 \
\cb8 \};\cb1 \
\
\cb8   add(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 if\cf4 \cb8  (!\cf5 \cb8 this\cf4 \cb8 .has(element)) \{\cb1 \
\cb8 \'a0\'a0  \cf5 \cb8 this\cf4 \cb8 .collection.push(element);\cb1 \
\cb8 \'a0\'a0  \cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 true\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\}\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 false\cf4 \cb1 \
\cb8 \};\cb1 \
\
\cb8   remove(element) \{\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 if\cf4 \cb8  (\cf5 \cb8 this\cf4 \cb8 .has(element)) \{\cb1 \
\cb8 \'a0\'a0  index = \cf5 \cb8 this\cf4 \cb8 .collection.indexOf(element);\cb1 \
\cb8 \'a0\'a0  \cf5 \cb8 this\cf4 \cb8 .collection.splice(index, \cf7 \cb8 1\cf4 \cb8 );\cb1 \
\cb8 \'a0\'a0  \cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 true\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\}\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 false\cf4 \cb1 \
\cb8 \};\cb1 \
\
\cb8   size () \{\cb1 \
\cb8     \cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 this\cf4 \cb8 .collection.length;\cb1 \
\cb8 \}\cb1 \
\
\cb8 \}\cb1 \
\pard\pardeftab720\sl340\partightenfactor0

\f2 \cf11 \cb3 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // GRAPH (used for BFS - social networks, GPS: shortest path problems)\
\pard\pardeftab720\sl500\sa200\partightenfactor0

\f2\b0 \cf11 Nearly all graph problems will somehow use a grid or network in the problem, but sometimes these will be well disguised. Secondly, if you are required to find a path of any sort, it is usually a graph problem as well. Some common keywords associated with graph problems are: vertices, nodes, edges, connections, connectivity, paths, cycles and direction. An example of a description of a simple problem that exhibits some of these characteristics is:\
"Bob has become lost in his neighborhood. He needs to get from his current position back to his home. Bob\'92s neighborhood is a 2 dimensional grid, that starts at (0, 0) and (width \'96 1, height \'96 1). There are empty spaces upon which bob can walk with no difficulty, and houses, which Bob cannot pass through. Bob may only move horizontally or vertically by one square at a time.\
Bob\'92s initial position will be represented by a \'91B\'92 and the house location will be represented by an \'91H\'92. Empty squares on the grid are represented by \'91.\'92 and houses are represented by \'91X\'92. Find the minimum number of steps it takes Bob to get back home, but if it is not possible for Bob to return home, return -1.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb1 \
\cf5 \cb8 class\cf4  \cf6 Graph\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .adjList = \{\}\cb1 \
\cb8   \}\cb1 \
\
\
\cb8 addVertex (vertex) \{\cb1 \
\cb8   \cf5 this\cf4 .adjList[vertex] = []\cb1 \
\cb8 \}\cb1 \
\
\cb8 addEdge (vertex1, vertex2) \{\cb1 \
\cb8   \cf5 this\cf4 .adjList[vertex1].push(vertex2)\cb1 \
\cb8 \}\cb1 \
\
\cb8 dfs () \{\cb1 \
\cb8   \cf5 const\cf4  nodes = \cf6 Object\cf4 .keys(\cf5 this\cf4 .adjList)\cb1 \
\cb8   \cf5 const\cf4  visited = \{\}\cb1 \
\cb8   \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < nodes.length; i++) \{\cb1 \
\cb8     \cf5 this\cf4 ._dfsUtil(nodes[i], visited)\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\cb8   \cb1 \
\cb8 _dfsUtil (vertex, visited) \{\cb1 \
\cb8   \cf5 if\cf4  (!visited[vertex])\{  \cb1 \
\cb8     visited[vertex] = \cf5 true\cf4 \cb1 \
\cb8     \cf5 const\cf4  neighbors = \cf5 this\cf4 .adjList[vertex]\cb1 \
\cb8     \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < neighbors.length; i++) \{\cb1 \
\cb8         \cf5 this\cf4 ._dfsUtil(neighbors[i], visited)\cb1 \
\cb8     \}\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\
\cb8 detectCycle () \{\cb1 \
\cb8   \cf5 const\cf4  nodes = \cf6 Object\cf4 .keys(\cf5 this\cf4 .adjList);\cb1 \
\cb8   \cf5 const\cf4  visited = \{\};\cb1 \
\cb8   \cf5 const\cf4  recStack = \{\};\cb1 \
\cb8   \cb1 \
\cb8   \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < nodes.length; i++) \{\cb1 \
\cb8     \cf5 if\cf4  (\cf5 this\cf4 ._detectCycleUtil(nodes[i], visited , recStack)) \cb1 \
\cb8       \cf5 return\cf4  \cf13 "There is a cycle!"\cf4 \cb1 \
\cb8   \}\cb1 \
\cb8   \cf5 return\cf4  \cf13 "No cycle!"\cf4 \cb1 \
\cb8 \}\cb1 \
\
\cb8 _detectCycleUtil (vertex, visited, recStack) \{\cb1 \
\cb8   \cf5 if\cf4 (!visited[vertex])\{\cb1 \
\cb8     visited[vertex] = \cf5 true\cf4 ;\cb1 \
\cb8     recStack[vertex] = \cf5 true\cf4 ;\cb1 \
\cb8     \cf5 const\cf4  neighbors = \cf5 this\cf4 .adjList[vertex];\cb1 \
\cb8     \cf5 for\cf4 (\cf5 let\cf4  i = \cf7 0\cf4 ; i < neighbors.length; i++)\{\cb1 \
\cb8       \cf5 let\cf4  currentNode = neighbors[i];\cb1 \
\cb8       \cf5 if\cf4 (!visited[currentNode] && \cf5 this\cf4 ._detectCycleUtil(currentNode, visited, recStack))\{\cb1 \
\cb8         \cf5 return\cf4  \cf5 true\cf4 ;\cb1 \
\cb8       \} \cf5 else\cf4  \cf5 if\cf4  (recStack[currentNode])\{\cb1 \
\cb8         \cf5 return\cf4  \cf5 true\cf4 ;\cb1 \
\cb8       \}\cb1 \
\cb8     \}\cb1 \
\cb8   \}\cb1 \
\cb8   recStack[vertex] = \cf5 false\cf4 ;\cb1 \
\cb8   \cf5 return\cf4  \cf5 false\cf4 ;\cb1 \
\cb8 \}\cb1 \
\cb8 \}\cb1 \
\
\cf5 \cb8 const\cf4  graph = \cf5 new\cf4  \cf6 Graph\cf4 ()\cb1 \
\
\cb8 graph.addVertex(\cf13 'A'\cf4 )\cb1 \
\cb8 graph.addVertex(\cf13 'B'\cf4 )\cb1 \
\cb8 graph.addVertex(\cf13 'C'\cf4 )\cb1 \
\cb8 graph.addVertex(\cf13 'D'\cf4 )\cb1 \
\cb8 graph.addVertex(\cf13 'E'\cf4 )\cb1 \
\
\cb8 graph.addEdge(\cf13 'A'\cf4 , \cf13 'B'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'D'\cf4 , \cf13 'E'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'C'\cf4 , \cf13 'E'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'A'\cf4 , \cf13 'D'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'A'\cf4 , \cf13 'C'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'E'\cf4 , \cf13 'B'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'D'\cf4 , \cf13 'B'\cf4 )\cb1 \
\cb8 graph.addEdge(\cf13 'E'\cf4 , \cf13 'A'\cf4 )\cb1 \
\
\cb8 graph.dfs()\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // GRAPH BFS
\f1\b0 \cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 let\cf4 \cb8  bfs = (graph, root) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cf5 \cb8 let\cf4 \cb8  nodesLen = \{\};\cb1 \
\
\cb8   \cf5 \cb8 for\cf4 \cb8 (\cf5 \cb8 let\cf4 \cb8  i = \cf7 \cb8 0\cf4 \cb8 ; i < graph.length; i++)\{\cb1 \
\cb8     nodesLen[i] = \cf6 \cb8 Infinity\cf4 \cb8 ; \cb1 \
\cb8   \}\cb1 \
\cb8   nodesLen[root] = \cf7 \cb8 0\cf4 \cb8 ;\cb1 \
\
\cb8   \cf5 \cb8 let\cf4 \cb8  queue = [root]\cb1 \
\cb8   \cf5 \cb8 let\cf4 \cb8  current;\cb1 \
\
\cb8   \cf5 \cb8 while\cf4 \cb8 (queue.length)\{\cb1 \
\cb8     current = queue.shift()\cb1 \
\
\cb8     \cf5 \cb8 let\cf4 \cb8  curConnected = graph[current] \cb1 \
\cb8     \cf5 \cb8 let\cf4 \cb8  neighborIdx = []\cb1 \
\cb8     \cf5 \cb8 let\cf4 \cb8  idx = curConnected.indexOf(\cf7 \cb8 1\cf4 \cb8 ) \cb1 \
\
\cb8     \cf5 \cb8 while\cf4 \cb8 (idx != -\cf7 \cb8 1\cf4 \cb8 )\{\cb1 \
\cb8       neighborIdx.push(idx) \cb1 \
\cb8       idx = curConnected.indexOf(\cf7 \cb8 1\cf4 \cb8 , idx + \cf7 \cb8 1\cf4 \cb8 )\cb1 \
\cb8     \}\cb1 \
\
\cb8     \cf5 \cb8 for\cf4 \cb8  ( \cf5 \cb8 let\cf4 \cb8  j = \cf7 \cb8 0\cf4 \cb8 ; j < neighborIdx.length; j++)\{\
		let neighbor = neighborIdx[j]\cb1 \
\cb8       \cf5 \cb8 if\cf4 \cb8  (nodesLen[neighbor] == \cf6 \cb8 Infinity\cf4 \cb8 )\{\cb1 \
\cb8         nodesLen[neighbor] = nodesLen[current] + \cf7 \cb8 1\cf4 \cb1 \
\cb8         queue.push(neighbor)\cb1 \
\cb8       \}\cb1 \
\cb8     \}\cb1 \
\cb8   \}\cb1 \
\
\cb8   \cf5 \cb8 return\cf4 \cb8  nodesLen\cb1 \
\cb8 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 let\cf4 \cb8  exBFSGraph = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   [\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ],\cb1 \
\cb8   [\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ],\cb1 \
\cb8   [\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ],\cb1 \
\cb8   [\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ],\cb1 \
\cb8   [\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 1\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ,\cf7 \cb8 0\cf4 \cb8 ]\cb1 \
\cb8 ]\cb1 \
\
\cb8 bfs(exBFSGraph, \cf7 \cb8 1\cf4 \cb8 )\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // TRIE
\f1\b0 \cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 class\cf4 \cb8  \cf6 \cb8 Node\cf4 \cb8  \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cf5 \cb8 constructor\cf4 \cb8 (keys, end) \{\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 this\cf4 \cb8 .keys = \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Map\cf4 \cb8 ();\cb1 \
\cb8 \'a0\'a0\cf5 \cb8 this\cf4 \cb8 .end = \cf5 \cb8 false\cf4 \cb8 ;\cb1 \
\cb8 \}\cb1 \
\cb8 \'a0\'a0setEnd() \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 this\cf4 \cb8 .end = \cf5 \cb8 true\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\};\cb1 \
\cb8 \'a0\'a0isEnd() \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 this\cf4 \cb8 .end;\cb1 \
\cb8 \'a0\'a0\};\cb1 \
\cb8 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb8 class\cf4 \cb8  \cf6 \cb8 Trie\cf4 \cb8  \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb8   \cf5 \cb8 constructor\cf4 \cb8 (root) \{\cb1 \
\cb8     \cf5 \cb8 this\cf4 \cb8 .root = \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Node\cf4 \cb8 ();\cb1 \
\cb8   \}\cb1 \
\cb8 \'a0\'a0\cb1 \
\
\cb8 \'a0\'a0add(input, node = \cf5 \cb8 this\cf4 \cb8 .root) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 if\cf4 \cb8  (input.length == \cf7 \cb8 0\cf4 \cb8 ) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0node.setEnd();\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\'a0\'a0\} \cf5 \cb8 else\cf4 \cb8  \cf5 \cb8 if\cf4 \cb8  (!node.keys.has(input[\cf7 \cb8 0\cf4 \cb8 ])) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0node.keys.\cf5 \cb8 set\cf4 \cb8 (input[\cf7 \cb8 0\cf4 \cb8 ], \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Node\cf4 \cb8 ());\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 this\cf4 \cb8 .add(input.substr(\cf7 \cb8 1\cf4 \cb8 ), node.keys.\cf5 \cb8 get\cf4 \cb8 (input[\cf7 \cb8 0\cf4 \cb8 ]));\cb1 \
\cb8 \'a0\'a0\'a0\'a0\} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 this\cf4 \cb8 .add(input.substr(\cf7 \cb8 1\cf4 \cb8 ), node.keys.\cf5 \cb8 get\cf4 \cb8 (input[\cf7 \cb8 0\cf4 \cb8 ]));\cb1 \
\cb8 \'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\};\cb1 \
\
\cb8 \'a0\'a0isWord(word) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 let\cf4 \cb8  node = \cf5 \cb8 this\cf4 \cb8 .root;\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 while\cf4 \cb8  (word.length > \cf7 \cb8 1\cf4 \cb8 ) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 if\cf4 \cb8  (!node.keys.has(word[\cf7 \cb8 0\cf4 \cb8 ])) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  \cf5 \cb8 false\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0node = node.keys.\cf5 \cb8 get\cf4 \cb8 (word[\cf7 \cb8 0\cf4 \cb8 ]);\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0word = word.substr(\cf7 \cb8 1\cf4 \cb8 );\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  (node.keys.has(word) && node.keys.\cf5 \cb8 get\cf4 \cb8 (word).isEnd()) ? \cb1 \
\cb8       \cf5 \cb8 true\cf4 \cb8  : \cf5 \cb8 false\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\};\cb1 \
\
\cb8 \'a0\'a0print() \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 let\cf4 \cb8  words = \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Array\cf4 \cb8 ();\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 let\cf4 \cb8  search = (node, string) => \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 if\cf4 \cb8  (node.keys.size != \cf7 \cb8 0\cf4 \cb8 ) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 for\cf4 \cb8  (\cf5 \cb8 let\cf4 \cb8  letter \cf5 \cb8 of\cf4 \cb8  node.keys.keys()) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0search(node.keys.\cf5 \cb8 get\cf4 \cb8 (letter), string.concat(letter));\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 if\cf4 \cb8  (node.isEnd()) \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0words.push(string);\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\} \cf5 \cb8 else\cf4 \cb8  \{\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0string.length > \cf7 \cb8 0\cf4 \cb8  ? words.push(string) : \cf5 \cb8 undefined\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0\};\cb1 \
\cb8 \'a0\'a0\'a0\'a0search(\cf5 \cb8 this\cf4 \cb8 .root, \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 String\cf4 \cb8 ());\cb1 \
\cb8 \'a0\'a0\'a0\'a0\cf5 \cb8 return\cf4 \cb8  words.length > \cf7 \cb8 0\cf4 \cb8  ? words : \cf13 \cb8 ''\cf4 \cb8 ;\cb1 \
\cb8 \'a0\'a0\};\cb1 \
\
\cb8 \};\cb1 \
\
\cb8 myTrie = \cf5 \cb8 new\cf4 \cb8  \cf6 \cb8 Trie\cf4 \cb8 ()\cb1 \
\cb8 myTrie.add(\cf13 \cb8 'ball'\cf4 \cb8 ); \cb1 \
\cb8 myTrie.add(\cf13 \cb8 'bat'\cf4 \cb8 ); \cb1 \
\cb8 myTrie.add(\cf13 \cb8 'doll'\cf4 \cb8 ); \cb1 \
\cb8 myTrie.add(\cf13 \cb8 'dork'\cf4 \cb8 ); \cb1 \
\cb8 myTrie.add(\cf13 \cb8 'do'\cf4 \cb8 ); \cb1 \
\cb8 myTrie.add(\cf13 \cb8 'dorm'\cf4 \cb8 )\cb1 \
\cb8 myTrie.add(\cf13 \cb8 'send'\cf4 \cb8 )\cb1 \
\cb8 myTrie.add(\cf13 \cb8 'sense'\cf4 \cb8 )\cb1 \
\cb8 console.log(myTrie.isWord(\cf13 \cb8 'doll'\cf4 \cb8 ))\cb1 \
\cb8 console.log(myTrie.isWord(\cf13 \cb8 'dor'\cf4 \cb8 ))\cb1 \
\cb8 console.log(myTrie.isWord(\cf13 \cb8 'dorf'\cf4 \cb8 ))\cb1 \
\cb8 console.log(myTrie.print())}