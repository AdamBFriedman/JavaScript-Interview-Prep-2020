{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red154\green154\blue154;\red191\green28\blue37;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
\red29\green38\blue42;\red255\green255\blue254;\red19\green120\blue72;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c66667\c66667\c66667;\cssrgb\c80392\c19216\c19216;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
\cssrgb\c14902\c19608\c21961;\cssrgb\c100000\c100000\c99608;\cssrgb\c3529\c53333\c35294;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14620\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 ''\cf4 ).sort().join(\cf7 ''\cf4 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\

\f0\b \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  sumAll = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \

\f0\b \cf2 \cb3 \
// Fibonacci O(2^n) or O(n) with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  fibonacci = (n, memo) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     memo = memo || \{\}\cb1 \
\cb5     \cf6 if\cf4  (n <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[n] = fibonacci(n - \cf8 1\cf4 , memo) + fibonacci(n - \cf8 2\cf4 , memo)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[n]\cb1 \
\cb5 \}
\f0\b \cf2 \cb3 \
\
// Two Sum
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
let\cf4  twoSum = (nums, target) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf4 , \cf8 3\cf4 , \cf8 8\cf4 , \cf8 7\cf4 , \cf8 4\cf4 ], \cf8 9\cf4 ) \cf10 //[0, 3]\
\

\f0\b \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
let\cf4  solution = \cf6 function\cf4 (isBadVersion) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 return\cf4  \cf6 function\cf4 (n) \{\cb1 \
\cb5         \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5         \cf6 let\cf4  right = n;\cb1 \
\cb5         \cb1 \
\cb5         \cf6 while\cf4  (left < right) \{\cb1 \
\cb5             \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\cb5             \cf6 if\cf4  (!isBadVersion(mid)) \{\cb1 \
\cb5                 left = mid + \cf8 1\cf4 ;\cb1 \
\cb5             \} \cf6 else\cf4  \{\cb1 \
\cb5                 right = mid;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\
\cb5         \cf6 return\cf4  left;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  mySqrt = num => \{\cf11 \'a0\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5     \cf6 return\cf4  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5   \cf6 let\cf4  right = num;\cb1 \
\
\cb5   \cf6 while\cf4  (left < right) \{\cb1 \
\cb5     \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\
\cb5    \'a0\cf6 if\cf4  (mid * mid === num) \cf6 return\cf4  mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf6 if\cf4  (mid * mid < num) left = mid + \cf8 1\cf4 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 return\cf4  left;\cb1 \
\cb5 \};\cb1 \
\cb5 \

\f0\b \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  rob = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 if\cf4  (nums === \cf6 null\cf4  || nums.length === \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 0\cf4 ;\cb1 \
\cb5     \} \cf6 else\cf4  \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  nums[\cf8 0\cf4 ];\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 let\cf4  runningTotal = [];\cb1 \
\cb5     runningTotal[\cf8 0\cf4 ] = nums[\cf8 0\cf4 ],\cb1 \
\cb5     runningTotal[\cf8 1\cf4 ] = \cf9 Math\cf4 .max(nums[\cf8 0\cf4 ], nums[\cf8 1\cf4 ]);\cb1 \
\
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 2\cf4 ; i < nums.length; i++) \{\cb1 \
\
\cb5        runningTotal[i] = \cf9 Math\cf4 .max(nums[i] + runningTotal[i - \cf8 2\cf4 ], runningTotal[i - \cf8 1\cf4 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  runningTotal[runningTotal.length - \cf8 1\cf4 ];\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numberOfSteps = num => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 let\cf4  count = \cf8 0\cf4 \cb1 \
\
\cb5     \cf6 while\cf4  (num > \cf8 0\cf4 ) \{\cb1 \
\cb5         \cf6 if\cf4  (num % \cf8 2\cf4  === \cf8 1\cf4 ) \{\cb1 \
\cb5             num = num - \cf8 1\cf4 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5         num = num / \cf8 2\cf4 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 return\cf4  count\cb1 \
\cb5 \};\
\

\f0\b \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  numIslands = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 const\cf4  height = grid.length;\cb1 \
\cb5   \cf6 const\cf4  width = height && grid[\cf8 0\cf4 ].length;\cb1 \
\cb5   \cf6 let\cf4  count = \cf8 0\cf4 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < height; row++) \{\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < width; col++) \{\cb1 \
\cb5       \cf6 if\cf4  (grid[row][col] === \cf7 '0'\cf4 ) \cf6 continue\cf4 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 function\cf4  dfs(row, col) \{\cb1 \
\cb5     \cf6 if\cf4  (row < \cf8 0\cf4  || col < \cf8 0\cf4  || row === height || col === width || grid[row][col] === \cf7 '0'\cf4 ) \cf6 return\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 '0'\cf4 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf4 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf4 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf4 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\
\

\f0\b \cf2 \cb3 // Largest Number in Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  largestNumber = nums => \{\cb1 \
\cb5   \cf6 const\cf4  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb5     \cf10 // -1 a goes before b\cf4 \cb1 \
\cb5     \cf10 // 0  no change\cf4 \cb1 \
\cb5     \cf10 // 1  b goes before a\cf4 \cb1 \
\cb5     \cf6 const\cf4  compareFunc = (a, b) => \cf7 \cb5 `\cf4 \cb5 $\{b\}$\{a\}\cf7 \cb5 `\cf4 \cb5  - \cf7 \cb5 `\cf4 \cb5 $\{a\}$\{b\}\cf7 \cb5 `\cf4 \cb1 \
\
\cb5     finalNums.sort(compareFunc);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 if\cf4 (finalNums[\cf8 0\cf4 ] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 return\cf4  \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  finalNums.join(\cf7 \cb5 ''\cf4 \cb5 );\cb1 \
\cb5 \};\cb1 \
\
\
\cf9 \cb5 Input\cf4 : [\cf8 3\cf4 ,\cf8 30\cf4 ,\cf8 34\cf4 ,\cf8 5\cf4 ,\cf8 9\cf4 ]\cb1 \
\cf9 \cb5 Output\cf4 : \cf7 \cb5 "9534330"\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Get All Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  getPermutations = arr => \{\cb1 \
\
\cb5   \cf6 const\cf4  output = [];\cb1 \
\
\cb5   \cf6 const\cf4  swap = (arrToSwap, indexA, indexB) => \{\cb1 \
\cb5     \cf6 const\cf4  temp = arrToSwap[indexA];\cb1 \
\cb5     arrToSwap[indexA] = arrToSwap[indexB];\cb1 \
\cb5     arrToSwap[indexB] = temp;\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 const\cf4  generate = (n, heapArr) => \{\cb1 \
\cb5     \cf6 if\cf4  (n === \cf8 1\cf4 ) \{\cb1 \
\cb5       output.push(heapArr.slice());\cb1 \
\cb5       \cf6 return\cf4 ;\cb1 \
\cb5     \}\cb1 \
\
\cb5     generate(n - \cf8 1\cf4 , heapArr);\cb1 \
\
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < n - \cf8 1\cf4 ; i++) \{\cb1 \
\cb5       \cf6 if\cf4  (n % \cf8 2\cf4  === \cf8 0\cf4 ) \{\cb1 \
\cb5         swap(heapArr, i, n - \cf8 1\cf4 );\cb1 \
\cb5       \} \cf6 else\cf4  \{\cb1 \
\cb5         swap(heapArr, \cf8 0\cf4 , n - \cf8 1\cf4 );\cb1 \
\cb5       \}\cb1 \
\
\cb5       generate(n - \cf8 1\cf4 , heapArr);\cb1 \
\cb5     \}\cb1 \
\cb5   \};\cb1 \
\
\cb5   generate(arr.length, arr.slice());\cb1 \
\
\cb5   \cf6 return\cf4  output;\cb1 \
\cb5 \};\cb1 \
\
\cb5 getPermutations([\cf8 1\cf4 , \cf8 2\cf4 , \cf8 3\cf4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two arrays of integers\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0and\'a0
\f4 \cf13 \cb14 index
\f3 \cf12 \cb3 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
From left to right read nums[i] and index[i], insert at index\'a0
\f4 \cf13 \cb14 index[i]
\f3 \cf12 \cb3 \'a0the value\'a0
\f4 \cf13 \cb14 nums[i]
\f3 \cf12 \cb3 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Repeat the previous step until there are no elements to read in\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0and\'a0
\f4 \cf13 \cb14 index.
\f3 \cf12 \cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  createTargetArray = (nums, idx) => \{\cb1 \
\cb5     \cf6 let\cf4  target = []\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  num \cf6 in\cf4  nums)target.splice(idx[num], \cf8 0\cf4 , nums[num])\cb1 \
\cb5     \cf6 return\cf4  target\cb1 \
\cb5 \};\cb1 \
\
\
\cf6 \cb5 let\cf4  nums = [\cf8 0\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 3\cf4 ,\cf8 4\cf4 ]\cb1 \
\cf6 \cb5 let\cf4  index = [\cf8 0\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 2\cf4 ,\cf8 1\cf4 ]\cb1 \
\
\cf10 \cb5 //Output: [0,4,1,3,2]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  climbStairs = n => \{\cb1 \
\cb5     \cf6 let\cf4  arr=[\cf8 1\cf4 , \cf8 2\cf4 , \cf8 3\cf4 ];\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 3\cf4 ;i<n;i++)\{\cb1 \
\cb5         arr[i]=arr[i-\cf8 1\cf4 ] + arr[i-\cf8 2\cf4 ];\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  arr[n-\cf8 1\cf4 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Image/Grid/Matrix 90deg
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf15 \cb3 \outl0\strokewidth0 \strokec15 You are given an\'a0
\f5\i n
\f3\i0 \'a0x\'a0
\f5\i n
\f3\i0 \'a02D matrix representing an image.\
Rotate the image by 90 degrees (clockwise).\

\f6\b Note:
\f3\b0 \
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.\'a0
\f6\b DO NOT
\f3\b0 \'a0allocate another 2D matrix and do the rotation.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  rotate = grid => \{\cb1 \
\
\cf6 \cb5 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < grid.length; i++)\{\cb1 \
\cf6 \cb5 for\cf4 (\cf6 let\cf4  j = \cf8 0\cf4 ; j < i; j++)\{\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 //swap\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4  temp = grid[i][j];\cb1 \
\cb5 grid[i][j]=grid[j][i];\cb1 \
\cb5 grid[j][i] = temp;\cb1 \
\cb5 \}\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 for\cf4 (\cf6 var\cf4  i=\cf8 0\cf4 ;i<grid.length; i++)\{\cb1 \
\cb5 grid[i].reverse();\cb1 \
\cb5 \}\cb1 \
\cf6 \cb5 return\cf4  grid\cb1 \
\cb5 \};\cb1 \
\
\cf6 \cb5 let\cf4  x = [\cb1 \
\cb5   [\cf8 1\cf4 ,\cf8 2\cf4 ,\cf8 3\cf4 ],\cb1 \
\cb5   [\cf8 4\cf4 ,\cf8 5\cf4 ,\cf8 6\cf4 ],\cb1 \
\cb5   [\cf8 7\cf4 ,\cf8 8\cf4 ,\cf8 9\cf4 ]\cb1 \
\cb5 ]\cb1 \
\cf10 \cb5 // [\cf4 \cb1 \
\cf10 \cb5 //  [7,4,1],\cf4 \cb1 \
\cf10 \cb5 //  [8,5,2],\cf4 \cb1 \
\cf10 \cb5 //  [9,6,3]\cf4 \cb1 \
\cf10 \cb5 // ]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Transpose Matrix 
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  transpose = arr => \{\cb1 \
\cb5     \cf6 if\cf4 (arr.length === \cf8 0\cf4 ) \cf6 return\cf4  [];\cb1 \
\cb5     \cf6 let\cf4  width = arr[\cf8 0\cf4 ].length \cb1 \
\cb5     \cf6 let\cf4  height = arr.length;\cb1 \
\cb5     \cf6 var\cf4  result = [];\cb1 \
\cb5     \cf6 for\cf4 (\cf6 var\cf4  i = \cf8 0\cf4 ; i < width; i++) \{\cb1 \
\cb5         result[i] = [];\cb1 \
\cb5         \cf6 for\cf4 (\cf6 var\cf4  j = \cf8 0\cf4 ; j < height; j++)\{\cb1 \
\cb5             result[i][j] = arr[j][i];\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb3 Input: 
\f1\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],[2,5,8],[3,6,9]]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm.  Dynamic Programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given an integer array\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  maxSubArray = nums => \{\cb1 \
\cb5     \cf6 let\cf4  currentMax = nums[\cf8 0\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  max = nums[\cf8 0\cf4 ];\cb1 \
\
\cb5   \cf6 for\cf4  (\cf6 let\cf4  num \cf6 of\cf4  nums) \{\cb1 \
\cb5     \cf6 let\cf4  current = num;\cb1 \
\cb5     currentMax = \cf9 Math\cf4 .max(current, current + currentMax);\cb1 \
\cb5     max = \cf9 Math\cf4 .max(max, currentMax);\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  max;\cb1 \
\cb5 \};\cb1 \
\
\cb5 maxSubArray([\cf8 1\cf4 , \cf8 3\cf4 , -\cf8 4\cf4 , \cf8 4\cf4 , -\cf8 6\cf4 , \cf8 3\cf4 , \cf8 9\cf4 , -\cf8 11\cf4 , \cf8 10\cf4 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Knight Probability
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 On an\'a0
\f4 \cf13 \cb14 N
\f3 \cf12 \cb3 x
\f4 \cf13 \cb14 N
\f3 \cf12 \cb3 \'a0chessboard, a knight starts at the\'a0
\f4 \cf13 \cb14 r
\f3 \cf12 \cb3 -th row and\'a0
\f4 \cf13 \cb14 c
\f3 \cf12 \cb3 -th column and attempts to make exactly\'a0
\f4 \cf13 \cb14 K
\f3 \cf12 \cb3 \'a0moves. The rows and columns are 0 indexed, so the top-left square is\'a0
\f4 \cf13 \cb14 (0, 0)
\f3 \cf12 \cb3 , and the bottom-right square is\'a0
\f4 \cf13 \cb14 (N-1, N-1)
\f3 \cf12 \cb3 .\
A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\
The knight continues moving until it has made exactly\'a0
\f4 \cf13 \cb14 K
\f3 \cf12 \cb3 \'a0moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb14 Input:
\f1\b0  3, 2, 0, 0\

\f0\b Output:
\f1\b0  0.0625\

\f0\b Explanation:
\f1\b0  There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\
From each of those positions, there are also two moves that will keep the knight on the board.\
The total probability the knight stays on the board is 0.0625.\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  knightProbability = (\cf9 N\cf4 , \cf9 K\cf4 , r, c) => \{\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  dp = \cf6 new\cf4  \cf9 Array\cf4 (\cf9 N\cf4 );\cb1 \
\cb5     \cf6 const\cf4  movesR = [\cf8 2\cf4 ,\cf8 2\cf4 ,-\cf8 2\cf4 ,-\cf8 2\cf4 ,\cf8 1\cf4 ,\cf8 1\cf4 ,-\cf8 1\cf4 ,-\cf8 1\cf4 ];\cb1 \
\cb5     \cf6 const\cf4  movesC = [\cf8 1\cf4 ,-\cf8 1\cf4 ,\cf8 1\cf4 ,-\cf8 1\cf4 ,\cf8 2\cf4 ,-\cf8 2\cf4 ,\cf8 2\cf4 ,-\cf8 2\cf4 ]; \cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  col = \cf8 0\cf4 ; col < dp.length; col++) \{\cb1 \
\cb5         dp[col] = \cf6 new\cf4  \cf9 Array\cf4 (\cf9 N\cf4 );\cb1 \
\cb5         \cf6 for\cf4 (\cf6 let\cf4  k = \cf8 0\cf4 ; k < dp[col].length; k++) \{\cb1 \
\cb5             dp[col][k] = [\cf8 1\cf4 ]; \cf10 // 0 move has 100% of staying on the board\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  s = \cf8 1\cf4 ; s < \cf9 K\cf4  + \cf8 1\cf4 ; s++) \{\cb1 \
\cb5         \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 0\cf4 ; i < \cf9 N\cf4 ; i++) \{\cb1 \
\cb5             \cf6 for\cf4 (\cf6 let\cf4  j = \cf8 0\cf4 ; j < \cf9 N\cf4 ; j++) \{\cb1 \
\cb5                 \cf6 let\cf4  probability = \cf8 0.0\cf4 ;\cb1 \
\cb5                 \cf6 for\cf4 (\cf6 let\cf4  m = \cf8 0\cf4 ; m < \cf8 8\cf4 ; m++) \{\cb1 \
\cb5                     \cf6 const\cf4  nextRow = i + movesR[m];\cb1 \
\cb5                     \cf6 const\cf4  nextCol = j + movesC[m];\cb1 \
\cb5                     \cf6 if\cf4 (nextRow >= \cf8 0\cf4  && nextRow < \cf9 N\cf4  && nextCol >= \cf8 0\cf4  && nextCol < \cf9 N\cf4 ) \{\cb1 \
\cb5                         probability += dp[nextRow][nextCol][s-\cf8 1\cf4 ]/\cf8 8.0\cf4 ; \cf10 // % of chance out of 8 moves\cf4 \cb1 \
\cb5                     \}\cb1 \
\cb5                 \}\cb1 \
\cb5                 dp[i][j][s] = probability;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  dp[r][c][\cf9 K\cf4 ];\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Product Except Self
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0of\'a0
\f5\i n
\f3\i0 \'a0integers where\'a0
\f5\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f4 \cf13 \cb14 output
\f3 \cf12 \cb3 \'a0such that\'a0
\f4 \cf13 \cb14 output[i]
\f3 \cf12 \cb3 \'a0is equal to the product of all the elements of\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0except\'a0
\f4 \cf13 \cb14 nums[i]
\f3 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb14 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf12 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f6\b Note:\'a0
\f3\b0 Please solve it\'a0
\f6\b without division
\f3\b0 \'a0and in O(
\f5\i n
\f3\i0 ).
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  productExceptSelf = nums => \{\cb1 \
\cb5     \cf6 let\cf4  length = nums.length;\cb1 \
\cb5     \cf6 let\cf4  result = [\cf8 1\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  temp = \cf8 1\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < length; i++) \{\cb1 \
\cb5         result[i] = result[i - \cf8 1\cf4 ] * nums[i - \cf8 1\cf4 ];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = length - \cf8 1\cf4 ; i > -\cf8 1\cf4 ; i--) \{\cb1 \
\cb5         result[i] = result[i] * temp;\cb1 \
\cb5         temp = temp * nums[i];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Square in Grid
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  largestSquare = grid => \{\cb1 \
\cb5     \cf6 let\cf4  rows = grid.length;\cb1 \
\cb5     \cf6 let\cf4  cols = rows ? grid[\cf8 0\cf4 ].length : \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 let\cf4  max = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  row = \cf8 0\cf4 ; row < rows; row++) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  col = \cf8 0\cf4 ; col < cols; col++) \{\cb1 \
\cb5             \cf6 let\cf4  left = col === \cf8 0\cf4  ? \cf8 0\cf4  : grid[row][col - \cf8 1\cf4 ],\cb1 \
\cb5                 up = row === \cf8 0\cf4  ? \cf8 0\cf4  : grid[row - \cf8 1\cf4 ][col], \cb1 \
\cb5                 back = row && col ? grid[row - \cf8 1\cf4 ][col - \cf8 1\cf4 ] : \cf8 0\cf4 ;\cb1 \
\cb5             \cf6 if\cf4  (grid[row][col] == \cf8 1\cf4 ) \{\cb1 \
\cb5                 grid[row][col] = \cf9 Math\cf4 .min(left, up, back) + grid[row][col] * \cf8 1\cf4 ;\cb1 \
\cb5             \} \cf6 else\cf4  \{\cb1 \
\cb5                 grid[row][col] = \cf8 0\cf4 ;\cb1 \
\cb5             \};\cb1 \
\cb5             max = max > grid[row][col] ? max : grid[row][col];\cb1 \
\cb5         \};\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  max * max;\cb1 \
\cb5 \};\
\
\cf6 let\cf4  items = [\cb1 \
\cb5   [\cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 ],\cb1 \
\cb5   [\cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 ],\cb1 \
\cb5   [\cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 ],\cb1 \
\cb5   [\cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 ],\cb1 \
\cb5   [\cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 ]\cb1 \
\cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Tower of Hanoi (Recursion)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  hanoiTower = (height, srcP, destP, bufferP) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (height >= \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\
\cb5     \cf10 \cb5 // Move a tower of height-1 to the buffer peg, using the destination peg.\cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , srcP, bufferP, destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the remaining disk to the destination peg.\cf4 \cb1 \
\cb5     console.log(\cf7 \cb5 'Move disk from Tower '\cf4 \cb5 , srcP, \cf7 \cb5 ' to Tower '\cf4 \cb5 , destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.        \cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , bufferP, destP, srcP);\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5 \}\cb1 \
\
\cb5 hanoiTower(\cf8 \cb5 3\cf4 \cb5 , \cf7 \cb5 "A"\cf4 \cb5 , \cf7 \cb5 "C"\cf4 \cb5 , \cf7 \cb5 "B"\cf4 \cb5 );\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  permute = (nums, memo = \cf8 0\cf4 ) => \{\cb1 \
\cb5     \cf6 if\cf4  (memo >= nums.length) \cf6 return\cf4  [[]];\cb1 \
\cb5     \cf6 const\cf4  res = [];\cb1 \
\cb5     \cf6 const\cf4  prevs = permute(nums, memo + \cf8 1\cf4 );  \cf10 // permutations of elements after n\cf4 \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  prev \cf6 of\cf4  prevs) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i <= prev.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  p = prev.slice(\cf8 0\cf4 );\cb1 \
\cb5             p.splice(i, \cf8 0\cf4 , nums[memo]);  \cf10 // successively insert element n\cf4 \cb1 \
\cb5             res.push(p); \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  res;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations 2 (Unique)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb5 const\cf4  permuteUnique = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 let\cf4  permU = \cf6 function\cf4 (nums) \{\cb1 \
\cb5         \cf6 if\cf4  (nums.length == \cf8 1\cf4 ) \cf6 return\cf4  [nums];\cb1 \
\cb5         \cf6 let\cf4  res = []\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  temp = [...nums.slice(\cf8 0\cf4 , i), ...nums.slice(i+\cf8 1\cf4 )];\cb1 \
\cb5             \cf6 for\cf4  (\cf6 let\cf4  c \cf6 of\cf4  permU(temp)) \{\cb1 \
\cb5                 res.push([nums[i], ...c]); \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 while\cf4 (nums[i+\cf8 1\cf4 ]==nums[i])i++; \cf10 // skip\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 return\cf4  res;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  permU(nums);\cb1 \
\cb5 \};\cb1 \
\cb5 nums = [\cf8 1\cf4 ,\cf8 1\cf4 ,\cf8 2\cf4 ]\cb1 \
\cb5 permuteUnique(nums) \cb1 \
\cf10 \cb5 //[ [ 1, 1, 2 ], [ 1, 2, 1 ], [ 2, 1, 1 ] ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Range Sum of BST
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given the\'a0
\f4\fs26 \cf13 \cb14 root
\f3\fs28 \cf12 \cb3 \'a0node of a binary search tree, return the sum of values of all nodes with value between\'a0
\f4\fs26 \cf13 \cb14 L
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f4\fs26 \cf13 \cb14 R
\f3\fs28 \cf12 \cb3 \'a0(inclusive).\
The binary search tree is guaranteed to have unique values.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  rangeSumBST = (root, \cf9 L\cf4 , \cf9 R\cf4 ) => \{\cb1 \
\cb5     \cf10 // check if value is in the given range\cf4 \cb1 \
\cb5     \cf6 const\cf4  isInBetween = val => val >= \cf9 L\cf4  && val <= \cf9 R\cf4 ;\cb1 \
\cb5     \cf10 // sum the value if it's in the range\cf4 \cb1 \
\cb5     \cf6 const\cf4  add = (val, sum) => isInBetween(val) ? sum += val : sum;\cb1 \
\cb5 \'a0\'a0\cf10 // traverse through the nodes and sum the values in range\cf4 \cb1 \
\cb5     \cf6 const\cf4  preorder =(root, sum) => \{\cb1 \
\cb5         \cf6 if\cf4  (!root) \cf6 return\cf4  sum;\cb1 \
\cb5         \cf6 return\cf4  add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\cb1 \
\cb5     \} \cb1 \
\cb5     \cf6 return\cf4  preorder(root, \cf8 0\cf4 )\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shortest Path in Maze
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 function\cf4  \cf9 Point\cf4 (x, y) \{\cb1 \
\cb5   \cf6 this\cf4 .x = x;\cb1 \
\cb5   \cf6 this\cf4 .y = y;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 function\cf4  \cf9 Node\cf4 (pt, dist) \{\cb1 \
\cb5   \cf6 this\cf4 .pt = pt;\cb1 \
\cb5   \cf6 this\cf4 .dist = dist;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 var\cf4  d = [\cb1 \
\cb5   \{x: \cf8 0\cf4 , y: \cf8 1\cf4 \},\cb1 \
\cb5   \{x: \cf8 1\cf4 , y: \cf8 0\cf4 \},\cb1 \
\cb5   \{x: \cf8 0\cf4 , y: -\cf8 1\cf4 \},\cb1 \
\cb5   \{x: -\cf8 1\cf4 , y: \cf8 0\cf4 \}\cb1 \
\cb5 ];\cb1 \
\
\cf6 \cb5 function\cf4  bfs(maze, src, dest) \{\cb1 \
\cb5   \cf6 var\cf4  minDist = -\cf8 1\cf4 ;\cb1 \
\cb5     \cf6 if\cf4  (maze[src.x][src.y] != \cf8 1\cf4  || maze[dest.x][dest.y] != \cf8 1\cf4 )\cb1 \
\cb5       \cf6 return\cf4  minDist;\cb1 \
\cb5   \cf6 var\cf4  h = maze.length;\cb1 \
\cb5   \cf6 var\cf4  w = maze[\cf8 0\cf4 ].length;\cb1 \
\cb5   visited = [];\cb1 \
\cb5   \cf6 for\cf4  (\cf6 var\cf4  i = \cf8 0\cf4 ; i < h; i++) \{\cb1 \
\cb5     visited.push([]);\cb1 \
\cb5     \cf6 for\cf4  (\cf6 var\cf4  j = \cf8 0\cf4 ; j < w; j++) \{\cb1 \
\cb5       visited[i].push(\cf6 false\cf4 );\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 var\cf4  queue = [];\cb1 \
\cb5   \cf6 var\cf4  s = \cf6 new\cf4  \cf9 Node\cf4 (src, \cf8 0\cf4 );\cb1 \
\cb5   queue.push(s);\cb1 \
\
\cb5   \cf6 while\cf4  (queue.length>\cf8 0\cf4 ) \{\cb1 \
\cb5     \cf6 var\cf4  curr = queue.pop();\cb1 \
\cb5     \cf6 var\cf4  pt = curr.pt;\cb1 \
\cb5     \cf6 if\cf4  (pt.x == dest.x && pt.y == dest.y)\cb1 \
\cb5       \cf6 return\cf4  curr.dist;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 var\cf4  i = \cf8 0\cf4 ; i < \cf8 4\cf4 ; i++) \{\cb1 \
\cb5       \cf6 var\cf4  row = pt.x + d[i].x;\cb1 \
\cb5       \cf6 var\cf4  col = pt.y + d[i].y;\cb1 \
\cb5       \cf6 if\cf4  (isValid(maze, visited, h, w, row, col)) \{\cb1 \
\cb5         visited[row][col] = \cf6 true\cf4 ;\cb1 \
\cb5         \cf6 var\cf4  adjCell = \cf6 new\cf4  \cf9 Node\cf4 (\cf6 new\cf4  \cf9 Point\cf4 (row, col), curr.dist + \cf8 1\cf4 );\cb1 \
\cb5         queue.push(adjCell);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 return\cf4  minDist;\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 function\cf4  isValid(maze, visited, width, height, row, col) \{\cb1 \
\cb5   \cf6 return\cf4  (row >= \cf8 0\cf4 ) && (row < width) && (col >= \cf8 0\cf4 ) && (col < height) && maze[row][col] == \cf8 1\cf4  && !visited[row][col];\cb1 \
\cb5 \}\cb1 \
\
\cf6 \cb5 var\cf4  maze = [\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4  ],\cb1 \
\cb5     [ \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 1\cf4  ],\cb1 \
\cb5     [ \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4 , \cf8 1\cf4 , \cf8 0\cf4 , \cf8 0\cf4 , \cf8 1\cf4  ]\cb1 \
\cb5 ];\cb1 \
\
\cf6 \cb5 var\cf4  source = \cf6 new\cf4  \cf9 Point\cf4 (\cf8 0\cf4 , \cf8 0\cf4 );\cb1 \
\cf6 \cb5 var\cf4  dest = \cf6 new\cf4  \cf9 Point\cf4 (\cf8 7\cf4 , \cf8 5\cf4 );\cb1 \
\cf6 \cb5 var\cf4  dist = bfs(maze, source, dest);\cb1 \
\
\cf6 \cb5 if\cf4  (dist != -\cf8 1\cf4 )\cb1 \
\cb5   console.log(\cf7 \cb5 `The shortest path from (\cf4 \cb5 $\{source.x\}\cf7 \cb5 , \cf4 \cb5 $\{source.y\}\cf7 \cb5 ) to (\cf4 \cb5 $\{dest.x\}\cf7 \cb5 , \cf4 \cb5 $\{dest.y\}\cf7 \cb5 ) has length \cf4 \cb5 $\{dist\}\cf7 \cb5 \\n`\cf4 \cb5 );\cb1 \
\cf6 \cb5 else\cf4 \cb1 \
\cb5   console.log(\cf7 \cb5 `Shortest path from \cf4 \cb5 $\{(source.x, source.y)\}\cf7 \cb5  to \cf4 \cb5 $\{(dest.x, dest.y)\}\cf7 \cb5  does not exist`\cf4 \cb5 );\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Repeated Substring Pattern
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf15 \cb3 \outl0\strokewidth0 \strokec15 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb16 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  repeatedSubstringPattern = string => \{\cb1 \
\cb16     \cf6 \strokec6 if\cf4 \strokec4  (string.length === \cf17 \strokec17 0\cf4 \strokec4  || string.length === \cf17 \strokec17 1\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb16     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 1\cf4 \strokec4 ; i <= string.length / \cf17 \strokec17 2\cf4 \strokec4 ; i++) \{\cb1 \
\cb16         \cf6 \strokec6 if\cf4 \strokec4  (string.length % i === \cf17 \strokec17 0\cf4 \strokec4  && string.slice(\cf17 \strokec17 0\cf4 \strokec4 , i).repeat(string.length / i) === string) \{\cb1 \
\cb16             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb16         \}\cb1 \
\cb16     \}\cb1 \
\cb16     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb16 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Next Problem
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  functionName = arr => \{\cb1 \
\
\}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Next Problem
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  functionName = arr => \{\cb1 \
\
\}\
\
}