{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red255\green255\blue254;\red154\green154\blue154;\red19\green120\blue72;\red14\green110\blue109;
\red149\green155\blue194;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c65098\c67451\c80392;}
\margl1440\margr1440\vieww14900\viewh17260\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// MERGE SORT\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0\fs28 \cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb6 const\cf4  mergeSort = array => \{\cb1 \
\cb6   \cf7 \cb6 //Check if array can be split\cf4 \cb1 \
\cb6   \cf5 if\cf4 (array.length < \cf8 2\cf4 ) \cf5 return\cf4  array;\cb1 \
\cb6   \cf7 \cb6 //Get Middle index\cf4 \cb1 \
\cb6   \cf5 const\cf4  middle = \cf9 \cb6 Math\cf4 \cb6 .floor(array.length / \cf8 2\cf4 );\cb1 \
\cb6   \cf7 \cb6 //Split Array In Two Sides\cf4 \cb1 \
\cb6   \cf5 const\cf4  leftSide = array.slice(\cf8 0\cf4 , middle);\cb1 \
\cb6   \cf5 const\cf4  rightSide = array.slice(middle, array.length);\cb1 \
\cb6   \cf7 \cb6 //Use recursion to continue splitting\cf4 \cb1 \
\cb6   \cf5 return\cf4  merge(mergeSort(leftSide), mergeSort(rightSide));\cb1 \
\cb6 \}\cb1 \
\
\cf5 \cb6 const\cf4  merge = (left, right) => \{\cb1 \
\cb6   \cf7 \cb6 //Create New Array\cf4 \cb1 \
\cb6   \cf5 const\cf4  result = [];\cb1 \
\cb6   \cf7 \cb6 //Check if left array and right array is empty\cf4 \cb1 \
\cb6   \cf5 while\cf4 (left.length && right.length) \{\cb1 \
\cb6     \cf7 \cb6 //Find lower value\cf4 \cb1 \
\cb6     \cf5 if\cf4 (left[\cf8 0\cf4 ] <= right[\cf8 0\cf4 ]) \{\cb1 \
\cb6       \cf7 \cb6 //Add left value\cf4 \cb1 \
\cb6       result.push(left.shift());\cb1 \
\cb6     \} \cf5 else\cf4  \{\cb1 \
\cb6       \cf7 \cb6 //Add right value\cf4 \cb1 \
\cb6       result.push(right.shift());\cb1 \
\cb6     \}\cb1 \
\cb6   \}\cb1 \
\cb6   \cf7 \cb6 //Merge left array\cf4 \cb1 \
\cb6   \cf5 while\cf4 (left.length) result.push(left.shift());\cb1 \
\cb6   \cf7 \cb6 //Merge right array\cf4 \cb1 \
\cb6   \cf5 while\cf4 (right.length) result.push(right.shift());\cb1 \
\cb6   \cf7 \cb6 //return result array\cf4 \cb1 \
\cb6   \cf5 return\cf4  result;\cb1 \
\cb6 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // QUICK SORT
\f1\b0\fs28 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb6 function\cf4  quickSort(arr, start, end) \{\cb1 \
\cb6     \cf5 if\cf4  (start >= end) \{\cb1 \
\cb6       \cf5 return\cf4 ;\cb1 \
\cb6     \}\cb1 \
\cb6     \cf5 let\cf4  index = partition(arr, start, end);\cb1 \
\cb6     states[index] = -\cf8 1\cf4 ;\cb1 \
\cb6   \cb1 \
\
\cb6       quickSort(arr, start, index - \cf8 1\cf4 ),\cb1 \
\cb6       quickSort(arr, index + \cf8 1\cf4 , end)\cb1 \
\
\cb6   \}\cb1 \
\cb6   \cb1 \
\cb6   \cf5 function\cf4  partition(arr, start, end) \{\cb1 \
\cb6     \cf5 for\cf4  (\cf5 let\cf4  i = start; i < end; i++) \{\cb1 \
\cb6       states[i] = \cf8 1\cf4 ;\cb1 \
\cb6     \}\cb1 \
\cb6   \cb1 \
\cb6     \cf5 let\cf4  pivotValue = arr[end];\cb1 \
\cb6     \cf5 let\cf4  pivotIndex = start;\cb1 \
\cb6     states[pivotIndex] = \cf8 0\cf4 ;\cb1 \
\cb6     \cf5 for\cf4  (\cf5 let\cf4  i = start; i < end; i++) \{\cb1 \
\cb6       \cf5 if\cf4  (arr[i] < pivotValue) \{\cb1 \
\cb6         swap(arr, i, pivotIndex);\cb1 \
\cb6         states[pivotIndex] = -\cf8 1\cf4 ;\cb1 \
\cb6         pivotIndex++;\cb1 \
\cb6         states[pivotIndex] = \cf8 0\cf4 ;\cb1 \
\cb6       \}\cb1 \
\cb6     \}\cb1 \
\cb6     swap(arr, pivotIndex, end);\cb1 \
\cb6   \cb1 \
\cb6     \cf5 for\cf4  (\cf5 let\cf4  i = start; i < end; i++) \{\cb1 \
\cb6       \cf5 if\cf4  (i != pivotIndex) \{\cb1 \
\cb6         states[i] = -\cf8 1\cf4 ;\cb1 \
\cb6       \}\cb1 \
\cb6     \}\cb1 \
\cb6   \cb1 \
\cb6     \cf5 return\cf4  pivotIndex;\cb1 \
\cb6   \}\cb1 \
\
\cf5 \cb6 function\cf4  swap(arr, a, b) \{\cb1 \
\cb6     \cf5 let\cf4  temp = arr[a];\cb1 \
\cb6     arr[a] = arr[b];\cb1 \
\cb6     arr[b] = temp;\cb1 \
\cb6 \}\cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\fs24 \cf4 \cb3 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // Factorial\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0\fs24 \cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf5 \cb6 function\cf4  factorial(num) \{\cb1 \
\cb6   \cf5 if\cf4  (num < \cf8 2\cf4 ) \{\cb1 \
\cb6     \cf5 return\cf4  num\cb1 \
\cb6   \}\cb1 \
\cb6   \cf5 return\cf4  num * factorial(num - \cf8 1\cf4 )\cb1 \
\cb6 \}\cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\fs24 \cf4 \cb3 \
\
\cf10 \cb1 \
}