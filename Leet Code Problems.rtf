{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red154\green154\blue154;\red191\green28\blue37;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
\red255\green255\blue254;\red14\green110\blue109;\red19\green120\blue72;\red144\green1\blue18;\red29\green38\blue42;
\red245\green247\blue249;\red67\green91\blue103;\red154\green154\blue154;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c66667\c66667\c66667;\cssrgb\c80392\c19216\c19216;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c63922\c8235\c8235;\cssrgb\c14902\c19608\c21961;
\cssrgb\c96863\c97647\c98039;\cssrgb\c32941\c43137\c47843;\cssrgb\c66667\c66667\c66667;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww12980\viewh17140\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  sumAll = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \
// Fibonacci O(2^n) or O(n) with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  fibonacci = (n, memo) => \{\cb1 \
\cb5     memo = memo || \{\}\cb1 \
\cb5     \cf6 if\cf4  (n <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[n] = fibonacci(n - \cf8 1\cf4 , memo) + fibonacci(n - \cf8 2\cf4 , memo)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[n]\cb1 \
\cb5 \}
\f0\b \cf2 \cb3 \
\
// Two Sum
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
const\cf4  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf4 , \cf8 3\cf4 , \cf8 8\cf4 , \cf8 7\cf4 , \cf8 4\cf4 ], \cf8 9\cf4 ) \cf10 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Three Sum
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  threeSum = nums => \{\cb1 \
\cb5     nums.sort((a,b)=>a-b);\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i=\cf8 0\cf4 ;i<nums.length; i++) \{\cb1 \
\cb5         \cf6 let\cf4  t = -nums[i];\cb1 \
\cb5         \cf6 let\cf4  left = i+\cf8 1\cf4 , right = nums.length-\cf8 1\cf4 ;\cb1 \
\cb5         \cf6 while\cf4 (left < right) \{\cb1 \
\cb5             \cf6 if\cf4  (nums[left] + nums[right] == t) \{\cb1 \
\cb5                 result.push([nums[i], nums[left], nums[right]]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[left+\cf8 1\cf4 ] == nums[left++]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[right-\cf8 1\cf4 ] == nums[right--]);\cb1 \
\cb5             \} \cf6 else\cf4  \cf6 if\cf4  (nums[left]+nums[right] < t) left++;\cb1 \
\cb5             \cf6 else\cf4  right--;\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 while\cf4 (nums[i+\cf8 1\cf4 ]==nums[i]) i++\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5     \cb1 \
\cb5 \};\cf10 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
var\cf4  solution = \cf6 function\cf4 (isBadVersion) \{\cb1 \
\
\cb5     \cf6 return\cf4  \cf6 function\cf4 (n) \{\cb1 \
\cb5         \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5         \cf6 let\cf4  right = n;\cb1 \
\cb5         \cf6 while\cf4 (left <= right)\{\cb1 \
\cb5             \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\cb5             \cf6 if\cf4 (isBadVersion(mid))\{\cb1 \
\cb5                 \cf6 if\cf4  ((mid-\cf8 1\cf4  > \cf8 0\cf4  && !isBadVersion(mid-\cf8 1\cf4 )) || (mid === \cf8 1\cf4 ))\{\cb1 \
\cb5                     \cf6 return\cf4  mid;\cb1 \
\cb5                 \}\cf6 else\cf4 \{\cb1 \
\cb5                     right = mid - \cf8 1\cf4 ;\cb1 \
\cb5                 \}\cb1 \
\cb5             \}\cf6 else\cf4 \{\cb1 \
\cb5                 left = mid + \cf8 1\cf4 ;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 return\cf4  -\cf8 1\cf4 ;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  mySqrt = num => \{\cf11 \cb5 \'a0\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (num <= \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 \cb5 let\cf4 \cb5  left = \cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  right = num;\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (left < right) \{\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  mid = left + \cf9 \cb5 Math\cf4 \cb5 .floor((right - left) / \cf8 \cb5 2\cf4 \cb5 );\cb1 \
\
\cb5    \'a0\cf6 \cb5 if\cf4 \cb5  (mid * mid === num) \cf6 \cb5 return\cf4 \cb5  mid;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (mid * mid < num) left = mid + \cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf6 \cb5 return\cf4 \cb5  left;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rob = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5  (nums === \cf6 \cb5 null\cf4 \cb5  || nums.length === \cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \} \cf6 \cb5 else\cf4 \cb5  \cf6 \cb5 if\cf4 \cb5  (nums.length == \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 let\cf4 \cb5  runningTotal = [];\cb1 \
\cb5     runningTotal[\cf8 \cb5 0\cf4 \cb5 ] = nums[\cf8 \cb5 0\cf4 \cb5 ],\cb1 \
\cb5     runningTotal[\cf8 \cb5 1\cf4 \cb5 ] = \cf9 \cb5 Math\cf4 \cb5 .max(nums[\cf8 \cb5 0\cf4 \cb5 ], nums[\cf8 \cb5 1\cf4 \cb5 ]);\cb1 \
\
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 2\cf4 \cb5 ; i < nums.length; i++) \{\cb1 \
\
\cb5        runningTotal[i] = \cf9 \cb5 Math\cf4 \cb5 .max(nums[i] + runningTotal[i - \cf8 \cb5 2\cf4 \cb5 ], runningTotal[i - \cf8 \cb5 1\cf4 \cb5 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 return\cf4 \cb5  runningTotal[runningTotal.length - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  numberOfSteps = num => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  count = \cf8 \cb5 0\cf4 \cb1 \
\
\cb5     \cf6 \cb5 while\cf4 \cb5  (num > \cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (num % \cf8 \cb5 2\cf4 \cb5  === \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5             num = num - \cf8 \cb5 1\cf4 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5         num = num / \cf8 \cb5 2\cf4 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 return\cf4 \cb5  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  numIslands = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 const\cf4 \cb5  height = grid.length;\cb1 \
\cb5   \cf6 \cb5 const\cf4 \cb5  width = height && grid[\cf8 \cb5 0\cf4 \cb5 ].length;\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  count = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  row = \cf8 \cb5 0\cf4 \cb5 ; row < height; row++) \{\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < width; col++) \{\cb1 \
\cb5       \cf6 \cb5 if\cf4 \cb5  (grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 continue\cf4 \cb5 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 function\cf4 \cb5  dfs(row, col) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (row < \cf8 \cb5 0\cf4 \cb5  || col < \cf8 \cb5 0\cf4 \cb5  || row === height || col === width || grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     dfs(row-\cf8 \cb5 1\cf4 \cb5 , col);\cb1 \
\cb5     dfs(row+\cf8 \cb5 1\cf4 \cb5 , col);\cb1 \
\cb5     dfs(row, col-\cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5     dfs(row, col+\cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Number in Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  largestNumber = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 const\cf4 \cb5  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb5     \cf10 \cb5 // -1 a goes before b\cf4 \cb1 \
\cb5     \cf10 \cb5 // 0  no change\cf4 \cb1 \
\cb5     \cf10 \cb5 // 1  b goes before a\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  compareFunc = (a, b) => \cf7 \cb5 `\cf4 \cb5 $\{b\}$\{a\}\cf7 \cb5 `\cf4 \cb5  - \cf7 \cb5 `\cf4 \cb5 $\{a\}$\{b\}\cf7 \cb5 `\cf4 \cb1 \
\
\cb5     finalNums.sort(compareFunc);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5 (finalNums[\cf8 \cb5 0\cf4 \cb5 ] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  finalNums.join(\cf7 \cb5 ''\cf4 \cb5 );\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb5 Input\cf4 \cb5 : [\cf8 \cb5 3\cf4 \cb5 ,\cf8 \cb5 30\cf4 \cb5 ,\cf8 \cb5 34\cf4 \cb5 ,\cf8 \cb5 5\cf4 \cb5 ,\cf8 \cb5 9\cf4 \cb5 ]\cb1 \
\cf9 \cb5 Output\cf4 \cb5 : \cf7 \cb5 "9534330"\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given two arrays of integers\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0and\'a0
\f4 \cf13 \cb14 index
\f3 \cf12 \cb3 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf12 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
From left to right read nums[i] and index[i], insert at index\'a0
\f4 \cf13 \cb14 index[i]
\f3 \cf12 \cb3 \'a0the value\'a0
\f4 \cf13 \cb14 nums[i]
\f3 \cf12 \cb3 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Repeat the previous step until there are no elements to read in\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0and\'a0
\f4 \cf13 \cb14 index.
\f3 \cf12 \cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf12 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  createTargetArray = (nums, idx) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  target = []\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  num \cf6 \cb5 in\cf4 \cb5  nums)target.splice(idx[num], \cf8 \cb5 0\cf4 \cb5 , nums[num])\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  target\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  nums = [\cf8 \cb5 0\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 3\cf4 \cb5 ,\cf8 \cb5 4\cf4 \cb5 ]\cb1 \
\cf6 \cb5 let\cf4 \cb5  index = [\cf8 \cb5 0\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 //Output: [0,4,1,3,2]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  climbStairs = n => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  arr=[\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 2\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 3\cf4 \cb5 ;i<n;i++)\{\cb1 \
\cb5         arr[i]=arr[i-\cf8 \cb5 1\cf4 \cb5 ] + arr[i-\cf8 \cb5 2\cf4 \cb5 ];\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  arr[n-\cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Image 90deg
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 You are given an\'a0
\f5\i n
\f3\i0 \'a0x\'a0
\f5\i n
\f3\i0 \'a02D matrix representing an image.\
Rotate the image by 90 degrees (clockwise).\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf12 Note:
\f3\b0 \
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.\'a0
\f6\b DO NOT
\f3\b0 \'a0allocate another 2D matrix and do the rotation.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rotate = grid => \{\cb1 \
\
\cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ;i < grid.length; i++)\{\cb1 \
\cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ;j < i; j++)\{\cb1 \
\
\cf6 \cb5 let\cf4 \cb5  temp = grid[i][j];\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 grid[i][j] = grid[j][i];\cb1 \
\cb5 grid[j][i] = temp;\cb1 \
\
\cb5 \}\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  g \cf6 \cb5 of\cf4 \cb5  grid) g.reverse()\cb1 \
\
\cf6 \cb5 return\cf4 \cb5  grid\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  x = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 3\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 4\cf4 \cb5 ,\cf8 \cb5 5\cf4 \cb5 ,\cf8 \cb5 6\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 7\cf4 \cb5 ,\cf8 \cb5 8\cf4 \cb5 ,\cf8 \cb5 9\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 // [\cf4 \cb1 \
\cf10 \cb5 //  [7,4,1],\cf4 \cb1 \
\cf10 \cb5 //  [8,5,2],\cf4 \cb1 \
\cf10 \cb5 //  [9,6,3]\cf4 \cb1 \
\cf10 \cb5 // ]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Transpose Matrix 
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  transpose = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5 (arr.length === \cf8 \cb5 0\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  width = arr[\cf8 \cb5 0\cf4 \cb5 ].length \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  height = arr.length;\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  result = [];\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < width; i++) \{\cb1 \
\cb5         result[i] = [];\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < height; j++)\{\cb1 \
\cb5             result[i][j] = arr[j][i];\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb3 Input: 
\f1\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],[2,5,8],[3,6,9]]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm.  Dynamic Programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given an integer array\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  maxSubArray = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  currentMax = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  num \cf6 \cb5 of\cf4 \cb5  nums) \{\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  current = num;\cb1 \
\cb5     currentMax = \cf9 \cb5 Math\cf4 \cb5 .max(current, current + currentMax);\cb1 \
\cb5     max = \cf9 \cb5 Math\cf4 \cb5 .max(max, currentMax);\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  max;\cb1 \
\cb5 \};\cb1 \
\
\cb5 maxSubArray([\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , -\cf8 \cb5 4\cf4 \cb5 , \cf8 \cb5 4\cf4 \cb5 , -\cf8 \cb5 6\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , \cf8 \cb5 9\cf4 \cb5 , -\cf8 \cb5 11\cf4 \cb5 , \cf8 \cb5 10\cf4 \cb5 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Knight Probability
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 On an\'a0
\f4 \cf13 \cb14 N
\f3 \cf12 \cb3 x
\f4 \cf13 \cb14 N
\f3 \cf12 \cb3 \'a0chessboard, a knight starts at the\'a0
\f4 \cf13 \cb14 r
\f3 \cf12 \cb3 -th row and\'a0
\f4 \cf13 \cb14 c
\f3 \cf12 \cb3 -th column and attempts to make exactly\'a0
\f4 \cf13 \cb14 K
\f3 \cf12 \cb3 \'a0moves. The rows and columns are 0 indexed, so the top-left square is\'a0
\f4 \cf13 \cb14 (0, 0)
\f3 \cf12 \cb3 , and the bottom-right square is\'a0
\f4 \cf13 \cb14 (N-1, N-1)
\f3 \cf12 \cb3 .\
A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\
The knight continues moving until it has made exactly\'a0
\f4 \cf13 \cb14 K
\f3 \cf12 \cb3 \'a0moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb14 Input:
\f1\b0  3, 2, 0, 0\

\f0\b Output:
\f1\b0  0.0625\

\f0\b Explanation:
\f1\b0  There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\
From each of those positions, there are also two moves that will keep the knight on the board.\
The total probability the knight stays on the board is 0.0625.\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  knightProbability = (\cf9 \cb5 N\cf4 \cb5 , \cf9 \cb5 K\cf4 \cb5 , r, c) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  dp = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesR = [\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesC = [\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ]; \cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < dp.length; col++) \{\cb1 \
\cb5         dp[col] = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  k = \cf8 \cb5 0\cf4 \cb5 ; k < dp[col].length; k++) \{\cb1 \
\cb5             dp[col][k] = [\cf8 \cb5 1\cf4 \cb5 ]; \cf10 \cb5 // 0 move has 100% of staying on the board\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  s = \cf8 \cb5 1\cf4 \cb5 ; s < \cf9 \cb5 K\cf4 \cb5  + \cf8 \cb5 1\cf4 \cb5 ; s++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf9 \cb5 N\cf4 \cb5 ; i++) \{\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < \cf9 \cb5 N\cf4 \cb5 ; j++) \{\cb1 \
\cb5                 \cf6 \cb5 let\cf4 \cb5  probability = \cf8 \cb5 0.0\cf4 \cb5 ;\cb1 \
\cb5                 \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  m = \cf8 \cb5 0\cf4 \cb5 ; m < \cf8 \cb5 8\cf4 \cb5 ; m++) \{\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextRow = i + movesR[m];\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextCol = j + movesC[m];\cb1 \
\cb5                     \cf6 \cb5 if\cf4 \cb5 (nextRow >= \cf8 \cb5 0\cf4 \cb5  && nextRow < \cf9 \cb5 N\cf4 \cb5  && nextCol >= \cf8 \cb5 0\cf4 \cb5  && nextCol < \cf9 \cb5 N\cf4 \cb5 ) \{\cb1 \
\cb5                         probability += dp[nextRow][nextCol][s-\cf8 \cb5 1\cf4 \cb5 ]/\cf8 \cb5 8.0\cf4 \cb5 ; \cf10 \cb5 // % of chance out of 8 moves\cf4 \cb1 \
\cb5                     \}\cb1 \
\cb5                 \}\cb1 \
\cb5                 dp[i][j][s] = probability;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  dp[r][c][\cf9 \cb5 K\cf4 \cb5 ];\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Product Except Self
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given an array\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0of\'a0
\f5\i n
\f3\i0 \'a0integers where\'a0
\f5\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f4 \cf13 \cb14 output
\f3 \cf12 \cb3 \'a0such that\'a0
\f4 \cf13 \cb14 output[i]
\f3 \cf12 \cb3 \'a0is equal to the product of all the elements of\'a0
\f4 \cf13 \cb14 nums
\f3 \cf12 \cb3 \'a0except\'a0
\f4 \cf13 \cb14 nums[i]
\f3 \cf12 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf12 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf12 \cb14 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf12 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f6\b Note:\'a0
\f3\b0 Please solve it\'a0
\f6\b without division
\f3\b0 \'a0and in O(
\f5\i n
\f3\i0 ).
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\cf6 const\cf4  productExceptSelf = nums => \{\cb1 \
\cb5     \cf6 let\cf4  result = [\cf8 1\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  temp = \cf8 1\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         result[i] = result[i - \cf8 1\cf4 ] * nums[i - \cf8 1\cf4 ];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = nums.length - \cf8 1\cf4 ; i >= \cf8 \cb5 0\cf4 \cb5 ; i--) \{\cb1 \
\cb5         result[i] *= temp;\cb1 \
\cb5         temp *= nums[i];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Square in Grid
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  largestSquare = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  height = grid.length;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  width = height ? grid[\cf8 \cb5 0\cf4 \cb5 ].length : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  row = \cf8 \cb5 0\cf4 \cb5 ; row < height; row++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < width; col++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  left = col === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row][col - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  up = row === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row - \cf8 \cb5 1\cf4 \cb5 ][col];\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  back = row && col ? grid[row - \cf8 \cb5 1\cf4 \cb5 ][col - \cf8 \cb5 1\cf4 \cb5 ] : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \cf6 \cb5 if\cf4 \cb5  (grid[row][col] == \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5                 grid[row][col] = \cf9 \cb5 Math\cf4 \cb5 .min(left, up, back) + grid[row][col] * \cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5             \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5                 grid[row][col] = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \};\cb1 \
\cb5             max = \cf9 Math\cf4 .max(max, grid[row][col])\cb1 \
\cb5 ;\cb1 \
\cb5         \};\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  max * max;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  items = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Tower of Hanoi (Recursion)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  hanoiTower = (height, srcP, destP, bufferP) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (height >= \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\
\cb5     \cf10 \cb5 // Move a tower of height-1 to the buffer peg, using the destination peg.\cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , srcP, bufferP, destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the remaining disk to the destination peg.\cf4 \cb1 \
\cb5     console.log(\cf7 \cb5 'Move disk from Tower '\cf4 \cb5 , srcP, \cf7 \cb5 ' to Tower '\cf4 \cb5 , destP);\cb1 \
\
\cb5     \cf10 \cb5 // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.        \cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , bufferP, destP, srcP);\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5 \}\cb1 \
\
\cb5 hanoiTower(\cf8 \cb5 3\cf4 \cb5 , \cf7 \cb5 "A"\cf4 \cb5 , \cf7 \cb5 "C"\cf4 \cb5 , \cf7 \cb5 "B"\cf4 \cb5 );\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  permute = (nums, memo = \cf8 0\cf4 ) => \{\cb1 \
\cb5     \cf6 if\cf4  (memo >= nums.length) \cf6 return\cf4  [[]];\cb1 \
\cb5     \cf6 const\cf4  result = [];\cb1 \
\cb5     \cf6 const\cf4  prevs = permute(nums, memo + \cf8 1\cf4 );  \cf10 // permutations of elements after n\cf4 \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  prev \cf6 of\cf4  prevs) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i <= prev.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  p = prev.slice(\cf8 0\cf4 );\cb1 \
\cb5             p.splice(i, \cf8 0\cf4 , nums[memo]);  \cf10 // successively insert element n\cf4 \cb1 \
\cb5             result.push(p); \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations 2 (Unique)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0
\cf6 const\cf4  permuteUnique = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  permU = \cf6 \cb5 function\cf4 \cb5 (nums) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (nums.length == \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [nums];\cb1 \
\cb5         \cf6 \cb5 let\cf4 \cb5  result = []\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < nums.length; i++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  temp = [...nums.slice(\cf8 \cb5 0\cf4 \cb5 , i), ...nums.slice(i+\cf8 \cb5 1\cf4 \cb5 )];\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  c \cf6 \cb5 of\cf4 \cb5  permU(temp)) \{\cb1 \
\cb5                 result.push([nums[i], ...c]); \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 \cb5 while\cf4 \cb5 (nums[i+\cf8 \cb5 1\cf4 \cb5 ]==nums[i])i++; \cf10 \cb5 // skip\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  permU(nums);\cb1 \
\cb5 \};\cb1 \
\cb5 nums = [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ]\cb1 \
\cb5 permuteUnique(nums) \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb5 //[ [ 1, 1, 2 ], [ 1, 2, 1 ], [ 2, 1, 1 ] ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Range Sum of BST
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf12 \cb3 Given the\'a0
\f4\fs26 \cf13 \cb14 root
\f3\fs28 \cf12 \cb3 \'a0node of a binary search tree, return the sum of values of all nodes with value between\'a0
\f4\fs26 \cf13 \cb14 L
\f3\fs28 \cf12 \cb3 \'a0and\'a0
\f4\fs26 \cf13 \cb14 R
\f3\fs28 \cf12 \cb3 \'a0(inclusive).\
The binary search tree is guaranteed to have unique values.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rangeSumBST = (root, \cf9 \cb5 L\cf4 \cb5 , \cf9 \cb5 R\cf4 \cb5 ) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf10 \cb5 // check if value is in the given range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  isInBetween = val => val >= \cf9 \cb5 L\cf4 \cb5  && val <= \cf9 \cb5 R\cf4 \cb5 ;\cb1 \
\cb5     \cf10 \cb5 // sum the value if it's in the range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  add = (val, sum) => isInBetween(val) ? sum += val : sum;\cb1 \
\cb5 \'a0\'a0\cf10 \cb5 // traverse through the nodes and sum the values in range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  preorder =(root, sum) => \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (!root) \cf6 \cb5 return\cf4 \cb5  sum;\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\cb1 \
\cb5     \} \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  preorder(root, \cf8 \cb5 0\cf4 \cb5 )\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shortest Path in Maze
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (x, y) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .x = x;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .y = y;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (pt, dist) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .pt = pt;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .dist = dist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  d = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: \cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: -\cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: -\cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \}\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  bfs(maze, src, dest) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 var\cf4 \cb5  minDist = -\cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (maze[src.x][src.y] != \cf8 \cb5 1\cf4 \cb5  || maze[dest.x][dest.y] != \cf8 \cb5 1\cf4 \cb5 )\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  h = maze.length;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  w = maze[\cf8 \cb5 0\cf4 \cb5 ].length;\cb1 \
\cb5   visited = [];\cb1 \
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < h; i++) \{\cb1 \
\cb5     visited.push([]);\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < w; j++) \{\cb1 \
\cb5       visited[i].push(\cf6 \cb5 false\cf4 \cb5 );\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  queue = [];\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  s = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (src, \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cb5   queue.push(s);\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (queue.length>\cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  curr = queue.pop();\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  pt = curr.pt;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (pt.x == dest.x && pt.y == dest.y)\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  curr.dist;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf8 \cb5 4\cf4 \cb5 ; i++) \{\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  row = pt.x + d[i].x;\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  col = pt.y + d[i].y;\cb1 \
\cb5       \cf6 \cb5 if\cf4 \cb5  (isValid(maze, visited, h, w, row, col)) \{\cb1 \
\cb5         visited[row][col] = \cf6 \cb5 true\cf4 \cb5 ;\cb1 \
\cb5         \cf6 \cb5 var\cf4 \cb5  adjCell = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (\cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (row, col), curr.dist + \cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5         queue.push(adjCell);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  isValid(maze, visited, width, height, row, col) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 return\cf4 \cb5  (row >= \cf8 \cb5 0\cf4 \cb5 ) && (row < width) && (col >= \cf8 \cb5 0\cf4 \cb5 ) && (col < height) && maze[row][col] == \cf8 \cb5 1\cf4 \cb5  && !visited[row][col];\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  maze = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ]\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  source = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dest = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 7\cf4 \cb5 , \cf8 \cb5 5\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dist = bfs(maze, source, dest);\cb1 \
\
\cf6 \cb5 if\cf4 \cb5  (dist != -\cf8 \cb5 1\cf4 \cb5 )\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `The shortest path from (\cf4 \cb5 $\{source.x\}\cf7 \cb5 , \cf4 \cb5 $\{source.y\}\cf7 \cb5 ) to (\cf4 \cb5 $\{dest.x\}\cf7 \cb5 , \cf4 \cb5 $\{dest.y\}\cf7 \cb5 ) has length \cf4 \cb5 $\{dist\}\cf7 \cb5 \\n`\cf4 \cb5 );\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 else\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `Shortest path from \cf4 \cb5 $\{(source.x, source.y)\}\cf7 \cb5  to \cf4 \cb5 $\{(dest.x, dest.y)\}\cf7 \cb5  does not exist`\cf4 \cb5 );\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Repeated Substring Pattern
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf12 \cb3 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  repeatedSubstringPattern = string => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5  (string.length === \cf8 \cb5 0\cf4 \cb5  || string.length === \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 false\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 1\cf4 \cb5 ; i <= string.length / \cf8 \cb5 2\cf4 \cb5 ; i++) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (string.length % i === \cf8 \cb5 0\cf4 \cb5  && string.slice(\cf8 \cb5 0\cf4 \cb5 , i).repeat(string.length / i) === string) \{\cb1 \
\cb5             \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 true\cf4 \cb5 ;\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 false\cf4 \cb5 ;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  merge = (arr1, arr2) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 let\cf4 \cb5  sorted = [];\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (arr1.length && arr2.length) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (arr1[\cf8 \cb5 0\cf4 \cb5 ] < arr2[\cf8 \cb5 0\cf4 \cb5 ]) sorted.push(arr1.shift());\cb1 \
\cb5     \cf6 \cb5 else\cf4 \cb5  sorted.push(arr2.shift());\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 \cb5 return\cf4 \cb5  sorted.concat(arr1.slice().concat(arr2.slice()));\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  mergeSort = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (arr.length <= \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  arr;\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  mid = \cf9 \cb5 Math\cf4 \cb5 .floor(arr.length / \cf8 \cb5 2\cf4 \cb5 ),\cb1 \
\cb5       left = mergeSort(arr.slice(\cf8 \cb5 0\cf4 \cb5 , mid)),\cb1 \
\cb5       right = mergeSort(arr.slice(mid));\cb1 \
\
\cb5   \cf6 \cb5 return\cf4 \cb5  merge(left, right);\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Quick Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  quickSort = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \'a0\'a0\cf6 \cb5 if\cf4 \cb5  (arr.length <=\cf8 \cb5 1\cf4 \cb5  || arr === \cf6 \cb5 null\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  arr;\cb1 \
\cb5 \'a0\'a0\cf6 \cb5 let\cf4 \cb5  pivot = arr[arr.length - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  leftArr = [];\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  rightArr = [];\cb1 \
\
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  el \cf6 \cb5 of\cf4 \cb5  arr.slice(\cf8 \cb5 0\cf4 \cb5 , arr.length -\cf8 \cb5 1\cf4 \cb5 )) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (el < pivot) \{\cb1 \
\cb5       leftArr.push(el);\cb1 \
\cb5     \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5       rightArr.push(el);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  [...quickSort(leftArr), pivot, ...quickSort(rightArr)]\cb1 \
\cb5 \}\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Verifying an Alien Dictionary
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isAlienSorted = (words, order) => \{\cb1 \
\cb5     \cf6 let\cf4  charPosition = \cf6 new\cf4  \cf9 Map\cf4 ()\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  position = \cf8 0\cf4 ; position < order.length; position++)\{\cb1 \
\cb5         \cf6 let\cf4  char = order[position]\cb1 \
\cb5         charPosition.\cf6 set\cf4 (char, position)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 1\cf4 ; i < words.length; i++)\{\cb1 \
\cb5         \cf6 let\cf4  prev = words[i-\cf8 1\cf4 ], curr = words[i]\cb1 \
\cb5         \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[\cf8 0\cf4 ]) > charPosition.\cf6 get\cf4 (curr[\cf8 0\cf4 ]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \cf6 else\cf4  \cf6 if\cf4 (prev[\cf8 0\cf4 ] === curr[\cf8 0\cf4 ])\{\cb1 \
\cb5             \cf6 let\cf4  pointer = \cf8 1\cf4 \cb1 \
\cb5             \cf6 while\cf4 (prev[pointer] === curr[pointer])pointer++\cb1 \
\cb5             \cf6 if\cf4 (curr[pointer] === \cf6 undefined\cf4 )\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[pointer]) > charPosition.\cf6 get\cf4 (curr[pointer]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 true\cf4 \cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Destination City
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  destCity = paths => \{\cb1 \
\cb5     \cf6 const\cf4  result = \cf6 new\cf4  \cf9 Set\cf4 (paths.map((path) => path[\cf8 0\cf4 ]));\cb1 \
\cb5     \cf6 return\cf4  paths.filter((path) => !result.has(path[\cf8 1\cf4 ])).pop()[\cf8 1\cf4 ]\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Parentheses
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isValid = str => \{\cb1 \
\cb5     \cf6 const\cf4  stack = []\cb1 \
\cb5     \cf6 const\cf4  keys = \{\cb1 \
\cb5         \cf7 '('\cf4 : \cf7 ')'\cf4 ,\cb1 \
\cb5         \cf7 '\{'\cf4 : \cf7 '\}'\cf4 ,\cb1 \
\cb5         \cf7 '['\cf4 : \cf7 ']'\cf4 ,\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  char \cf6 of\cf4  str) \{\cb1 \
\cb5         \cf6 if\cf4  (char \cf6 in\cf4  keys) \{\cb1 \
\cb5             stack.push(keys[char])\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             \cf6 if\cf4  (stack.length === \cf8 0\cf4  || stack.pop() !== char) \{\cb1 \
\cb5                 \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  stack.length === \cf8 0\cf4 \cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  bestBuy = prices[\cf8 0\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < prices.length; i++) \{\cb1 \
\cb5         bestBuy = \cf9 Math\cf4 .min(bestBuy, prices[i])\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit, prices[i] - bestBuy);\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock II
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < prices.length - \cf8 1\cf4 ; i++) \{\cb1 \
\cb5         \cf6 const\cf4  possibleProfit = prices[i + \cf8 1\cf4 ] - prices[i];\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit + possibleProfit, profit);\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Integer
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseInt = x => \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  max = \cf16 \strokec16 Math\cf4 \strokec4 .pow(\cf17 \strokec17 2\cf4 \strokec4 , \cf17 \strokec17 31\cf4 \strokec4 ) - \cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  min = \cf16 \strokec16 Math\cf4 \strokec4 .pow(-\cf17 \strokec17 2\cf4 \strokec4 , \cf17 \strokec17 31\cf4 \strokec4 )\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  sign = \cf16 \strokec16 Math\cf4 \strokec4 .sign(x)\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  num = (x * sign).toString().split(\cf18 \strokec18 ''\cf4 \strokec4 ).reverse().join(\cf18 \strokec18 ''\cf4 \strokec4 )\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  result = \cf16 \strokec16 Number\cf4 \strokec4 (num) * sign\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  result > min && result < max ? result : \cf17 \strokec17 0\cf4 \cb1 \strokec4 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Longest Common Prefix\
\pard\pardeftab720\sl420\partightenfactor0

\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  longestCommonPrefix = strs => \{\cb1 \
\cb15   \cf6 \strokec6 if\cf4 \strokec4  (!strs.length) \cf6 \strokec6 return\cf4 \strokec4  \cf18 \strokec18 ''\cf4 \strokec4 ;\cb1 \
\cb15   \cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < strs[\cf17 \strokec17 0\cf4 \strokec4 ].length; i++) \{\cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  str \cf6 \strokec6 of\cf4 \strokec4  strs) \{\cb1 \
\cb15       \cf6 \strokec6 if\cf4 \strokec4  (str[i] !== strs[\cf17 \strokec17 0\cf4 \strokec4 ][i]) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  str.slice(\cf17 \strokec17 0\cf4 \strokec4 , i);\cb1 \
\cb15       \}\cb1 \
\cb15     \}\cb1 \
\cb15   \}\cb1 \
\cb15   \cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  strs[\cf17 \strokec17 0\cf4 \strokec4 ];\cb1 \
\cb15 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Duplicate Numbers from Sorted Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  removeDuplicates = nums => \{\cb1 \
\cb15     \cf6 \strokec6 var\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15     nums.forEach(num => \{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (num !== nums[i]) \{\cb1 \
\cb15             nums[++i] = num;\cb1 \
\cb15         \}\cb1 \
\cb15     \});\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  nums.length && i + \cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Element from Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  removeElement = (nums, val) => \{\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < nums.length; i++) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (nums[i] === val) \{\cb1 \
\cb15       nums.splice(i, \cf17 \strokec17 1\cf4 \strokec4 );\cb1 \
\cb15       i--;\cb1 \
\cb15     \}\cb1 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  nums.length;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // strStr (Needle and Haystack)
\f3\b0 \cf19 \outl0\strokewidth0 \strokec19 \
\pard\pardeftab720\sa280\partightenfactor0
\cf19 Return the index of the first occurrence of needle in haystack, or\'a0
\f6\b -1
\f3\b0 \'a0if needle is not part of haystack.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  haystack = "hello", needle = "ll"\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf19 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  haystack = "aaaaa", needle = "bba"\

\f0\b Output:
\f1\b0  -1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  strStr = (haystack, needle) => \{\cb1 \
\cb15   \cf6 \strokec6 let\cf4 \strokec4  needleLength = needle.length\cb1 \
\cb15   \cf6 \strokec6 let\cf4 \strokec4  haystackLength = haystack.length\cb1 \
\
\cb15   \cf6 \strokec6 if\cf4 \strokec4 (needle === \cf18 \strokec18 ''\cf4 \strokec4  && haystack === \cf18 \strokec18 ''\cf4 \strokec4  )\{\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  \cf17 \strokec17 0\cf4 \cb1 \strokec4 \
\cb15   \}\cb1 \
\
\cb15   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i=\cf17 \strokec17 0\cf4 \strokec4 ; i < haystack.length; i++)\{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (haystack.substr(i, needleLength) === needle)\{\cb1 \
\cb15       \cf6 \strokec6 return\cf4 \strokec4  i\cb1 \
\cb15     \}\cb1 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  -\cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Search Insert Position
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\
You may assume no duplicates in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  [1,3,5,6], 5\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  searchInsert = (nums, target) => \{\cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < nums.length; i++)\{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (nums[i] >= target)\{\cb1 \
\cb15             \cf6 \strokec6 return\cf4 \strokec4  i;\cb1 \
\cb15         \}\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  nums.length;\cb1 \
\cb15 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \outl0\strokewidth0 // Length of Last Word
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  lengthOfLastWord = str => \{\cb1 \
\cb5     \cf6 const\cf4  arr = str.trim().split(\cf7 ' '\cf4 );\cb1 \
\cb5     \cf6 return\cf4  arr[arr.length - \cf8 1\cf4 ].length;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Plus One
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array of digits\'a0representing a non-negative integer, plus one to the integer.\
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\
You may assume the integer does not contain any leading zero, except the number 0 itself.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  [1,2,3]\

\f0\b Output:
\f1\b0  [1,2,4]\

\f0\b Explanation:
\f1\b0  The array represents the integer 123.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  plusOne = digits => \{\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = digits.length - \cf17 \strokec17 1\cf4 \strokec4 ; i >= \cf17 \strokec17 0\cf4 \strokec4 ; i --)\{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4 (digits[i] === \cf17 \strokec17 9\cf4 \strokec4 )\{\cb1 \
\cb15       digits[i] = \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb15       digits[i] ++;\cb1 \
\cb15       \cf6 \strokec6 return\cf4 \strokec4  digits;\cb1 \
\cb15     \}\cb1 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  [\cf17 \strokec17 1\cf4 \strokec4 , ...digits];\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sorted Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  merge = (nums1, m, nums2, n) => \{\cb1 \
\cb15     \cb1 \
\cb15    \cf6 \strokec6 let\cf4 \strokec4  len = nums1.length - \cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15    m--;\cb1 \
\cb15    n--;\cb1 \
\cb15     \cb1 \
\cb15    \cf6 \strokec6 while\cf4 \strokec4  (n >= \cf17 \strokec17 0\cf4 \strokec4 ) \{\cb1 \
\cb15        \cf6 \strokec6 if\cf4 \strokec4  (nums1[m] > nums2[n]) \{\cb1 \
\cb15            nums1[len] = nums1[m], m--\cb1 \
\cb15        \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb15            nums1[len] = nums2[n], n--\cb1 \
\cb15        \}\cb1 \
\cb15        len--\cb1 \
\cb15    \cb1 \
\cb15    \}\cb1 \
\cb15    \cf6 \strokec6 return\cf4 \strokec4  nums1\cb1 \
\cb15     \cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find the Town Judge
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 In a town, there are\'a0
\f4\fs26 \cf21 \cb20 \strokec21 N
\f3\fs28 \cf19 \cb3 \strokec19 \'a0people labelled from\'a0
\f4\fs26 \cf21 \cb20 \strokec21 1
\f3\fs28 \cf19 \cb3 \strokec19 \'a0to\'a0
\f4\fs26 \cf21 \cb20 \strokec21 N
\f3\fs28 \cf19 \cb3 \strokec19 .\'a0 There is a rumor that one of these people is secretly the town judge.\
If the\'a0town judge exists, then:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf19 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec19 The town judge trusts nobody.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec19 Everybody (except for the town judge) trusts the town judge.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec19 There is exactly one person that satisfies properties 1 and 2.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf19 \cb3 You are given\'a0
\f4\fs26 \cf21 \cb20 \strokec21 trust
\f3\fs28 \cf19 \cb3 \strokec19 , an array of pairs\'a0
\f4\fs26 \cf21 \cb20 \strokec21 trust[i] = [a, b]
\f3\fs28 \cf19 \cb3 \strokec19 \'a0representing that the person labelled\'a0
\f4\fs26 \cf21 \cb20 \strokec21 a
\f3\fs28 \cf19 \cb3 \strokec19 \'a0trusts the person labelled\'a0
\f4\fs26 \cf21 \cb20 \strokec21 b
\f3\fs28 \cf19 \cb3 \strokec19 .\
If the town judge exists and can be identified, return the label of the town judge.\'a0 Otherwise, return\'a0
\f4\fs26 \cf21 \cb20 \strokec21 -1
\f3\fs28 \cf19 \cb3 \strokec19 .\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  N = 2, trust = [[1,2]]\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  findJudge = (\cf16 \strokec16 N\cf4 \strokec4 , trust) => \{\cb1 \
\cb15   \cf6 \strokec6 var\cf4 \strokec4  graph = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Map\cf4 \strokec4  ()\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 1\cf4 \strokec4 ; i <= \cf16 \strokec16 N\cf4 \strokec4 ; i ++) \{\cb1 \
\cb15     graph.\cf6 \strokec6 set\cf4 \strokec4 (i, \cf17 \strokec17 1\cf4 \strokec4 )\cb1 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  [v, e] \cf6 \strokec6 of\cf4 \strokec4  trust) \{\cb1 \
\cb15     \cf22 \strokec22 // console.log(v, e)\cf4 \cb1 \strokec4 \
\cb15     graph.\cf6 \strokec6 set\cf4 \strokec4 (v, graph.\cf6 \strokec6 get\cf4 \strokec4 (v) - \cf17 \strokec17 1\cf4 \strokec4 ) \cf22 \strokec22 // the node which is not  trusted -1\cf4 \cb1 \strokec4 \
\cb15     graph.\cf6 \strokec6 set\cf4 \strokec4 (e, graph.\cf6 \strokec6 get\cf4 \strokec4 (e) + \cf17 \strokec17 1\cf4 \strokec4 ) \cf22 \strokec22 // the node which is  trusted + 1\cf4 \cb1 \strokec4 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  [key, value] \cf6 \strokec6 of\cf4 \strokec4  graph) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (value === \cf16 \strokec16 N\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  key\cb1 \
\cb15   \}\cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  -\cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Partition Equal Subset Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array containing\'a0
\f6\b only positive integers
\f3\b0 , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Note:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf19 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec19 Each of the array element will not exceed 100.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec19 The array size will not exceed 200.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf19 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf19 \cb20 Input: [1, 5, 11, 5]\
\
Output: true\
\
Explanation: The array can be partitioned as [1, 5, 5] and [11].\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  canPartition = nums => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4 (!nums) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 let\cf4 \strokec4  total = nums.reduce((a,b) => a + b, \cf17 \strokec17 0\cf4 \strokec4 )\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4 (total%\cf17 \strokec17 2\cf4 \strokec4  != \cf17 \strokec17 0\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 let\cf4 \strokec4  target = total /\cf17 \strokec17 2\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 let\cf4 \strokec4  arr = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Array\cf4 \strokec4 (target + \cf17 \strokec17 1\cf4 \strokec4 ).fill(\cf6 \strokec6 false\cf4 \strokec4 )\cb1 \
\cb15     arr[\cf17 \strokec17 0\cf4 \strokec4 ] = \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  el \cf6 \strokec6 of\cf4 \strokec4  nums) \{\cb1 \
\cb15         \cb1 \
\cb15         \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = target; i >=\cf17 \strokec17 0\cf4 \strokec4 ; i--) \{            \cb1 \
\cb15             \cf6 \strokec6 let\cf4 \strokec4  complement = i - el\cb1 \
\cb15             \cb1 \
\cb15             \cf6 \strokec6 if\cf4 \strokec4 (!arr[i] && arr[complement])\{\cb1 \
\cb15                 arr[i] = \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb15             \}\cb1 \
\cb15             \cf6 \strokec6 if\cf4 \strokec4 (arr[target] == \cf6 \strokec6 true\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb15         \}\cb1 \
\cb15     \}\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Balanced Binary Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isBalanced = root => \{\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  getHeight(root) !== -\cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 function\cf4 \strokec4  getHeight(root) \{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4 (!root) \{\cb1 \
\cb15             \cf6 \strokec6 return\cf4 \strokec4  \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15         \}\cb1 \
\cb15         \cf6 \strokec6 let\cf4 \strokec4  left = getHeight(root.left);\cb1 \
\cb15         \cf6 \strokec6 let\cf4 \strokec4  right = getHeight(root.right);\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4 (left == -\cf17 \strokec17 1\cf4 \strokec4  || right == -\cf17 \strokec17 1\cf4 \strokec4  || \cf16 \strokec16 Math\cf4 \strokec4 .abs(left - right) > \cf17 \strokec17 1\cf4 \strokec4 ) \{\cb1 \
\cb15             \cf6 \strokec6 return\cf4 \strokec4  -\cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15         \}\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  \cf17 \strokec17 1\cf4 \strokec4  + \cf16 \strokec16 Math\cf4 \strokec4 .max(left, right);\cb1 \
\cb15     \}\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Symmetric Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isSymmetric = root => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!root) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb15     \}\cb1 \
\
\cb15     \cf22 \strokec22 // Check if tree s & t are mirroring each other\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 function\cf4 \strokec4  isMirror(s, t) \{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (!s && !t) \{\cb1 \
\cb15             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ; \cf22 \strokec22 // Both nodes are null, ok\cf4 \cb1 \strokec4 \
\cb15         \}\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (!s || !t || s.val !== t.val) \{\cb1 \
\cb15             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ; \cf22 \strokec22 // Found a mismatch\cf4 \cb1 \strokec4 \
\cb15         \}\cb1 \
\cb15         \cf22 \strokec22 // Compare the left subtree of `s` with the right subtree of `t`\cf4 \cb1 \strokec4 \
\cb15         \cf22 \strokec22 // and the right subtree of `s` with the left subtree of `t`\cf4 \cb1 \strokec4 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  isMirror(s.left, t.right) && isMirror(s.right, t.left);\cb1 \
\cb15     \}\cb1 \
\
\cb15     \cf6 \strokec6 return\cf4 \strokec4  isMirror(root.left, root.right);\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Same Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isSameTree = (p, q) => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!p && !q) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!p || !q || p.val !== q.val) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Path Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Note:
\f3\b0 \'a0A leaf is a node with no children.\

\f6\b Example:
\f3\b0 \
Given the below binary tree and\'a0
\f4\fs26 \cf21 \cb20 \strokec21 sum = 22
\f3\fs28 \cf19 \cb3 \strokec19 ,\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf19 \cb20       
\f0\b 5
\f1\b0 \
     
\f0\b /
\f1\b0  \\\
    
\f0\b 4
\f1\b0    8\
   
\f0\b /
\f1\b0    / \\\
  
\f0\b 11
\f1\b0   13  4\
 /  
\f0\b \\
\f1\b0       \\\
7    
\f0\b 2
\f1\b0       1\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf19 \cb3 return true, as there exist a root-to-leaf path\'a0
\f4\fs26 \cf21 \cb20 \strokec21 5->4->11->2
\f3\fs28 \cf19 \cb3 \strokec19 \'a0which sum is 22.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  hasPathSum = (root, sum) => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!root) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!root.left && !root.right) \cf6 \strokec6 return\cf4 \strokec4  sum - root.val == \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);    \cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Kids With the Greatest Number of Candies
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  kidsWithCandies = (candies, extraCandies) => \{\cb1 \
\cb15 \'a0\'a0\cf6 \strokec6 const\cf4 \strokec4  max = \cf16 \strokec16 Math\cf4 \strokec4 .max(...candies)\cb1 \
\cb15 \'a0\'a0\cf6 \strokec6 const\cf4 \strokec4  result = candies.map((candy) => candy + extraCandies >= max)\cb1 \
\cb15 \'a0\'a0\cf6 \strokec6 return\cf4 \strokec4  result\cb1 \
\cb15 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse String
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseString = str => \{\cb1 \
\cb15   \cf6 \strokec6 if\cf4 \strokec4  (str.length < \cf17 \strokec17 2\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  str;\cb1 \
\cb15   \cf6 \strokec6 let\cf4 \strokec4  start = \cf17 \strokec17 0\cf4 \strokec4 , end = str.length - \cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15   \cf6 \strokec6 while\cf4 \strokec4  (end > start) \{\cb1 \
\cb15     [str[start], str[end]] = [str[end], str[start]]; \cf22 \strokec22 // es6 swap trick\cf4 \cb1 \strokec4 \
\cb15     end--;\cb1 \
\cb15     start++;\cb1 \
\cb15   \}\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Max Depth of Binary Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  maxDepth = root => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (root === \cf6 \strokec6 null\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf17 \strokec17 0\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  \cf16 \strokec16 Math\cf4 \strokec4 .max(maxDepth(root.left), maxDepth(root.right)) + \cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Single Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array of integers, every element appears\'a0
\f5\i twice
\f3\i0 \'a0except for one. Find that single one.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Note:
\f3\b0 \
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\

\f6\b Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  [2,2,1]\

\f0\b Output:
\f1\b0  1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  singleNumber = nums => \{\cb1 \
\cb15   \cf6 \strokec6 const\cf4 \strokec4  map = \{\};\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 of\cf4 \strokec4  nums) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (map[num] == \cf6 \strokec6 null\cf4 \strokec4 ) map[num] = \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15     map[num]++;\cb1 \
\cb15   \}\cb1 \
\
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 in\cf4 \strokec4  map) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (map[num] === \cf17 \strokec17 1\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf16 \strokec16 Number\cf4 \strokec4 (num);\cb1 \
\cb15   \}\cb1 \
\cb15 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // FizzBuzz
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  fizzBuzz = num => \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  res = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Array\cf4 \strokec4 (num);\cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 1\cf4 \strokec4 ; i <= num ; i++)\{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4 (i % \cf17 \strokec17 15\cf4 \strokec4  === \cf17 \strokec17 0\cf4 \strokec4 ) res[i-\cf17 \strokec17 1\cf4 \strokec4 ] = \cf18 \strokec18 'FizzBuzz'\cf4 \strokec4 ;\cb1 \
\cb15         \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4 (i % \cf17 \strokec17 3\cf4 \strokec4  === \cf17 \strokec17 0\cf4 \strokec4 ) res[i-\cf17 \strokec17 1\cf4 \strokec4 ] = \cf18 \strokec18 'Fizz'\cf4 \strokec4 ;\cb1 \
\cb15         \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4 (i % \cf17 \strokec17 5\cf4 \strokec4  === \cf17 \strokec17 0\cf4 \strokec4 ) res[i-\cf17 \strokec17 1\cf4 \strokec4 ] = \cf18 \strokec18 'Buzz'\cf4 \strokec4 ;\cb1 \
\cb15         \cf6 \strokec6 else\cf4 \strokec4  res[i-\cf17 \strokec17 1\cf4 \strokec4 ] = i.toString();\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  res;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseList = head => \{\cb1 \
\cb15     \cf6 \strokec6 let\cf4 \strokec4  prev = \cf6 \strokec6 null\cf4 \strokec4 ;\cb1 \
\cb15     \cf6 \strokec6 while\cf4 \strokec4 (head) \{\cb1 \
\cb15         \cf6 \strokec6 let\cf4 \strokec4  temp = head.next;\cb1 \
\cb15         head.next = prev;\cb1 \
\cb15         prev = head;\cb1 \
\cb15         head = temp;\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  prev;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Delete Node in Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  deleteNode = node => \{\cb1 \
\cb15     node.val = node.next.val;\cb1 \
\cb15     node.next = node.next.next;\cb1 \
\cb15 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Two Sorted Lists
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  mergeTwoLists = (l1, l2) => \{\cb1 \
\cb5     \cf6 let\cf4  list = \cf6 new\cf4  \cf9 ListNode\cf4 ()\cb1 \
\cb5     \cf6 let\cf4  head = list\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4  (l1 !== \cf6 null\cf4  && l2 !== \cf6 null\cf4 ) \{\cb1 \
\cb5 \'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf10 // Select the smallest value from either linked list,\cf4 \cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf10 // then increment that list forward.\cf4 \cb1 \
\cb5         \cf6 if\cf4  (l1.val < l2.val) \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l1.val)\cb1 \
\cb5             l1 = l1.next\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l2.val)\cb1 \
\cb5             l2 = l2.next\cb1 \
\cb5         \}\cb1 \
\cb5         \cb1 \
\cb5         list = list.next\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf10 // It's possible that one linked list is shorter than the other so we just\cf4 \cb1 \
\cb5 \'a0\'a0\cf10 // add on the remainder of the last linked list. It's already sorted :)\cf4 \cb1 \
\cb5     \cf6 if\cf4  (l1 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l1\cb1 \
\cb5     \cf6 if\cf4  (l2 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l2\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf10 // return .next because this first element in the linkedlist is empty\cf4 \cb1 \
\cb5     \cf6 return\cf4  head.next\cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Majority Element
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given an array of size\'a0
\f5\i n
\f3\i0 , find the majority element. The majority element is the element that appears\'a0
\f6\b more than
\f3\b0 \'a0
\f1\fs26 \cf21 \cb20 \strokec21 \uc0\u8970 
\f4  n/2 
\f1 \uc0\u8971 
\f3\fs28 \cf19 \cb3 \strokec19 \'a0times.\
You may assume that the array is non-empty and the majority element always exist in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  [3,2,3]\

\f0\b Output:
\f1\b0  3\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  majorityElement = nums => \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  hash = \{\}\cb1 \
\cb15     \cf6 \strokec6 let\cf4 \strokec4  max = \cf17 \strokec17 0\cf4 \strokec4 , val\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < nums.length; i++)\{\cb1 \
\cb15         hash[nums[i]] ? hash[nums[i]]++ : hash[nums[i]] = \cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (hash[nums[i]] > max)\{\cb1 \
\cb15             max = hash[nums[i]]\cb1 \
\cb15             val = nums[i]\cb1 \
\cb15         \}\cb1 \
\cb15     \}\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  val\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Move Zeroes
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf19 \cb3 \outl0\strokewidth0 \strokec19 Given an array\'a0
\f4\fs26 \cf21 \cb20 \strokec21 nums
\f3\fs28 \cf19 \cb3 \strokec19 , write a function to move all\'a0
\f4\fs26 \cf21 \cb20 \strokec21 0
\f3\fs28 \cf19 \cb3 \strokec19 's to the end of it while maintaining the relative order of the non-zero elements.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf19 \cb20 Input:
\f1\b0  [0,1,0,3,12]\

\f0\b Output:
\f1\b0  [1,3,12,0,0]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  moveZeroes = nums => \{\cb1 \
\cb15   \cf6 \strokec6 var\cf4 \strokec4  idx = \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 var\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < nums.length; i++) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (nums[i] !== \cf17 \strokec17 0\cf4 \strokec4 ) \{\cb1 \
\cb15       nums[idx] = nums[i];\cb1 \
\cb15       nums[i] = idx === i ? nums[i] : \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15       idx++;\cb1 \
\cb15     \}\cb1 \
\cb15   \}\cb1 \
\cb15 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Convert Sorted Array to BST\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf19 \outl0\strokewidth0 \strokec19 Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of\'a0
\f5\i every
\f3\i0 \'a0node never differ by more than 1.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf19 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf19 \cb20 Given the sorted array: [-10,-3,0,5,9],\
\
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\
\
      0\
     / \\\
   -3   9\
   /   /\
 -10  5\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  sortedArrayToBST = nums => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (!nums.length) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 null\cf4 \strokec4 ;\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  mid = \cf16 \strokec16 Math\cf4 \strokec4 .floor(nums.length / \cf17 \strokec17 2\cf4 \strokec4 );\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  root = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 TreeNode\cf4 \strokec4 (nums[mid]);\cb1 \
\cb15     \cb1 \
\cb15     \cf22 \strokec22 // subtrees are BSTs as well\cf4 \cb1 \strokec4 \
\cb15     root.left = sortedArrayToBST(nums.slice(\cf17 \strokec17 0\cf4 \strokec4 , mid));\cb1 \
\cb15     root.right = sortedArrayToBST(nums.slice(mid + \cf17 \strokec17 1\cf4 \strokec4 ));\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  root;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Anagram 2
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 var\cf4 \strokec4  isAnagram = \cf6 \strokec6 function\cf4 \strokec4 (s, t) \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (s.length !== t.length) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb15     \}\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  map = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Map\cf4 \strokec4 ();\cb1 \
\cb15     \cb1 \
\cb15     s.split(\cf18 \strokec18 ''\cf4 \strokec4 ).map((c, i) => \{\cb1 \
\cb15         \cf22 \strokec22 // record character occurrences in s\cf4 \cb1 \strokec4 \
\cb15         map.\cf6 \strokec6 set\cf4 \strokec4 (c, map.has(c) ? map.\cf6 \strokec6 get\cf4 \strokec4 (c) + \cf17 \strokec17 1\cf4 \strokec4  : \cf17 \strokec17 1\cf4 \strokec4 );\cb1 \
\cb15         \cf22 \strokec22 // at the same time subtract the character occurrences from t\cf4 \cb1 \strokec4 \
\cb15         map.\cf6 \strokec6 set\cf4 \strokec4 (t[i], map.has(t[i]) ? map.\cf6 \strokec6 get\cf4 \strokec4 (t[i]) - \cf17 \strokec17 1\cf4 \strokec4  : -\cf17 \strokec17 1\cf4 \strokec4 );\cb1 \
\cb15     \});\cb1 \
\cb15     \cb1 \
\cb15     \cf22 \strokec22 // for an anagram, final count should be 0\cf4 \cb1 \strokec4 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  \cf16 \strokec16 Array\cf4 \strokec4 .\cf6 \strokec6 from\cf4 \strokec4 (map.values()).reduce((acc, cur) => acc && cur === \cf17 \strokec17 0\cf4 \strokec4 , \cf6 \strokec6 true\cf4 \strokec4 );\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \outl0\strokewidth0 // Contains Duplicate
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  containsDuplicate = nums => \{\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  nums.length !== \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Set\cf4 \strokec4 (nums).size\cb1 \
\cb15 \};\cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Roman to Integer
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  romanToInt = str => \{\cb1 \
\cb15   \cf6 \strokec6 if\cf4 \strokec4  (!str || str.length === \cf17 \strokec17 0\cf4 \strokec4 ) \{\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  \cf17 \strokec17 0\cf4 \strokec4 ;\cb1 \
\cb15   \}\cb1 \
\
\cb15   \cf6 \strokec6 const\cf4 \strokec4  map = \cf6 \strokec6 new\cf4 \strokec4  \cf16 \strokec16 Map\cf4 \strokec4 ([[\cf18 \strokec18 'I'\cf4 \strokec4 , \cf17 \strokec17 1\cf4 \strokec4 ], [\cf18 \strokec18 'V'\cf4 \strokec4 , \cf17 \strokec17 5\cf4 \strokec4 ], [\cf18 \strokec18 'X'\cf4 \strokec4 , \cf17 \strokec17 10\cf4 \strokec4 ], [\cf18 \strokec18 'L'\cf4 \strokec4 , \cf17 \strokec17 50\cf4 \strokec4 ], [\cf18 \strokec18 'C'\cf4 \strokec4 , \cf17 \strokec17 100\cf4 \strokec4 ], [\cf18 \strokec18 'D'\cf4 \strokec4 , \cf17 \strokec17 500\cf4 \strokec4 ], [\cf18 \strokec18 'M'\cf4 \strokec4 , \cf17 \strokec17 1000\cf4 \strokec4 ]]);\cb1 \
\
\cb15   \cf6 \strokec6 let\cf4 \strokec4  i = str.length - \cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15   \cf6 \strokec6 let\cf4 \strokec4  result = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i]);\cb1 \
\
\cb15   \cf6 \strokec6 while\cf4 \strokec4  (i > \cf17 \strokec17 0\cf4 \strokec4 ) \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  curr = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i]);\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  prev = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i - \cf17 \strokec17 1\cf4 \strokec4 ]);\cb1 \
\
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (prev >= curr) \{\cb1 \
\cb15       result += prev;\cb1 \
\cb15     \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb15       result -= prev;\cb1 \
\cb15     \}\cb1 \
\
\cb15     i--;\cb1 \
\cb15   \}\cb1 \
\
\cb15   \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Excel Sheet Column Number
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  titleToNumber = (str) => \{\cb1 \
\cb15   \cf6 \strokec6 const\cf4 \strokec4  letterToNumber = char => char.charCodeAt(\cf17 \strokec17 0\cf4 \strokec4 ) - \cf17 \strokec17 64\cf4 \strokec4 ;\cb1 \
\cb15   \cb1 \
\cb15   \cf6 \strokec6 return\cf4 \strokec4  [...str]\cb1 \
\cb15     .reverse()\cb1 \
\cb15     .map((char, i) => letterToNumber(char) * \cf16 \strokec16 Math\cf4 \strokec4 .pow(\cf17 \strokec17 26\cf4 \strokec4 , i))\cb1 \
\cb15     .reduce((prev, current) => prev + current, \cf17 \strokec17 0\cf4 \strokec4 );\cb1 \
\cb15 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // First Unique Character
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  firstUniqChar = str => \{\cb1 \
\cb15    \cf6 \strokec6 for\cf4 \strokec4 (i = \cf17 \strokec17 0\cf4 \strokec4 ; i < str.length; i++)\{\cb1 \
\cb15        \cf6 \strokec6 if\cf4 \strokec4  (str.indexOf(str[i])=== str.lastIndexOf(str[i]))\{\cb1 \
\cb15           \cf6 \strokec6 return\cf4 \strokec4  i;\cb1 \
\cb15       \} \cb1 \
\cb15    \}\cb1 \
\cb15    \cf6 \strokec6 return\cf4 \strokec4  -\cf17 \strokec17 1\cf4 \strokec4 ;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Pascal\'92s Triangle
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  generate = numRows => \{\cb1 \
\cb15     \cf6 \strokec6 if\cf4 \strokec4  (numRows === \cf17 \strokec17 0\cf4 \strokec4 ) \{\cb1 \
\cb15         \cf6 \strokec6 return\cf4 \strokec4  [];\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  result = [];\cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < numRows; i++) \{\cb1 \
\cb15         \cf6 \strokec6 let\cf4 \strokec4  currRow = [];\cb1 \
\cb15         \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  j = \cf17 \strokec17 0\cf4 \strokec4 ; j <= i; j++) \{\cb1 \
\cb15             \cf6 \strokec6 if\cf4 \strokec4  (j === \cf17 \strokec17 0\cf4 \strokec4  || j === i)\{\cb1 \
\cb15                 currRow.push(\cf17 \strokec17 1\cf4 \strokec4 );\cb1 \
\cb15             \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb15                 currRow.push(result[i - \cf17 \strokec17 1\cf4 \strokec4 ][j - \cf17 \strokec17 1\cf4 \strokec4 ] + result[i - \cf17 \strokec17 1\cf4 \strokec4 ][j]);\cb1 \
\cb15             \}\cb1 \
\cb15         \}\cb1 \
\cb15         result.push(currRow);\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Missing Number
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  missingNumber = nums => \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  n = nums.length;\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  expectedSum = (n * (n + \cf17 \strokec17 1\cf4 \strokec4 )) / \cf17 \strokec17 2\cf4 \strokec4 ;\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  sum = nums.reduce((total, num) => total += num, \cf17 \strokec17 0\cf4 \strokec4 );\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  expectedSum - sum;\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Intersection of Two Arrays
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb15 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  intersect = (nums1, nums2) => \{\cb1 \
\cb15     \cf6 \strokec6 const\cf4 \strokec4  hash = \{\}, ar = []\cb1 \
\cb15     \cb1 \
\cb15     nums2.forEach(num => \{\cb1 \
\cb15         hash[num] ? hash[num]++ : hash[num] = \cf17 \strokec17 1\cf4 \cb1 \strokec4 \
\cb15     \})\cb1 \
\cb15     \cb1 \
\cb15     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf17 \strokec17 0\cf4 \strokec4 ; i < nums1.length; i++)\{\cb1 \
\cb15         \cf6 \strokec6 if\cf4 \strokec4  (hash[nums1[i]] > \cf17 \strokec17 0\cf4 \strokec4 )\{\cb1 \
\cb15             ar.push(nums1[i])\cb1 \
\cb15             hash[nums1[i]]--\cb1 \
\cb15         \}\cb1 \
\cb15     \}\cb1 \
\cb15     \cf6 \strokec6 return\cf4 \strokec4  ar\cb1 \
\cb15 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\cb1 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
}