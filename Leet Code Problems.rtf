{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue255;
\red255\green255\blue254;\red0\green0\blue0;\red14\green110\blue109;\red19\green120\blue72;\red154\green154\blue154;
\red191\green28\blue37;\red144\green1\blue18;\red255\green255\blue254;\red154\green154\blue154;\red144\green1\blue18;
\red19\green120\blue72;\red14\green110\blue109;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c100000;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c66667\c66667\c66667;
\cssrgb\c80392\c19216\c19216;\cssrgb\c63922\c8235\c8235;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;\cssrgb\c63922\c8235\c8235;
\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;}
\margl1440\margr1440\vieww14020\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Two Sum
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
let\cf6  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf4 let\cf6  numberIndex = \cf4 new\cf6  \cf7 Map\cf6 ();\cb1 \
\cb5     \cf4 let\cf6  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf4 let\cf6  complement = target - num;\cb1 \
\
\cb5       \cf4 if\cf6  (numberIndex.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf6 ] = numberIndex.\cf4 get\cf6 (complement);\cb1 \
\cb5         result[\cf8 1\cf6 ] = i;\cb1 \
\
\cb5         \cf4 return\cf6  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       numberIndex.\cf4 set\cf6 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf4 return\cf6  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf6 , \cf8 3\cf6 , \cf8 8\cf6 , \cf8 7\cf6 , \cf8 4\cf6 ], \cf8 9\cf6 ) \cf9 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
let\cf6  solution = \cf4 function\cf6 (isBadVersion) \{\cb1 \
\cb5     \cf4 return\cf6  \cf4 function\cf6 (n) \{\cb1 \
\cb5         \cf4 let\cf6  left = \cf8 1\cf6 ;\cb1 \
\cb5         \cf4 let\cf6  right = n;\cb1 \
\cb5         \cb1 \
\cb5         \cf4 while\cf6  (left < right) \{\cb1 \
\cb5             \cf4 let\cf6  mid = left + \cf7 Math\cf6 .floor((right - left) / \cf8 2\cf6 );\cb1 \
\cb5             \cf4 if\cf6  (!isBadVersion(mid)) \{\cb1 \
\cb5                 left = mid + \cf8 1\cf6 ;\cb1 \
\cb5             \} \cf4 else\cf6  \{\cb1 \
\cb5                 right = mid;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\
\cb5         \cf4 return\cf6  left;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Sqrt(x) (binary search)
\f2\b0\fs28 \cf6 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  mySqrt = num => \{\cf10 \'a0\cf6 \cb1 \
\cb5   \cf4 if\cf6  (num <= \cf8 1\cf6 ) \{\cb1 \
\cb5     \cf4 return\cf6  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 let\cf6  left = \cf8 1\cf6 ;\cb1 \
\cb5   \cf4 let\cf6  right = num;\cb1 \
\
\cb5   \cf4 while\cf6  (left < right) \{\cb1 \
\cb5     \cf4 let\cf6  mid = left + \cf7 Math\cf6 .floor((right - left) / \cf8 2\cf6 );\cb1 \
\
\cb5    \'a0\cf4 if\cf6  (mid * mid === num) \cf4 return\cf6  mid;\cb1 \
\cb5     \cf4 if\cf6  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf4 if\cf6  (mid * mid < num) left = mid + \cf8 1\cf6 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 return\cf6  left - \cf8 1\cf6 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f2\b0\fs28 \cf6 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  rob = nums => \{\cb1 \
\cb5     \cf4 if\cf6  (nums === \cf4 null\cf6  || nums.length === \cf8 0\cf6 ) \{ \cf9 // if there are no houses, the total is zero\cf6 \cb1 \
\cb5         \cf4 return\cf6  \cf8 0\cf6 ;\cb1 \
\cb5     \} \cf4 else\cf6  \cf4 if\cf6  (nums.length == \cf8 1\cf6 ) \{\cb1 \
\cb5         \cf4 return\cf6  nums[\cf8 0\cf6 ]; \cf9 // if there is only one house, return its value\cf6 \cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf4 let\cf6  runningTotal = [];\cb1 \
\cb5      \cf9 /* the first index will be the same value as the first house since there are no decisions to make at this point */\cf6 \cb1 \
\cb5     runningTotal[\cf8 0\cf6 ] = nums[\cf8 0\cf6 ],\cb1 \
\cb5     \cf9 /* the second index will be the greater value of the first house or the second house */\cf6 \cb1 \
\cb5     runningTotal[\cf8 1\cf6 ] = \cf7 Math\cf6 .max(nums[\cf8 0\cf6 ], nums[\cf8 1\cf6 ]);\cb1 \
\
\cb5     \cf9 /* start at index 2 since we already have already made our 0th and 1st decisions (which correspond to our first and second houses) */\cf6 \cb1 \
\cb5     \cf4 for\cf6  (\cf4 let\cf6  i = \cf8 2\cf6 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf9 /* for each index, we choose the greater of (the current house's value plus the total from two houses ago) or (the total through the last house)  */\cf6 \cb1 \
\cb5         runningTotal[i] = \cf7 Math\cf6 .max(nums[i] + runningTotal[i - \cf8 2\cf6 ], runningTotal[i - \cf8 1\cf6 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf9 // return the last value in the array. this will be the optimal solution\cf6 \cb1 \
\cb5     \cf4 return\cf6  runningTotal[runningTotal.length - \cf8 1\cf6 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Steps
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  numberOfSteps = num => \{\cb1 \
\cb5     \cf4 let\cf6  count = \cf8 0\cf6 \cb1 \
\
\cb5     \cf4 while\cf6  (num > \cf8 0\cf6 ) \{\cb1 \
\cb5         \cf4 if\cf6  (num % \cf8 2\cf6  === \cf8 1\cf6 ) \{\cb1 \
\cb5             num = num - \cf8 1\cf6 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf4 else\cf6  \{\cb1 \
\cb5         num = num / \cf8 2\cf6 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf4 return\cf6  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Islands
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  numIslands = grid => \{\cb1 \
\cb5   \cf4 const\cf6  height = grid.length;\cb1 \
\cb5   \cf4 const\cf6  width = height && grid[\cf8 0\cf6 ].length;\cb1 \
\cb5   \cf4 let\cf6  count = \cf8 0\cf6 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 for\cf6  (\cf4 let\cf6  row = \cf8 0\cf6 ; row < height; row++) \{\cb1 \
\cb5     \cf4 for\cf6  (\cf4 let\cf6  col = \cf8 0\cf6 ; col < width; col++) \{\cb1 \
\cb5       \cf4 if\cf6  (grid[row][col] === \cf11 '0'\cf6 ) \cf4 continue\cf6 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf4 return\cf6  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 function\cf6  dfs(row, col) \{\cb1 \
\cb5     \cf4 if\cf6  (row < \cf8 0\cf6  || col < \cf8 0\cf6  || row === height || col === width || grid[row][col] === \cf11 '0'\cf6 ) \cf4 return\cf6 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf11 '0'\cf6 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf6 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf6 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf6 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf6 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Largest Number in Array
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  largestNumber = nums => \{\cb1 \
\cb12   \cf4 \strokec4 const\cf6 \strokec6  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb12     \cf13 \strokec13 // -1 a goes before b\cf6 \cb1 \strokec6 \
\cb12     \cf13 \strokec13 // 0  no change\cf6 \cb1 \strokec6 \
\cb12     \cf13 \strokec13 // 1  b goes before a\cf6 \cb1 \strokec6 \
\cb12     \cf4 \strokec4 const\cf6 \strokec6  compareFunc = (a, b) => \cf14 \strokec14 `\cf6 \strokec6 $\{b\}$\{a\}\cf14 \strokec14 `\cf6 \strokec6  - \cf14 \strokec14 `\cf6 \strokec6 $\{a\}$\{b\}\cf14 \strokec14 `\cf6 \cb1 \strokec6 \
\
\cb12     finalNums.sort(compareFunc);\cb1 \
\cb12     \cb1 \
\cb12     \cf4 \strokec4 if\cf6 \strokec6 (finalNums[\cf15 \strokec15 0\cf6 \strokec6 ] === \cf14 \strokec14 '0'\cf6 \strokec6 ) \cf4 \strokec4 return\cf6 \strokec6  \cf14 \strokec14 '0'\cf6 \strokec6 ;\cb1 \
\cb12     \cb1 \
\cb12     \cf4 \strokec4 return\cf6 \strokec6  finalNums.join(\cf14 \strokec14 ''\cf6 \strokec6 );\cb1 \
\cb12 \};\cb1 \
\
\
\cf16 \cb12 \strokec16 Input\cf6 \strokec6 : [\cf15 \strokec15 3\cf6 \strokec6 ,\cf15 \strokec15 30\cf6 \strokec6 ,\cf15 \strokec15 34\cf6 \strokec6 ,\cf15 \strokec15 5\cf6 \strokec6 ,\cf15 \strokec15 9\cf6 \strokec6 ]\cb1 \
\cf16 \cb12 \strokec16 Output\cf6 \strokec6 : \cf14 \strokec14 "9534330"\cf6 \cb1 \strokec6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Get All Permutations
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  getPermutations = arr => \{\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  output = [];\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  swap = (arrToSwap, indexA, indexB) => \{\cb1 \
\cb12     \cf4 \strokec4 const\cf6 \strokec6  temp = arrToSwap[indexA];\cb1 \
\cb12     arrToSwap[indexA] = arrToSwap[indexB];\cb1 \
\cb12     arrToSwap[indexB] = temp;\cb1 \
\cb12   \};\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  generate = (n, heapArr) => \{\cb1 \
\cb12     \cf4 \strokec4 if\cf6 \strokec6  (n === \cf15 \strokec15 1\cf6 \strokec6 ) \{\cb1 \
\cb12       output.push(heapArr.slice());\cb1 \
\cb12       \cf4 \strokec4 return\cf6 \strokec6 ;\cb1 \
\cb12     \}\cb1 \
\
\cb12     generate(n - \cf15 \strokec15 1\cf6 \strokec6 , heapArr);\cb1 \
\
\cb12     \cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  i = \cf15 \strokec15 0\cf6 \strokec6 ; i < n - \cf15 \strokec15 1\cf6 \strokec6 ; i++) \{\cb1 \
\cb12       \cf4 \strokec4 if\cf6 \strokec6  (n % \cf15 \strokec15 2\cf6 \strokec6  === \cf15 \strokec15 0\cf6 \strokec6 ) \{\cb1 \
\cb12         swap(heapArr, i, n - \cf15 \strokec15 1\cf6 \strokec6 );\cb1 \
\cb12       \} \cf4 \strokec4 else\cf6 \strokec6  \{\cb1 \
\cb12         swap(heapArr, \cf15 \strokec15 0\cf6 \strokec6 , n - \cf15 \strokec15 1\cf6 \strokec6 );\cb1 \
\cb12       \}\cb1 \
\
\cb12       generate(n - \cf15 \strokec15 1\cf6 \strokec6 , heapArr);\cb1 \
\cb12     \}\cb1 \
\cb12   \};\cb1 \
\
\cb12   generate(arr.length, arr.slice());\cb1 \
\
\cb12   \cf4 \strokec4 return\cf6 \strokec6  output;\cb1 \
\cb12 \};\cb1 \
\
\cb12 getPermutations([\cf15 \strokec15 1\cf6 \strokec6 , \cf15 \strokec15 2\cf6 \strokec6 , \cf15 \strokec15 3\cf6 \strokec6 ])\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Next Problem
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 const\cf6  functionName = arr => \{\cb1 \
\
\}\
\
}