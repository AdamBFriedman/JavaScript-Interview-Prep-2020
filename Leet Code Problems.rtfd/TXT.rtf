{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
\f6\fnil\fcharset0 HelveticaNeue-Bold;\f7\fnil\fcharset0 Menlo-Italic;\f8\fnil\fcharset0 HelveticaNeue-BoldItalic;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue254;\red0\green0\blue255;\red144\green1\blue18;\red19\green120\blue72;\red14\green110\blue109;
\red255\green255\blue254;\red19\green120\blue72;\red154\green154\blue154;\red14\green110\blue109;\red29\green38\blue42;
\red67\green91\blue103;\red245\green247\blue249;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
\red144\green1\blue18;\red78\green106\blue120;\red154\green154\blue154;\red78\green78\blue78;\red107\green0\blue1;
}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;
\cssrgb\c100000\c100000\c99608;\cssrgb\c3529\c53333\c35294;\cssrgb\c66667\c66667\c66667;\cssrgb\c0\c50196\c50196;\cssrgb\c14902\c19608\c21961;
\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
\cssrgb\c63922\c8235\c8235;\cssrgb\c37647\c49020\c54510;\cssrgb\c66667\c66667\c66667;\cssrgb\c38039\c38039\c38039;\cssrgb\c50196\c0\c0;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}}
\margl1440\margr1440\vieww16760\viewh17140\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Anagram
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  anagram = ((str1, str2) => \{\cb1 \
\cb5   \cf6 let\cf4  sorted1 = str1.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\cb5   \cf6 let\cf4  sorted2 = str2.split(\cf7 \cb5 ''\cf4 \cb5 ).sort().join(\cf7 \cb5 ''\cf4 \cb5 ).toLowerCase();\cb1 \
\
\cb5   \cf6 return\cf4  (sorted1 === sorted2)\cb1 \
\cb5 \})\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sum All #\'92s In Range
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  sumAll = arr => \{\cb1 \
\cb5 \'a0\'a0\cf6 let\cf4  sum = \cf8 0\cf4 ;\cb1 \
\cb5 \'a0\'a0\cf6 for\cf4  (\cf6 let\cf4  i = \cf9 Math\cf4 .min( ...arr ); i <= \cf9 Math\cf4 .max( ...arr ); i++) \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb5 \'a0\'a0\}\cb1 \
\cb5 \'a0\'a0\cf6 return\cf4  sum;\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \
// Fibonacci O(2^n) or O(n) with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\cf6 \cb5 const\cf4  fibonacci = (num, memo = \{\}) => \{\cb1 \
\cb5     \cf6 if\cf4  (num <= \cf8 1\cf4 ) \{\cb1 \
\cb5         \cf6 return\cf4  \cf8 1\cf4 \cb1 \
\cb5     \} \cf6 else\cf4  \{\cb1 \
\cb5       memo[num] = fibonacci(num - \cf8 1\cf4 , memo) + fibonacci(num - \cf8 2\cf4 , memo)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  memo[num]\cb1 \
\cb5 \}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Factorial with memoization
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  factorial = (num, memo = \{\}) => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (num <= \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10     \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10       memo[num] = factorial(num - \cf11 \strokec11 1\cf4 \strokec4 , memo) * num\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  memo[num]\cb1 \
\cb10 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \outl0\strokewidth0 \
\
// Two Sum
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
const\cf4  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf6 let\cf4  idx = \cf6 new\cf4  \cf9 Map\cf4 ();\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf6 let\cf4  complement = target - num;\cb1 \
\
\cb5       \cf6 if\cf4  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf4 ] = idx.\cf6 get\cf4 (complement);\cb1 \
\cb5         result[\cf8 1\cf4 ] = i;\cb1 \
\
\cb5         \cf6 return\cf4  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf6 set\cf4 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf4 , \cf8 3\cf4 , \cf8 8\cf4 , \cf8 7\cf4 , \cf8 4\cf4 ], \cf8 9\cf4 ) \cf12 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Three Sum
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  threeSum = nums => \{\cb1 \
\cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cf6 let\cf4  result = [];\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf6 let\cf4  t = -nums[i];\cb1 \
\cb5         \cf6 let\cf4  left = i+\cf8 1\cf4 , right = nums.length-\cf8 1\cf4 ;\cb1 \
\cb5         \cf6 while\cf4 (left < right) \{\cb1 \
\cb5             \cf6 if\cf4  (nums[left] + nums[right] == t) \{\cb1 \
\cb5                 result.push([nums[i], nums[left], nums[right]]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[left+\cf8 1\cf4 ] == nums[left++]);\cb1 \
\cb5                 \cf6 while\cf4 (nums[right-\cf8 1\cf4 ] == nums[right--]);\cb1 \
\cb5             \} \cf6 else\cf4  \cf6 if\cf4  (nums[left]+nums[right] < t) left++;\cb1 \
\cb5             \cf6 else\cf4  right--;\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 while\cf4 (nums[i+\cf8 1\cf4 ]==nums[i]) i++\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5     \cb1 \
\cb5 \};\cf12 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f2\b0 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf6 \cb5 \expnd0\expndtw0\kerning0
var\cf4  solution = \cf6 function\cf4 (isBadVersion) \{\cb1 \
\
\cb5     \cf6 return\cf4  \cf6 function\cf4 (n) \{\cb1 \
\cb5         \cf6 let\cf4  left = \cf8 1\cf4 ;\cb1 \
\cb5         \cf6 let\cf4  right = n;\cb1 \
\cb5         \cf6 while\cf4 (left <= right)\{\cb1 \
\cb5             \cf6 let\cf4  mid = left + \cf9 Math\cf4 .floor((right - left) / \cf8 2\cf4 );\cb1 \
\cb5             \cf6 if\cf4 (isBadVersion(mid))\{\cb1 \
\cb5                 \cf6 if\cf4  ((mid-\cf8 1\cf4  > \cf8 0\cf4  && !isBadVersion(mid-\cf8 1\cf4 )) || (mid === \cf8 1\cf4 ))\{\cb1 \
\cb5                     \cf6 return\cf4  mid;\cb1 \
\cb5                 \}\cf6 else\cf4 \{\cb1 \
\cb5                     right = mid - \cf8 1\cf4 ;\cb1 \
\cb5                 \}\cb1 \
\cb5             \}\cf6 else\cf4 \{\cb1 \
\cb5                 left = mid + \cf8 1\cf4 ;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 return\cf4  -\cf8 1\cf4 ;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Sqrt(x) (binary search)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb1 \outl0\strokewidth0 \
\cf6 \cb10 \strokec6 const\cf4 \strokec4  mySqrt = num => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  left = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  right = num;\cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4  (left <= right) \{\cb1 \
\cb10         \cf6 \strokec6 const\cf4 \strokec4  m = \cf13 \strokec13 Math\cf4 \strokec4 .floor(left + (right - left) / \cf11 \strokec11 2\cf4 \strokec4 );\cb1 \
\cb10         \cf6 \strokec6 const\cf4 \strokec4  m2 = m * m;\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (m2 === num) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  m;\cb1 \
\cb10         \} \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4  (num < m2) \{\cb1 \
\cb10             right = m - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10         \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10             left = m + \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  right;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\cb5 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rob = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5  (nums === \cf6 \cb5 null\cf4 \cb5  || nums.length === \cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \} \cf6 \cb5 else\cf4 \cb5  \cf6 \cb5 if\cf4 \cb5  (nums.length == \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 let\cf4 \cb5  runningTotal = [];\cb1 \
\cb5     runningTotal[\cf8 \cb5 0\cf4 \cb5 ] = nums[\cf8 \cb5 0\cf4 \cb5 ],\cb1 \
\cb5     runningTotal[\cf8 \cb5 1\cf4 \cb5 ] = \cf9 \cb5 Math\cf4 \cb5 .max(nums[\cf8 \cb5 0\cf4 \cb5 ], nums[\cf8 \cb5 1\cf4 \cb5 ]);\cb1 \
\
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 2\cf4 \cb5 ; i < nums.length; i++) \{\cb1 \
\
\cb5        runningTotal[i] = \cf9 \cb5 Math\cf4 \cb5 .max(nums[i] + runningTotal[i - \cf8 \cb5 2\cf4 \cb5 ], runningTotal[i - \cf8 \cb5 1\cf4 \cb5 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 return\cf4 \cb5  runningTotal[runningTotal.length - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Steps to Reach Zero
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  numberOfSteps = num => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  count = \cf8 \cb5 0\cf4 \cb1 \
\
\cb5     \cf6 \cb5 while\cf4 \cb5  (num > \cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (num % \cf8 \cb5 2\cf4 \cb5  === \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5             num = num - \cf8 \cb5 1\cf4 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5         num = num / \cf8 \cb5 2\cf4 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf6 \cb5 return\cf4 \cb5  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of Islands (Backtracking)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  numIslands = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 const\cf4 \cb5  height = grid.length;\cb1 \
\cb5   \cf6 \cb5 const\cf4 \cb5  width = height && grid[\cf8 \cb5 0\cf4 \cb5 ].length;\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  count = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  row = \cf8 \cb5 0\cf4 \cb5 ; row < height; row++) \{\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < width; col++) \{\cb1 \
\cb5       \cf6 \cb5 if\cf4 \cb5  (grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 continue\cf4 \cb5 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 function\cf4 \cb5  dfs(row, col) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (row < \cf8 \cb5 0\cf4 \cb5  || col < \cf8 \cb5 0\cf4 \cb5  || row === height || col === width || grid[row][col] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     dfs(row-\cf8 \cb5 1\cf4 \cb5 , col);\cb1 \
\cb5     dfs(row+\cf8 \cb5 1\cf4 \cb5 , col);\cb1 \
\cb5     dfs(row, col-\cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5     dfs(row, col+\cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Number in Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  largestNumber = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 const\cf4 \cb5  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb5     \cf12 \cb5 // -1 a goes before b\cf4 \cb1 \
\cb5     \cf12 \cb5 // 0  no change\cf4 \cb1 \
\cb5     \cf12 \cb5 // 1  b goes before a\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  compareFunc = (a, b) => \cf7 \cb5 `\cf4 \cb5 $\{b\}$\{a\}\cf7 \cb5 `\cf4 \cb5  - \cf7 \cb5 `\cf4 \cb5 $\{a\}$\{b\}\cf7 \cb5 `\cf4 \cb1 \
\
\cb5     finalNums.sort(compareFunc);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5 (finalNums[\cf8 \cb5 0\cf4 \cb5 ] === \cf7 \cb5 '0'\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  \cf7 \cb5 '0'\cf4 \cb5 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  finalNums.join(\cf7 \cb5 ''\cf4 \cb5 );\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf9 \cb5 Input\cf4 \cb5 : [\cf8 \cb5 3\cf4 \cb5 ,\cf8 \cb5 30\cf4 \cb5 ,\cf8 \cb5 34\cf4 \cb5 ,\cf8 \cb5 5\cf4 \cb5 ,\cf8 \cb5 9\cf4 \cb5 ]\cb1 \
\cf9 \cb5 Output\cf4 \cb5 : \cf7 \cb5 "9534330"\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Create Target Array from Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 Given two arrays of integers\'a0
\f4 \cf15 \cb16 nums
\f3 \cf14 \cb3 \'a0and\'a0
\f4 \cf15 \cb16 index
\f3 \cf14 \cb3 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf14 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
From left to right read nums[i] and index[i], insert at index\'a0
\f4 \cf15 \cb16 index[i]
\f3 \cf14 \cb3 \'a0the value\'a0
\f4 \cf15 \cb16 nums[i]
\f3 \cf14 \cb3 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Repeat the previous step until there are no elements to read in\'a0
\f4 \cf15 \cb16 nums
\f3 \cf14 \cb3 \'a0and\'a0
\f4 \cf15 \cb16 index.
\f3 \cf14 \cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf14 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  createTargetArray = (nums, idx) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  target = []\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  num \cf6 \cb5 in\cf4 \cb5  nums)target.splice(idx[num], \cf8 \cb5 0\cf4 \cb5 , nums[num])\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  target\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  nums = [\cf8 \cb5 0\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 3\cf4 \cb5 ,\cf8 \cb5 4\cf4 \cb5 ]\cb1 \
\cf6 \cb5 let\cf4 \cb5  index = [\cf8 \cb5 0\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb5 //Output: [0,4,1,3,2]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  climbStairs = n => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  arr=[\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 2\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 3\cf4 \cb5 ;i<n;i++)\{\cb1 \
\cb5         arr[i]=arr[i-\cf8 \cb5 1\cf4 \cb5 ] + arr[i-\cf8 \cb5 2\cf4 \cb5 ];\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  arr[n-\cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Image 90deg
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 You are given an\'a0
\f5\i n
\f3\i0 \'a0x\'a0
\f5\i n
\f3\i0 \'a02D matrix representing an image.\
Rotate the image by 90 degrees (clockwise).\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf14 Note:
\f3\b0 \
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.\'a0
\f6\b DO NOT
\f3\b0 \'a0allocate another 2D matrix and do the rotation.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rotate = grid => \{\cb1 \
\
\cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ;i < grid.length; i++)\{\cb1 \
\cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ;j < i; j++)\{\cb1 \
\
\cf6 \cb5 let\cf4 \cb5  temp = grid[i][j];\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 grid[i][j] = grid[j][i];\cb1 \
\cb5 grid[j][i] = temp;\cb1 \
\
\cb5 \}\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  g \cf6 \cb5 of\cf4 \cb5  grid) g.reverse()\cb1 \
\
\cf6 \cb5 return\cf4 \cb5  grid\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  x = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 3\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 4\cf4 \cb5 ,\cf8 \cb5 5\cf4 \cb5 ,\cf8 \cb5 6\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 7\cf4 \cb5 ,\cf8 \cb5 8\cf4 \cb5 ,\cf8 \cb5 9\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb5 // [\cf4 \cb1 \
\cf12 \cb5 //  [7,4,1],\cf4 \cb1 \
\cf12 \cb5 //  [8,5,2],\cf4 \cb1 \
\cf12 \cb5 //  [9,6,3]\cf4 \cb1 \
\cf12 \cb5 // ]\cf4 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Transpose Matrix 
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  transpose = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5 (arr.length === \cf8 \cb5 0\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  width = arr[\cf8 \cb5 0\cf4 \cb5 ].length \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  height = arr.length;\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  result = [];\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < width; i++) \{\cb1 \
\cb5         result[i] = [];\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < height; j++)\{\cb1 \
\cb5             result[i][j] = arr[j][i];\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf14 \cb3 Input: 
\f1\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f1\b0 [[1,4,7],[2,5,8],[3,6,9]]\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Maximum Subarray (Kadane\'92s Algorithm.  Dynamic Programming)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf14 \cb3 Given an integer array\'a0
\f4 \cf15 \cb16 nums
\f3 \cf14 \cb3 , find the contiguous subarray\'a0(containing at least one number) which has the largest sum and return its sum.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  maxSubArray = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  currentMax = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = nums[\cf8 \cb5 0\cf4 \cb5 ];\cb1 \
\
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  num \cf6 \cb5 of\cf4 \cb5  nums) \{\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  current = num;\cb1 \
\cb5     currentMax = \cf9 \cb5 Math\cf4 \cb5 .max(current, current + currentMax);\cb1 \
\cb5     max = \cf9 \cb5 Math\cf4 \cb5 .max(max, currentMax);\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  max;\cb1 \
\cb5 \};\cb1 \
\
\cb5 maxSubArray([\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , -\cf8 \cb5 4\cf4 \cb5 , \cf8 \cb5 4\cf4 \cb5 , -\cf8 \cb5 6\cf4 \cb5 , \cf8 \cb5 3\cf4 \cb5 , \cf8 \cb5 9\cf4 \cb5 , -\cf8 \cb5 11\cf4 \cb5 , \cf8 \cb5 10\cf4 \cb5 ])\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Knight Probability
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 On an\'a0
\f4 \cf15 \cb16 N
\f3 \cf14 \cb3 x
\f4 \cf15 \cb16 N
\f3 \cf14 \cb3 \'a0chessboard, a knight starts at the\'a0
\f4 \cf15 \cb16 r
\f3 \cf14 \cb3 -th row and\'a0
\f4 \cf15 \cb16 c
\f3 \cf14 \cb3 -th column and attempts to make exactly\'a0
\f4 \cf15 \cb16 K
\f3 \cf14 \cb3 \'a0moves. The rows and columns are 0 indexed, so the top-left square is\'a0
\f4 \cf15 \cb16 (0, 0)
\f3 \cf14 \cb3 , and the bottom-right square is\'a0
\f4 \cf15 \cb16 (N-1, N-1)
\f3 \cf14 \cb3 .\
A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\
The knight continues moving until it has made exactly\'a0
\f4 \cf15 \cb16 K
\f3 \cf14 \cb3 \'a0moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf14 \cb16 Input:
\f1\b0  3, 2, 0, 0\

\f0\b Output:
\f1\b0  0.0625\

\f0\b Explanation:
\f1\b0  There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\
From each of those positions, there are also two moves that will keep the knight on the board.\
The total probability the knight stays on the board is 0.0625.\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  knightProbability = (\cf9 \cb5 N\cf4 \cb5 , \cf9 \cb5 K\cf4 \cb5 , r, c) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  dp = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesR = [\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  movesC = [\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,-\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ,-\cf8 \cb5 2\cf4 \cb5 ]; \cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < dp.length; col++) \{\cb1 \
\cb5         dp[col] = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Array\cf4 \cb5 (\cf9 \cb5 N\cf4 \cb5 );\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  k = \cf8 \cb5 0\cf4 \cb5 ; k < dp[col].length; k++) \{\cb1 \
\cb5             dp[col][k] = [\cf8 \cb5 1\cf4 \cb5 ]; \cf12 \cb5 // 0 move has 100% of staying on the board\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  s = \cf8 \cb5 1\cf4 \cb5 ; s < \cf9 \cb5 K\cf4 \cb5  + \cf8 \cb5 1\cf4 \cb5 ; s++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf9 \cb5 N\cf4 \cb5 ; i++) \{\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < \cf9 \cb5 N\cf4 \cb5 ; j++) \{\cb1 \
\cb5                 \cf6 \cb5 let\cf4 \cb5  probability = \cf8 \cb5 0.0\cf4 \cb5 ;\cb1 \
\cb5                 \cf6 \cb5 for\cf4 \cb5 (\cf6 \cb5 let\cf4 \cb5  m = \cf8 \cb5 0\cf4 \cb5 ; m < \cf8 \cb5 8\cf4 \cb5 ; m++) \{\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextRow = i + movesR[m];\cb1 \
\cb5                     \cf6 \cb5 const\cf4 \cb5  nextCol = j + movesC[m];\cb1 \
\cb5                     \cf6 \cb5 if\cf4 \cb5 (nextRow >= \cf8 \cb5 0\cf4 \cb5  && nextRow < \cf9 \cb5 N\cf4 \cb5  && nextCol >= \cf8 \cb5 0\cf4 \cb5  && nextCol < \cf9 \cb5 N\cf4 \cb5 ) \{\cb1 \
\cb5                         probability += dp[nextRow][nextCol][s-\cf8 \cb5 1\cf4 \cb5 ]/\cf8 \cb5 8.0\cf4 \cb5 ; \cf12 \cb5 // % of chance out of 8 moves\cf4 \cb1 \
\cb5                     \}\cb1 \
\cb5                 \}\cb1 \
\cb5                 dp[i][j][s] = probability;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  dp[r][c][\cf9 \cb5 K\cf4 \cb5 ];\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Product Except Self
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 Given an array\'a0
\f4 \cf15 \cb16 nums
\f3 \cf14 \cb3 \'a0of\'a0
\f5\i n
\f3\i0 \'a0integers where\'a0
\f5\i n
\f3\i0 \'a0> 1, \'a0return an array\'a0
\f4 \cf15 \cb16 output
\f3 \cf14 \cb3 \'a0such that\'a0
\f4 \cf15 \cb16 output[i]
\f3 \cf14 \cb3 \'a0is equal to the product of all the elements of\'a0
\f4 \cf15 \cb16 nums
\f3 \cf14 \cb3 \'a0except\'a0
\f4 \cf15 \cb16 nums[i]
\f3 \cf14 \cb3 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf14 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b \cf14 \cb16 Input:
\f1\b0   [1,2,3,4]\

\f0\b Output:
\f1\b0  [24,12,8,6]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf14 \cb3 Constraint:
\f3\b0 \'a0It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\

\f6\b Note:\'a0
\f3\b0 Please solve it\'a0
\f6\b without division
\f3\b0 \'a0and in O(
\f5\i n
\f3\i0 ).
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\cf6 const\cf4  productExceptSelf = nums => \{\cb1 \
\cb5     \cf6 let\cf4  result = [\cf8 1\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  temp = \cf8 1\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < nums.length; i++) \{\cb1 \
\cb5         result[i] = result[i - \cf8 1\cf4 ] * nums[i - \cf8 1\cf4 ];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = nums.length - \cf8 1\cf4 ; i >= \cf8 \cb5 0\cf4 \cb5 ; i--) \{\cb1 \
\cb5         result[i] *= temp;\cb1 \
\cb5         temp *= nums[i];\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Largest Square in Grid
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  largestSquare = grid => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 let\cf4 \cb5  height = grid.length;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  width = height ? grid[\cf8 \cb5 0\cf4 \cb5 ].length : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  max = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  row = \cf8 \cb5 0\cf4 \cb5 ; row < height; row++) \{\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  col = \cf8 \cb5 0\cf4 \cb5 ; col < width; col++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  left = col === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row][col - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  up = row === \cf8 \cb5 0\cf4 \cb5  ? \cf8 \cb5 0\cf4 \cb5  : grid[row - \cf8 \cb5 1\cf4 \cb5 ][col];\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  back = row && col ? grid[row - \cf8 \cb5 1\cf4 \cb5 ][col - \cf8 \cb5 1\cf4 \cb5 ] : \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \cf6 \cb5 if\cf4 \cb5  (grid[row][col] == \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\cb5                 grid[row][col] = \cf9 \cb5 Math\cf4 \cb5 .min(left, up, back) + grid[row][col] * \cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5             \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5                 grid[row][col] = \cf8 \cb5 0\cf4 \cb5 ;\cb1 \
\cb5             \};\cb1 \
\cb5             max = \cf9 Math\cf4 .max(max, grid[row][col])\cb1 \
\cb5 ;\cb1 \
\cb5         \};\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  max * max;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 let\cf4 \cb5  items = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ],\cb1 \
\cb5   [\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 ]\cb1 \
\cb5 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Tower of Hanoi (Recursion)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  hanoiTower = (height, srcP, destP, bufferP) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (height >= \cf8 \cb5 1\cf4 \cb5 ) \{\cb1 \
\
\cb5     \cf12 \cb5 // Move a tower of height-1 to the buffer peg, using the destination peg.\cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , srcP, bufferP, destP);\cb1 \
\
\cb5     \cf12 \cb5 // Move the remaining disk to the destination peg.\cf4 \cb1 \
\cb5     console.log(\cf7 \cb5 'Move disk from Tower '\cf4 \cb5 , srcP, \cf7 \cb5 ' to Tower '\cf4 \cb5 , destP);\cb1 \
\
\cb5     \cf12 \cb5 // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.        \cf4 \cb1 \
\cb5     hanoiTower(height - \cf8 \cb5 1\cf4 \cb5 , bufferP, destP, srcP);\cb1 \
\cb5   \}\cb1 \
\cb5   \cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5 ;\cb1 \
\cb5 \}\cb1 \
\
\cb5 hanoiTower(\cf8 \cb5 3\cf4 \cb5 , \cf7 \cb5 "A"\cf4 \cb5 , \cf7 \cb5 "C"\cf4 \cb5 , \cf7 \cb5 "B"\cf4 \cb5 );\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  permute = (nums, memo = \cf8 0\cf4 ) => \{\cb1 \
\cb5     \cf6 if\cf4  (memo >= nums.length) \cf6 return\cf4  [[]];\cb1 \
\cb5     \cf6 const\cf4  result = [];\cb1 \
\cb5     \cf6 const\cf4  prevs = permute(nums, memo + \cf8 1\cf4 );  \cf12 // permutations of elements after n\cf4 \cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  prev \cf6 of\cf4  prevs) \{\cb1 \
\cb5         \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i <= prev.length; i++) \{\cb1 \
\cb5             \cf6 let\cf4  p = prev.slice(\cf8 0\cf4 );\cb1 \
\cb5             p.splice(i, \cf8 0\cf4 , nums[memo]);  \cf12 // successively insert element n\cf4 \cb1 \
\cb5             result.push(p); \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  result;\cb1 \
\cb5 \};\cb1 \
\
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Permutations 2 (Unique)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf14 \cb3 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0
\cf6 const\cf4  permuteUnique = nums => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     nums.sort((a,b) => a - b);\cb1 \
\cb5     \cb1 \
\cb5     \cf6 \cb5 let\cf4 \cb5  permU = \cf6 \cb5 function\cf4 \cb5 (nums) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (nums.length == \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  [nums];\cb1 \
\cb5         \cf6 \cb5 let\cf4 \cb5  result = []\cb1 \
\cb5         \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < nums.length; i++) \{\cb1 \
\cb5             \cf6 \cb5 let\cf4 \cb5  temp = [...nums.slice(\cf8 \cb5 0\cf4 \cb5 , i), ...nums.slice(i+\cf8 \cb5 1\cf4 \cb5 )];\cb1 \
\cb5             \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  c \cf6 \cb5 of\cf4 \cb5  permU(temp)) \{\cb1 \
\cb5                 result.push([nums[i], ...c]); \cb1 \
\cb5             \}\cb1 \
\cb5             \cf6 \cb5 while\cf4 \cb5 (nums[i+\cf8 \cb5 1\cf4 \cb5 ]==nums[i])i++; \cf12 \cb5 // skip\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  result;\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  permU(nums);\cb1 \
\cb5 \};\cb1 \
\cb5 nums = [\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 1\cf4 \cb5 ,\cf8 \cb5 2\cf4 \cb5 ]\cb1 \
\cb5 permuteUnique(nums) \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf12 \cb5 //[ [ 1, 1, 2 ], [ 1, 2, 1 ], [ 2, 1, 1 ] ]\cf4 \cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Range Sum of BST
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 Given the\'a0
\f4\fs26 \cf15 \cb16 root
\f3\fs28 \cf14 \cb3 \'a0node of a binary search tree, return the sum of values of all nodes with value between\'a0
\f4\fs26 \cf15 \cb16 L
\f3\fs28 \cf14 \cb3 \'a0and\'a0
\f4\fs26 \cf15 \cb16 R
\f3\fs28 \cf14 \cb3 \'a0(inclusive).\
The binary search tree is guaranteed to have unique values.
\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  rangeSumBST = (root, \cf9 \cb5 L\cf4 \cb5 , \cf9 \cb5 R\cf4 \cb5 ) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf12 \cb5 // check if value is in the given range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  isInBetween = val => val >= \cf9 \cb5 L\cf4 \cb5  && val <= \cf9 \cb5 R\cf4 \cb5 ;\cb1 \
\cb5     \cf12 \cb5 // sum the value if it's in the range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  add = (val, sum) => isInBetween(val) ? sum += val : sum;\cb1 \
\cb5 \'a0\'a0\cf12 \cb5 // traverse through the nodes and sum the values in range\cf4 \cb1 \
\cb5     \cf6 \cb5 const\cf4 \cb5  preorder =(root, sum) => \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (!root) \cf6 \cb5 return\cf4 \cb5  sum;\cb1 \
\cb5         \cf6 \cb5 return\cf4 \cb5  add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\cb1 \
\cb5     \} \cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  preorder(root, \cf8 \cb5 0\cf4 \cb5 )\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Shortest Path in Maze
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (x, y) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .x = x;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .y = y;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (pt, dist) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 this\cf4 \cb5 .pt = pt;\cb1 \
\cb5   \cf6 \cb5 this\cf4 \cb5 .dist = dist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  d = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: \cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \},\cb1 \
\cb5   \{x: \cf8 \cb5 0\cf4 \cb5 , y: -\cf8 \cb5 1\cf4 \cb5 \},\cb1 \
\cb5   \{x: -\cf8 \cb5 1\cf4 \cb5 , y: \cf8 \cb5 0\cf4 \cb5 \}\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  bfs(maze, src, dest) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 var\cf4 \cb5  minDist = -\cf8 \cb5 1\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (maze[src.x][src.y] != \cf8 \cb5 1\cf4 \cb5  || maze[dest.x][dest.y] != \cf8 \cb5 1\cf4 \cb5 )\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  h = maze.length;\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  w = maze[\cf8 \cb5 0\cf4 \cb5 ].length;\cb1 \
\cb5   visited = [];\cb1 \
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < h; i++) \{\cb1 \
\cb5     visited.push([]);\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  j = \cf8 \cb5 0\cf4 \cb5 ; j < w; j++) \{\cb1 \
\cb5       visited[i].push(\cf6 \cb5 false\cf4 \cb5 );\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  queue = [];\cb1 \
\cb5   \cf6 \cb5 var\cf4 \cb5  s = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (src, \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cb5   queue.push(s);\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (queue.length>\cf8 \cb5 0\cf4 \cb5 ) \{\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  curr = queue.pop();\cb1 \
\cb5     \cf6 \cb5 var\cf4 \cb5  pt = curr.pt;\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (pt.x == dest.x && pt.y == dest.y)\cb1 \
\cb5       \cf6 \cb5 return\cf4 \cb5  curr.dist;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 var\cf4 \cb5  i = \cf8 \cb5 0\cf4 \cb5 ; i < \cf8 \cb5 4\cf4 \cb5 ; i++) \{\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  row = pt.x + d[i].x;\cb1 \
\cb5       \cf6 \cb5 var\cf4 \cb5  col = pt.y + d[i].y;\cb1 \
\cb5       \cf6 \cb5 if\cf4 \cb5  (isValid(maze, visited, h, w, row, col)) \{\cb1 \
\cb5         visited[row][col] = \cf6 \cb5 true\cf4 \cb5 ;\cb1 \
\cb5         \cf6 \cb5 var\cf4 \cb5  adjCell = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Node\cf4 \cb5 (\cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (row, col), curr.dist + \cf8 \cb5 1\cf4 \cb5 );\cb1 \
\cb5         queue.push(adjCell);\cb1 \
\cb5       \}\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  minDist;\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 function\cf4 \cb5  isValid(maze, visited, width, height, row, col) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 return\cf4 \cb5  (row >= \cf8 \cb5 0\cf4 \cb5 ) && (row < width) && (col >= \cf8 \cb5 0\cf4 \cb5 ) && (col < height) && maze[row][col] == \cf8 \cb5 1\cf4 \cb5  && !visited[row][col];\cb1 \
\cb5 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  maze = [\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ],\cb1 \
\cb5     [ \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 1\cf4 \cb5  ]\cb1 \
\cb5 ];\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 var\cf4 \cb5  source = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 0\cf4 \cb5 , \cf8 \cb5 0\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dest = \cf6 \cb5 new\cf4 \cb5  \cf9 \cb5 Point\cf4 \cb5 (\cf8 \cb5 7\cf4 \cb5 , \cf8 \cb5 5\cf4 \cb5 );\cb1 \
\cf6 \cb5 var\cf4 \cb5  dist = bfs(maze, source, dest);\cb1 \
\
\cf6 \cb5 if\cf4 \cb5  (dist != -\cf8 \cb5 1\cf4 \cb5 )\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `The shortest path from (\cf4 \cb5 $\{source.x\}\cf7 \cb5 , \cf4 \cb5 $\{source.y\}\cf7 \cb5 ) to (\cf4 \cb5 $\{dest.x\}\cf7 \cb5 , \cf4 \cb5 $\{dest.y\}\cf7 \cb5 ) has length \cf4 \cb5 $\{dist\}\cf7 \cb5 \\n`\cf4 \cb5 );\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 else\cf4 \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   console.log(\cf7 \cb5 `Shortest path from \cf4 \cb5 $\{(source.x, source.y)\}\cf7 \cb5  to \cf4 \cb5 $\{(dest.x, dest.y)\}\cf7 \cb5  does not exist`\cf4 \cb5 );\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Repeated Substring Pattern
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\partightenfactor0

\f3 \cf14 \cb3 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\

\f1 \cf4 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  repeatedSubstringPattern = string => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5     \cf6 \cb5 if\cf4 \cb5  (string.length === \cf8 \cb5 0\cf4 \cb5  || string.length === \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 false\cf4 \cb5 ;\cb1 \
\cb5     \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  i = \cf8 \cb5 1\cf4 \cb5 ; i <= string.length / \cf8 \cb5 2\cf4 \cb5 ; i++) \{\cb1 \
\cb5         \cf6 \cb5 if\cf4 \cb5  (string.length % i === \cf8 \cb5 0\cf4 \cb5  && string.slice(\cf8 \cb5 0\cf4 \cb5 , i).repeat(string.length / i) === string) \{\cb1 \
\cb5             \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 true\cf4 \cb5 ;\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 \cb5 return\cf4 \cb5  \cf6 \cb5 false\cf4 \cb5 ;\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  merge = (arr1, arr2) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 let\cf4 \cb5  sorted = [];\cb1 \
\
\cb5   \cf6 \cb5 while\cf4 \cb5  (arr1.length && arr2.length) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (arr1[\cf8 \cb5 0\cf4 \cb5 ] < arr2[\cf8 \cb5 0\cf4 \cb5 ]) sorted.push(arr1.shift());\cb1 \
\cb5     \cf6 \cb5 else\cf4 \cb5  sorted.push(arr2.shift());\cb1 \
\cb5   \};\cb1 \
\
\cb5   \cf6 \cb5 return\cf4 \cb5  sorted.concat(arr1.slice().concat(arr2.slice()));\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  mergeSort = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5   \cf6 \cb5 if\cf4 \cb5  (arr.length <= \cf8 \cb5 1\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  arr;\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  mid = \cf9 \cb5 Math\cf4 \cb5 .floor(arr.length / \cf8 \cb5 2\cf4 \cb5 ),\cb1 \
\cb5       left = mergeSort(arr.slice(\cf8 \cb5 0\cf4 \cb5 , mid)),\cb1 \
\cb5       right = mergeSort(arr.slice(mid));\cb1 \
\
\cb5   \cf6 \cb5 return\cf4 \cb5  merge(left, right);\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Quick Sort
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4 \cb5  quickSort = arr => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \'a0\'a0\cf6 \cb5 if\cf4 \cb5  (arr.length <= \cf8 \cb5 1\cf4 \cb5  || arr === \cf6 \cb5 null\cf4 \cb5 ) \cf6 \cb5 return\cf4 \cb5  arr;\cb1 \
\cb5 \'a0\'a0\cf6 \cb5 let\cf4 \cb5  pivot = arr[arr.length - \cf8 \cb5 1\cf4 \cb5 ];\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  leftArr = [];\cb1 \
\cb5   \cf6 \cb5 let\cf4 \cb5  rightArr = [];\cb1 \
\
\cb5   \cf6 \cb5 for\cf4 \cb5  (\cf6 \cb5 let\cf4 \cb5  el \cf6 \cb5 of\cf4 \cb5  arr.slice(\cf8 \cb5 0\cf4 \cb5 , arr.length -\cf8 \cb5 1\cf4 \cb5 )) \{\cb1 \
\cb5     \cf6 \cb5 if\cf4 \cb5  (el < pivot) \{\cb1 \
\cb5       leftArr.push(el);\cb1 \
\cb5     \} \cf6 \cb5 else\cf4 \cb5  \{\cb1 \
\cb5       rightArr.push(el);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf6 \cb5 return\cf4 \cb5  [...quickSort(leftArr), pivot, ...quickSort(rightArr)]\cb1 \
\cb5 \}\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Verifying an Alien Dictionary
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isAlienSorted = (words, order) => \{\cb1 \
\cb5     \cf6 let\cf4  charPosition = \cf6 new\cf4  \cf9 Map\cf4 ()\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  position = \cf8 0\cf4 ; position < order.length; position++)\{\cb1 \
\cb5         \cf6 let\cf4  char = order[position]\cb1 \
\cb5         charPosition.\cf6 set\cf4 (char, position)\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4 (\cf6 let\cf4  i = \cf8 1\cf4 ; i < words.length; i++)\{\cb1 \
\cb5         \cf6 let\cf4  prev = words[i-\cf8 1\cf4 ], curr = words[i]\cb1 \
\cb5         \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[\cf8 0\cf4 ]) > charPosition.\cf6 get\cf4 (curr[\cf8 0\cf4 ]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \cf6 else\cf4  \cf6 if\cf4 (prev[\cf8 0\cf4 ] === curr[\cf8 0\cf4 ])\{\cb1 \
\cb5             \cf6 let\cf4  pointer = \cf8 1\cf4 \cb1 \
\cb5             \cf6 while\cf4 (prev[pointer] === curr[pointer])pointer++\cb1 \
\cb5             \cf6 if\cf4 (curr[pointer] === \cf6 undefined\cf4 )\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \cf6 if\cf4 (charPosition.\cf6 get\cf4 (prev[pointer]) > charPosition.\cf6 get\cf4 (curr[pointer]))\cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  \cf6 true\cf4 \cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Destination City
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 You are given the array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 paths
\f3\fs28 \cf17 \cb3 \strokec17 , where\'a0
\f4\fs26 \cf18 \cb19 \strokec18 paths[i] = [cityA
\fs19\fsmilli9750 i
\fs26 , cityB
\fs19\fsmilli9750 i
\fs26 ]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0means there\'a0exists a direct path going from\'a0
\f4\fs26 \cf18 \cb19 \strokec18 cityA
\fs19\fsmilli9750 i
\f3\fs28 \cf17 \cb3 \strokec17 \'a0to\'a0
\f4\fs26 \cf18 \cb19 \strokec18 cityB
\fs19\fsmilli9750 i
\f3\fs28 \cf17 \cb3 \strokec17 .\'a0
\f5\i Return the destination city, that is, the city without any path outgoing to another city.
\f3\i0 \
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]\

\f0\b Output:
\f1\b0  "Sao Paulo" \

\f0\b Explanation:
\f1\b0  Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\cf6 const\cf4  destCity = paths => \{\cb1 \
\cb5     \cf6 const\cf4  result = \cf6 new\cf4  \cf9 Set\cf4 (paths.map((path) => path[\cf8 0\cf4 ]));\cb1 \
\cb5     \cf6 return\cf4  paths.filter((path) => !result.has(path[\cf8 1\cf4 ])).pop()[\cf8 1\cf4 ]\cb1 \
\cb5 \};\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Parentheses
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a string containing just the characters\'a0
\f4\fs26 \cf18 \cb19 \strokec18 '('
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 ')'
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 '\{'
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 '\}'
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 '['
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 ']'
\f3\fs28 \cf17 \cb3 \strokec17 , determine if the input string is valid.\
An input string is valid if:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Open brackets must be closed by the same type of brackets.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Open brackets must be closed in the correct order.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 Note that an empty string is\'a0also considered valid.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  "()"\

\f0\b Output:
\f1\b0  true\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\cf6 const\cf4  isValid = str => \{\cb1 \
\cb5     \cf6 const\cf4  stack = []\cb1 \
\cb5     \cf6 const\cf4  keys = \{\cb1 \
\cb5         \cf7 '('\cf4 : \cf7 ')'\cf4 ,\cb1 \
\cb5         \cf7 '\{'\cf4 : \cf7 '\}'\cf4 ,\cb1 \
\cb5         \cf7 '['\cf4 : \cf7 ']'\cf4 ,\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  char \cf6 of\cf4  str) \{\cb1 \
\cb5         \cf6 if\cf4  (char \cf6 in\cf4  keys) \{\cb1 \
\cb5             stack.push(keys[char])\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             \cf6 if\cf4  (stack.length === \cf8 0\cf4  || stack.pop() !== char) \{\cb1 \
\cb5                 \cf6 return\cf4  \cf6 false\cf4 \cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  stack.length === \cf8 0\cf4 \cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Say you have an array for which the\'a0
\f5\i i
\f3\i0\fs21 th
\fs28 \'a0element is the price of a given stock on day\'a0
\f5\i i
\f3\i0 .\
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\
Note that you cannot sell a stock before you buy one.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [7,1,5,3,6,4]\

\f0\b Output:
\f1\b0  5\

\f0\b Explanation:
\f1\b0  Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\
\'a0            Not 7-1 = 6, as selling price needs to be larger than buying price.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\cf6 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  bestBuy = prices[\cf8 0\cf4 ];\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 1\cf4 ; i < prices.length; i++) \{\cb1 \
\cb5         bestBuy = \cf9 Math\cf4 .min(bestBuy, prices[i])\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit, prices[i] - bestBuy);\cb1 \
\cb5     \};\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Buy and Sell Stock II
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Say you have an array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 prices
\f3\fs28 \cf17 \cb3 \strokec17 \'a0for which the\'a0
\f5\i i
\f3\i0\fs21 th
\fs28 \'a0element is the price of a given stock on day\'a0
\f5\i i
\f3\i0 .\
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \'a0You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\

\f6\b Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [7,1,5,3,6,4]\

\f0\b Output:
\f1\b0  7\

\f0\b Explanation:
\f1\b0  Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\
\'a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  maxProfit = prices => \{\cb1 \
\cb5     \cf6 let\cf4  profit = \cf8 0\cf4 ;\cb1 \
\cb5     \cf6 for\cf4  (\cf6 let\cf4  i = \cf8 0\cf4 ; i < prices.length - \cf8 1\cf4 ; i++) \{\cb1 \
\cb5         \cf6 const\cf4  possibleProfit = prices[i + \cf8 1\cf4 ] - prices[i];\cb1 \
\cb5         profit = \cf9 Math\cf4 .max(profit + possibleProfit, profit);\cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  profit;\cb1 \
\cb5 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Integer
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a 32-bit signed integer, reverse digits of an integer.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  123\

\f0\b Output:
\f1\b0  321\
\pard\pardeftab720\partightenfactor0

\f6\b\fs28 \cf17 \cb3 \
Note:
\f3\b0 \
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\uc0\u8722 2
\fs21 31
\fs28 ,\'a0 2
\fs21 31\'a0
\fs28 \uc0\u8722  1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseInt = x => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  max = \cf13 \strokec13 Math\cf4 \strokec4 .pow(\cf11 \strokec11 2\cf4 \strokec4 , \cf11 \strokec11 31\cf4 \strokec4 ) - \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  min = \cf13 \strokec13 Math\cf4 \strokec4 .pow(-\cf11 \strokec11 2\cf4 \strokec4 , \cf11 \strokec11 31\cf4 \strokec4 )\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  sign = \cf13 \strokec13 Math\cf4 \strokec4 .sign(x)\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  num = (x * sign).toString().split(\cf20 \strokec20 ''\cf4 \strokec4 ).reverse().join(\cf20 \strokec20 ''\cf4 \strokec4 )\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  result = \cf13 \strokec13 Number\cf4 \strokec4 (num) * sign\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  result > min && result < max ? result : \cf11 \strokec11 0\cf4 \cb1 \strokec4 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Longest Common Prefix\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf17 \outl0\strokewidth0 \strokec17 Write a function to find the longest common prefix string amongst an array of strings.\
If there is no common prefix, return an empty string\'a0
\f4\fs26 \cf18 \cb19 \strokec18 ""
\f3\fs28 \cf17 \cb3 \strokec17 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input: 
\f1\b0 ["flower","flow","flight"]\

\f0\b Output:
\f1\b0  "fl"\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  longestCommonPrefix = strs => \{\cb1 \
\cb10   \cf6 \strokec6 if\cf4 \strokec4  (!strs.length) \cf6 \strokec6 return\cf4 \strokec4  \cf20 \strokec20 ''\cf4 \strokec4 ;\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < strs[\cf11 \strokec11 0\cf4 \strokec4 ].length; i++) \{\cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  str \cf6 \strokec6 of\cf4 \strokec4  strs) \{\cb1 \
\cb10       \cf6 \strokec6 if\cf4 \strokec4  (str[i] !== strs[\cf11 \strokec11 0\cf4 \strokec4 ][i]) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  str.slice(\cf11 \strokec11 0\cf4 \strokec4 , i);\cb1 \
\cb10       \}\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  strs[\cf11 \strokec11 0\cf4 \strokec4 ];\cb1 \
\cb10 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Duplicate Numbers from Sorted Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a sorted array\'a0
\f5\i nums
\f3\i0 , remove the duplicates\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/In-place_algorithm"}}{\fldrslt 
\f6\b \cf21 \strokec21 in-place}}\'a0such that each element appear only\'a0
\f5\i once
\f3\i0 \'a0and return the new length.\
Do not allocate extra space for another array, you must do this by\'a0
\f6\b modifying the input array\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/In-place_algorithm"}}{\fldrslt \cf21 \strokec21 in-place}}
\f3\b0 \'a0with O(1) extra memory.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19 Given 
\f7\i nums
\f1\i0  = 
\f0\b [1,1,2]
\f1\b0 ,\
\
Your function should return length = 
\f0\b 2
\f1\b0 , with the first two elements of 
\f7\i nums
\f1\i0  being 
\f0\b 1
\f1\b0  and 
\f0\b 2
\f1\b0  respectively.\
\
It doesn't matter what you leave beyond the returned length.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  removeDuplicates = nums => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     nums.forEach(num => \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (num !== nums[i]) \{\cb1 \
\cb10             nums[++i] = num;\cb1 \
\cb10         \}\cb1 \
\cb10     \});\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  i + \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Remove Element from Array
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  removeElement = (nums, val) => \{\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < nums.length; i++) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (nums[i] === val) \{\cb1 \
\cb10       nums.splice(i, \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10       i--;\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  nums.length;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // strStr (Needle and Haystack)
\f3\b0 \cf17 \outl0\strokewidth0 \strokec17 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 Return the index of the first occurrence of needle in haystack, or\'a0
\f6\b -1
\f3\b0 \'a0if needle is not part of haystack.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  haystack = "hello", needle = "ll"\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  haystack = "aaaaa", needle = "bba"\

\f0\b Output:
\f1\b0  -1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  strStr = (haystack, needle) => \{\cb1 \
\
\cb10   \cf6 \strokec6 if\cf4 \strokec4 (needle === \cf20 \strokec20 ''\cf4 \strokec4  && haystack === \cf20 \strokec20 ''\cf4 \strokec4  )\{\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 0\cf4 \cb1 \strokec4 \
\cb10   \}\cb1 \
\
\cb10   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < haystack.length; i++)\{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (haystack.substr(i, needle.length) === needle)\{\cb1 \
\cb10       \cf6 \strokec6 return\cf4 \strokec4  i\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  -\cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Search Insert Position
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\
You may assume no duplicates in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [1,3,5,6], 5\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  searchInsert = (nums, target) => \{\cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < nums.length; i++)\{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (nums[i] >= target)\{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  i;\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  nums.length;\cb1 \
\cb10 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \outl0\strokewidth0 // Length of Last Word
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a string\'a0
\f5\i s
\f3\i0 \'a0consists of upper/lower-case alphabets and empty space characters\'a0
\f4\fs26 \cf18 \cb19 \strokec18 ' '
\f3\fs28 \cf17 \cb3 \strokec17 , return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\
If the last word does not exist, return 0.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \'a0A word is defined as a\'a0
\f6\b maximal substring
\f3\b0 \'a0consisting\'a0of non-space characters only.\

\f6\b Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  "Hello World"\

\f0\b Output:
\f1\b0  5\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  lengthOfLastWord = str => \{\cb1 \
\cb5     \cf6 const\cf4  result = str.trim().split(\cf7 ' '\cf4 );\cb1 \
\cb5     \cf6 return\cf4  result[result.length - \cf8 1\cf4 ].length;\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Plus One
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array of digits\'a0representing a non-negative integer, plus one to the integer.\
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\
You may assume the integer does not contain any leading zero, except the number 0 itself.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [1,2,3]\

\f0\b Output:
\f1\b0  [1,2,4]\

\f0\b Explanation:
\f1\b0  The array represents the integer 123.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  plusOne = digits => \{\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = digits.length - \cf11 \strokec11 1\cf4 \strokec4 ; i >= \cf11 \strokec11 0\cf4 \strokec4 ; i--)\{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4 (digits[i] === \cf11 \strokec11 9\cf4 \strokec4 )\{\cb1 \
\cb10       digits[i] = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10       digits[i]++;\cb1 \
\cb10       \cf6 \strokec6 return\cf4 \strokec4  digits;\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  [\cf11 \strokec11 1\cf4 \strokec4 , ...digits];\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Sorted Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two sorted integer arrays\'a0
\f5\i nums1
\f3\i0 \'a0and\'a0
\f5\i nums2
\f3\i0 , merge\'a0
\f5\i nums2
\f3\i0 \'a0into\'a0
\f5\i nums1
\f3\i0 \'a0as one sorted array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 The number of elements initialized in\'a0
\f5\i nums1
\f3\i0 \'a0and\'a0
\f5\i nums2
\f3\i0 \'a0are\'a0
\f5\i m
\f3\i0 \'a0and\'a0
\f5\i n
\f3\i0 \'a0respectively.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 You may assume that\'a0
\f5\i nums1
\f3\i0 \'a0has enough space (size that is greater or equal to\'a0
\f5\i m
\f3\i0 \'a0+\'a0
\f5\i n
\f3\i0 ) to hold additional elements from\'a0
\f5\i nums2
\f3\i0 .\cb1 \
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 \cb3 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0 \
nums1 = [1,2,3,0,0,0], m = 3\
nums2 = [2,5,6],       n = 3\
\

\f0\b Output:
\f1\b0 \'a0[1,2,2,3,5,6]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  merge = (nums1, m, nums2, n) => \{\cb1 \
\cb10     \cb1 \
\cb10    \cf6 \strokec6 let\cf4 \strokec4  len = nums1.length - \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10    m--;\cb1 \
\cb10    n--;\cb1 \
\cb10     \cb1 \
\cb10    \cf6 \strokec6 while\cf4 \strokec4  (n >= \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10        \cf6 \strokec6 if\cf4 \strokec4  (nums1[m] > nums2[n]) \{\cb1 \
\cb10            nums1[len] = nums1[m], m--\cb1 \
\cb10        \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10            nums1[len] = nums2[n], n--\cb1 \
\cb10        \}\cb1 \
\cb10        len--\cb1 \
\cb10    \cb1 \
\cb10    \}\cb1 \
\cb10    \cf6 \strokec6 return\cf4 \strokec4  nums1\cb1 \
\cb10     \cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find the Town Judge
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 In a town, there are\'a0
\f4\fs26 \cf18 \cb19 \strokec18 N
\f3\fs28 \cf17 \cb3 \strokec17 \'a0people labelled from\'a0
\f4\fs26 \cf18 \cb19 \strokec18 1
\f3\fs28 \cf17 \cb3 \strokec17 \'a0to\'a0
\f4\fs26 \cf18 \cb19 \strokec18 N
\f3\fs28 \cf17 \cb3 \strokec17 .\'a0 There is a rumor that one of these people is secretly the town judge.\
If the\'a0town judge exists, then:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 The town judge trusts nobody.\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Everybody (except for the town judge) trusts the town judge.\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 There is exactly one person that satisfies properties 1 and 2.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 You are given\'a0
\f4\fs26 \cf18 \cb19 \strokec18 trust
\f3\fs28 \cf17 \cb3 \strokec17 , an array of pairs\'a0
\f4\fs26 \cf18 \cb19 \strokec18 trust[i] = [a, b]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0representing that the person labelled\'a0
\f4\fs26 \cf18 \cb19 \strokec18 a
\f3\fs28 \cf17 \cb3 \strokec17 \'a0trusts the person labelled\'a0
\f4\fs26 \cf18 \cb19 \strokec18 b
\f3\fs28 \cf17 \cb3 \strokec17 .\
If the town judge exists and can be identified, return the label of the town judge.\'a0 Otherwise, return\'a0
\f4\fs26 \cf18 \cb19 \strokec18 -1
\f3\fs28 \cf17 \cb3 \strokec17 .\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  N = 2, trust = [[1,2]]\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  findJudge = (\cf13 \strokec13 N\cf4 \strokec4 , trust) => \{\cb1 \
\cb10   \cf6 \strokec6 var\cf4 \strokec4  graph = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Map\cf4 \strokec4  ()\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 1\cf4 \strokec4 ; i <= \cf13 \strokec13 N\cf4 \strokec4 ; i++) \{\cb1 \
\cb10     graph.\cf6 \strokec6 set\cf4 \strokec4 (i, \cf11 \strokec11 1\cf4 \strokec4 )\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  [v, e] \cf6 \strokec6 of\cf4 \strokec4  trust) \{\cb1 \
\cb10     graph.\cf6 \strokec6 set\cf4 \strokec4 (v, graph.\cf6 \strokec6 get\cf4 \strokec4 (v) - \cf11 \strokec11 1\cf4 \strokec4 ) \cf22 \strokec22 // the node which is not trusted -1\cf4 \cb1 \strokec4 \
\cb10     graph.\cf6 \strokec6 set\cf4 \strokec4 (e, graph.\cf6 \strokec6 get\cf4 \strokec4 (e) + \cf11 \strokec11 1\cf4 \strokec4 ) \cf22 \strokec22 // the node which is trusted + 1\cf4 \cb1 \strokec4 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  [key, value] \cf6 \strokec6 of\cf4 \strokec4  graph) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (value === \cf13 \strokec13 N\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  key\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  -\cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Partition Equal Subset Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array containing\'a0
\f6\b only positive integers
\f3\b0 , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls5\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Each of the array element will not exceed 100.\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 The array size will not exceed 200.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19 Input: [1, 5, 11, 5]\
\
Output: true\
\
Explanation: The array can be partitioned as [1, 5, 5] and [11].\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  canPartition = nums => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4 (!nums) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  total = nums.reduce((a,b) => a + b, \cf11 \strokec11 0\cf4 \strokec4 )\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4 (total%\cf11 \strokec11 2\cf4 \strokec4  != \cf11 \strokec11 0\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  target = total / \cf11 \strokec11 2\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  arr = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Array\cf4 \strokec4 (target + \cf11 \strokec11 1\cf4 \strokec4 ).fill(\cf6 \strokec6 false\cf4 \strokec4 )\cb1 \
\cb10     arr[\cf11 \strokec11 0\cf4 \strokec4 ] = \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  el \cf6 \strokec6 of\cf4 \strokec4  nums) \{\cb1 \
\cb10         \cb1 \
\cb10         \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = target; i >= \cf11 \strokec11 0\cf4 \strokec4 ; i--) \{            \cb1 \
\cb10             \cf6 \strokec6 let\cf4 \strokec4  complement = i - el\cb1 \
\cb10             \cb1 \
\cb10             \cf6 \strokec6 if\cf4 \strokec4 (!arr[i] && arr[complement])\{\cb1 \
\cb10                 arr[i] = \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb10             \}\cb1 \
\cb10             \cf6 \strokec6 if\cf4 \strokec4 (arr[target] == \cf6 \strokec6 true\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \cb1 \strokec4 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \cb1 \strokec4 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Balanced Binary Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a binary tree, determine if it is height-balanced.\
For this problem, a height-balanced binary tree is defined as:\
\pard\pardeftab720\sa280\partightenfactor0
\cf23 \strokec23 a binary tree in which the left and right subtrees of\'a0
\f5\i every
\f3\i0 \'a0node differ in height by no more than 1.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 \strokec17 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
Given the following tree\'a0
\f4\fs26 \cf18 \cb19 \strokec18 [3,9,20,null,null,15,7]
\f3\fs28 \cf17 \cb3 \strokec17 :\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19     3\
   / \\\
  9  20\
    /  \\\
   15   7\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 Return true.\cb1 \uc0\u8232 \u8232 
\f6\b \cb3 Example 2:
\f3\b0 \
Given the following tree\'a0
\f4\fs26 \cf18 \cb19 \strokec18 [1,2,2,3,3,null,null,4,4]
\f3\fs28 \cf17 \cb3 \strokec17 :\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19        1\
      / \\\
     2   2\
    / \\\
   3   3\
  / \\\
 4   4\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 Return false.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{TreeNode\} root\
 * @return \{boolean\}\
 */\outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isBalanced = root => \{\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  dfs = node => \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (!node) \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 0\cf4 \strokec4 ;\
\cb1 \
\cb10         \cf6 \strokec6 let\cf4 \strokec4  left = \cf11 \strokec11 1\cf4 \strokec4  + dfs(node.left);\cb1 \
\cb10         \cf6 \strokec6 let\cf4 \strokec4  right = \cf11 \strokec11 1\cf4 \strokec4  + dfs(node.right);\
\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (\cf13 \strokec13 Math\cf4 \strokec4 .abs(left - right) > \cf11 \strokec11 1\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Infinity\cf4 \strokec4 ;\
\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Math\cf4 \strokec4 .max(left, right);\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  dfs(root) == \cf13 \strokec13 Infinity \cf4 \strokec4 ? \cf6 \strokec6 false \cf4 \strokec4 : \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Same Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf14 \cb3 Given two binary trees, write a function to check if they are the same or not.\
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf14 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf14 \cb16 Input:
\f1\b0      1         1\
          / \\       / \\\
         2   3     2   3\
\
        [1,2,3],   [1,2,3]\
\

\f0\b Output:
\f1\b0  true\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf14 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf14 \cb16 Input:
\f1\b0      1         1\
          /           \\\
         2             2\
\
        [1,2],     [1,null,2]\
\

\f0\b Output:
\f1\b0  false\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{TreeNode\} p\
 * @param \{TreeNode\} q\
 * @return \{boolean\}\
 */\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  isSameTree = (p, q) => \{\cb1 \
\cb5     \cf6 if\cf4  (!p && !q) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 true\cf4 ; \cf12 \cb5 // Both nodes are null, ok\cf4 \cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 if\cf4  (!p || !q || p.val !== q.val) \{\cb1 \
\cb5         \cf6 return\cf4  \cf6 false\cf4 ; \cf12 \cb5 // Found a mismatch\cf4 \cb1 \
\cb5     \}\cb1 \
\cb5     \cf6 return\cf4  isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Symmetric Tree
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\
For example, this binary tree\'a0
\f4\fs26 \cf18 \cb19 \strokec18 [1,2,2,3,4,4,3]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0is symmetric:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19     1\
   / \\\
  2   2\
 / \\ / \\\
3  4 4  3\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 \'a0\
But the following\'a0
\f4\fs26 \cf18 \cb19 \strokec18 [1,2,2,null,3,null,3]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0is not:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19     1\
   / \\\
  2   2\
   \\   \\\
   3    3\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 \'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Follow up:
\f3\b0 \'a0Solve it both recursively and iteratively.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isSymmetric = root => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (!root) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\
\cb10     \cf22 \strokec22 // Check if tree s & t are mirroring each other\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 function\cf4 \strokec4  isMirror(p, q) \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (!p && !q) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ; \cf22 \strokec22 // Both nodes are null, ok\cf4 \cb1 \strokec4 \
\cb10         \}\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (!p || !q || p.val !== q.val) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ; \cf22 \strokec22 // Found a mismatch\cf4 \cb1 \strokec4 \
\cb10         \}\cb1 \
\cb10         \cf22 \strokec22 // Compare the left subtree of `s` with the right subtree of `t`\cf4 \cb1 \strokec4 \
\cb10         \cf22 \strokec22 // and the right subtree of `s` with the left subtree of `t`\cf4 \cb1 \strokec4 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  isMirror(p.left, q.right) && isMirror(p.right, q.left);\cb1 \
\cb10     \}\cb1 \
\
\cb10     \cf6 \strokec6 return\cf4 \strokec4  isMirror(root.left, root.right);\cb1 \
\cb10 \};\cb1 \
\outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Convert Sorted Array to BST\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf14 Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of\'a0
\f5\i every
\f3\i0 \'a0node never differ by more than 1.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf14 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf14 \cb16 Given the sorted array: [-10,-3,0,5,9],\
\
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\
\
      0\
     / \\\
   -3   9\
   /   /\
 -10  5\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 /**\
 * Definition for a binary tree node.\
 * function TreeNode(val, left, right) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.left = (left===undefined ? null : left)\
 *     this.right = (right===undefined ? null : right)\
 * \}\
 */\
/**\
 * @param \{number[]\} nums\
 * @return \{TreeNode\}\
 */\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 const\cf4  sortedArrayToBST = nums => \{\cb1 \
\cb5     \cf6 if\cf4  (!nums.length) \cf6 return\cf4  \cf6 null\cf4 ;\cb1 \
\cb5     \cb1 \
\cb5     \cf6 const\cf4  mid = \cf9 Math\cf4 .floor(nums.length / \cf8 2\cf4 );\cb1 \
\cb5     \cf6 const\cf4  root = \cf6 new\cf4  \cf9 TreeNode\cf4 (nums[mid]);\cb1 \
\cb5     \cb1 \
\cb5     \cf12 // subtrees are BSTs as well\cf4 \cb1 \
\cb5     root.left = sortedArrayToBST(nums.slice(\cf8 0\cf4 , mid));\cb1 \
\cb5     root.right = sortedArrayToBST(nums.slice(mid + \cf8 1\cf4 ));\cb1 \
\cb5     \cb1 \
\cb5     \cf6 return\cf4  root;\cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Path Sum
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \'a0A leaf is a node with no children.\

\f6\b Example:
\f3\b0 \
Given the below binary tree and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 sum = 22
\f3\fs28 \cf17 \cb3 \strokec17 ,\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19       
\f0\b 5
\f1\b0 \
     
\f0\b /
\f1\b0  \\\
    
\f0\b 4
\f1\b0    8\
   
\f0\b /
\f1\b0    / \\\
  
\f0\b 11
\f1\b0   13  4\
 /  
\f0\b \\
\f1\b0       \\\
7    
\f0\b 2
\f1\b0       1\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 return true, as there exist a root-to-leaf path\'a0
\f4\fs26 \cf18 \cb19 \strokec18 5->4->11->2
\f3\fs28 \cf17 \cb3 \strokec17 \'a0which sum is 22.\
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  hasPathSum = (root, sum) => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (!root) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (!root.left && !root.right) \cf6 \strokec6 return\cf4 \strokec4  sum - root.val == \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);    \cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Kids With the Greatest Number of Candies
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  kidsWithCandies = (candies, extraCandies) => \{\cb1 \
\cb10 \'a0\'a0\cf6 \strokec6 const\cf4 \strokec4  max = \cf13 \strokec13 Math\cf4 \strokec4 .max(...candies)\cb1 \
\cb10 \'a0\'a0\cf6 \strokec6 const\cf4 \strokec4  result = candies.map(candy => candy + extraCandies >= max)\cb1 \
\cb10 \'a0\'a0\cf6 \strokec6 return\cf4 \strokec4  result\cb1 \
\cb10 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse String
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseString = str => \{\cb1 \
\cb10   \cf6 \strokec6 if\cf4 \strokec4  (str.length < \cf11 \strokec11 2\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  str;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  start = \cf11 \strokec11 0\cf4 \strokec4 , end = str.length - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 while\cf4 \strokec4  (end > start) \{\cb1 \
\cb10     [str[start], str[end]] = [str[end], str[start]]; \cf22 \strokec22 // es6 swap trick\cf4 \cb1 \strokec4 \
\cb10     end--;\cb1 \
\cb10     start++;\cb1 \
\cb10   \}\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Max Depth of Binary Tree
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  maxDepth = root => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (root === \cf6 \strokec6 null\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 0\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Math\cf4 \strokec4 .max(maxDepth(root.left), maxDepth(root.right)) + \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Single Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a\'a0
\f6\b non-empty
\f3\b0 \'a0array of integers, every element appears\'a0
\f5\i twice
\f3\i0 \'a0except for one. Find that single one.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Note:
\f3\b0 \
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\

\f6\b Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [2,2,1]\

\f0\b Output:
\f1\b0  1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  singleNumber = nums => \{\cb1 \
\cb10   \cf6 \strokec6 const\cf4 \strokec4  map = \{\};\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 of\cf4 \strokec4  nums) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (map[num] == \cf6 \strokec6 null\cf4 \strokec4 ) map[num] = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     map[num]++;\cb1 \
\cb10   \}\cb1 \
\
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  num \cf6 \strokec6 in\cf4 \strokec4  map) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (map[num] === \cf11 \strokec11 1\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Number\cf4 \strokec4 (num);\cb1 \
\cb10   \}\cb1 \
\cb10 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // FizzBuzz
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Write a program that outputs the string representation of numbers from 1 to\'a0
\f5\i n
\f3\i0 .\
But for multiples of three it should output \'93Fizz\'94 instead of the number and for the multiples of five output \'93Buzz\'94. For numbers which are multiples of both three and five output \'93FizzBuzz\'94.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19 n = 15,\
\
Return:\
[\
    "1",\
    "2",\
    "Fizz",\
    "4",\
    "Buzz",\
    "Fizz",\
    "7",\
    "8",\
    "Fizz",\
    "Buzz",\
    "11",\
    "Fizz",\
    "13",\
    "14",\
    "FizzBuzz"\
]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  fizzBuzz = num => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  result = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Array\cf4 \strokec4 (num);\cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 1\cf4 \strokec4 ; i <= num ; i++)\{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4 (i % \cf11 \strokec11 15\cf4 \strokec4  === \cf11 \strokec11 0\cf4 \strokec4 ) result[i-\cf11 \strokec11 1\cf4 \strokec4 ] = \cf20 \strokec20 'FizzBuzz'\cf4 \strokec4 ;\cb1 \
\cb10         \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4 (i % \cf11 \strokec11 3\cf4 \strokec4  === \cf11 \strokec11 0\cf4 \strokec4 ) result[i-\cf11 \strokec11 1\cf4 \strokec4 ] = \cf20 \strokec20 'Fizz'\cf4 \strokec4 ;\cb1 \
\cb10         \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4 (i % \cf11 \strokec11 5\cf4 \strokec4  === \cf11 \strokec11 0\cf4 \strokec4 ) result[i-\cf11 \strokec11 1\cf4 \strokec4 ] = \cf20 \strokec20 'Buzz'\cf4 \strokec4 ;\cb1 \
\cb10         \cf6 \strokec6 else\cf4 \strokec4  result[i-\cf11 \strokec11 1\cf4 \strokec4 ] = i.toString();\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseList = head => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  prev = \cf6 \strokec6 null\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4 (head) \{\cb1 \
\cb10         \cf6 \strokec6 let\cf4 \strokec4  temp = head.next;\cb1 \
\cb10         head.next = prev;\cb1 \
\cb10         prev = head;\cb1 \
\cb10         head = temp;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  prev;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Delete Node in Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  deleteNode = node => \{\cb1 \
\cb10     node.val = node.next.val;\cb1 \
\cb10     node.next = node.next.next;\cb1 \
\cb10 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Merge Two Sorted Lists
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  1->2->4, 1->3->4\

\f0\b Output:
\f1\b0  1->1->2->3->4->4\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \strokec4 /**\
 * Definition for singly-linked list.\
 * function ListNode(val, next) \{\
 *     this.val = (val===undefined ? 0 : val)\
 *     this.next = (next===undefined ? null : next)\
 * \}\
 */\
/**\
 * @param \{ListNode\} l1\
 * @param \{ListNode\} l2\
 * @return \{ListNode\}\
 */\outl0\strokewidth0 \
\
\cf6 const\cf4  mergeTwoLists = (l1, l2) => \{\cb1 \
\cb5     \cf6 let\cf4  list = \cf6 new\cf4  \cf9 ListNode\cf4 ()\cb1 \
\cb5     \cf6 let\cf4  head = list\cb1 \
\cb5     \cb1 \
\cb5     \cf6 while\cf4  (l1 !== \cf6 null\cf4  && l2 !== \cf6 null\cf4 ) \{\cb1 \
\cb5 \'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf12 // Select the smallest value from either linked list,\cf4 \cb1 \
\cb5 \'a0\'a0\'a0\'a0\cf12 // then increment that list forward.\cf4 \cb1 \
\cb5         \cf6 if\cf4  (l1.val < l2.val) \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l1.val)\cb1 \
\cb5             l1 = l1.next\cb1 \
\cb5         \} \cf6 else\cf4  \{\cb1 \
\cb5             list.next = \cf6 new\cf4  \cf9 ListNode\cf4 (l2.val)\cb1 \
\cb5             l2 = l2.next\cb1 \
\cb5         \}\cb1 \
\cb5         \cb1 \
\cb5         list = list.next\cb1 \
\cb5     \}\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf12 // It's possible that one linked list is shorter than the other so we just\cf4 \cb1 \
\cb5 \'a0\'a0\cf12 // add on the remainder of the last linked list. It's already sorted :)\cf4 \cb1 \
\cb5     \cf6 if\cf4  (l1 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l1\cb1 \
\cb5     \cf6 if\cf4  (l2 !== \cf6 null\cf4 )\cb1 \
\cb5         list.next = l2\cb1 \
\cb5     \cb1 \
\cb5 \'a0\'a0\cf12 // return .next because this first element in the linkedlist is empty\cf4 \cb1 \
\cb5     \cf6 return\cf4  head.next\cb1 \
\cb5 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Majority Element
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an array of size\'a0
\f5\i n
\f3\i0 , find the majority element. The majority element is the element that appears\'a0
\f6\b more than
\f3\b0 \'a0
\f1\fs26 \cf18 \cb19 \strokec18 \uc0\u8970 
\f4  n/2 
\f1 \uc0\u8971 
\f3\fs28 \cf17 \cb3 \strokec17 \'a0times.\
You may assume that the array is non-empty and the majority element always exist in the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [3,2,3]\

\f0\b Output:
\f1\b0  3\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  majorityElement = nums => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  hash = \{\}\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  max = \cf11 \strokec11 0\cf4 \strokec4 , val\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < nums.length; i++)\{\cb1 \
\cb10         hash[nums[i]] ? hash[nums[i]]++ : hash[nums[i]] = \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (hash[nums[i]] > max)\{\cb1 \
\cb10             max = hash[nums[i]]\cb1 \
\cb10             val = nums[i]\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  val\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Move Zeroes
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 , write a function to move all\'a0
\f4\fs26 \cf18 \cb19 \strokec18 0
\f3\fs28 \cf17 \cb3 \strokec17 's to the end of it while maintaining the relative order of the non-zero elements.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [0,1,0,3,12]\

\f0\b Output:
\f1\b0  [1,3,12,0,0]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  moveZeroes = nums => \{\cb1 \
\cb10   \cf6 \strokec6 var\cf4 \strokec4  idx = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 var\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < nums.length; i++) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (nums[i] !== \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10       nums[idx] = nums[i];\cb1 \
\cb10       nums[i] = idx === i ? nums[i] : \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10       idx++;\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Anagram 2
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 var\cf4 \strokec4  isAnagram = \cf6 \strokec6 function\cf4 \strokec4 (s, t) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (s.length !== t.length) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  map = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Map\cf4 \strokec4 ();\cb1 \
\cb10     \cb1 \
\cb10     s.split(\cf20 \strokec20 ''\cf4 \strokec4 ).map((char, i) => \{\cb1 \
\cb10         \cf22 \strokec22 // record character occurrences in s\cf4 \cb1 \strokec4 \
\cb10         map.\cf6 \strokec6 set\cf4 \strokec4 (char, map.has(char) ? map.\cf6 \strokec6 get\cf4 \strokec4 (char) + \cf11 \strokec11 1\cf4 \strokec4  : \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10         \cf22 \strokec22 // at the same time subtract the character occurrences from t\cf4 \cb1 \strokec4 \
\cb10         map.\cf6 \strokec6 set\cf4 \strokec4 (t[i], map.has(t[i]) ? map.\cf6 \strokec6 get\cf4 \strokec4 (t[i]) - \cf11 \strokec11 1\cf4 \strokec4  : -\cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10     \});\cb1 \
\cb10     \cb1 \
\cb10     \cf22 \strokec22 // for an anagram, final count should be 0\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Array\cf4 \strokec4 .\cf6 \strokec6 from\cf4 \strokec4 (map.values()).reduce((acc, cur) => acc && cur === \cf11 \strokec11 0\cf4 \strokec4 , \cf6 \strokec6 true\cf4 \strokec4 );\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 \outl0\strokewidth0 // Contains Duplicate
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  containsDuplicate = nums => \{\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  nums.length !== \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Set\cf4 \strokec4 (nums).size\cb1 \
\cb10 \};\cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Roman to Integer
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Roman numerals are represented by seven different symbols:\'a0
\f4\fs26 \cf18 \cb19 \strokec18 I
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 V
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 X
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 L
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 C
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 D
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 M
\f3\fs28 \cf17 \cb3 \strokec17 .\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Symbol
\f1\b0        
\f0\b Value
\f1\b0 \
I             1\
V             5\
X             10\
L             50\
C             100\
D             500\
M             1000\
\pard\pardeftab720\sa280\partightenfactor0

\f3\fs28 \cf17 \cb3 For example,\'a0two is written as\'a0
\f4\fs26 \cf18 \cb19 \strokec18 II
\f3\fs28 \cf17 \cb3 \strokec17 \'a0in Roman numeral, just two one's added together. Twelve is written as,\'a0
\f4\fs26 \cf18 \cb19 \strokec18 XII
\f3\fs28 \cf17 \cb3 \strokec17 , which is simply\'a0
\f4\fs26 \cf18 \cb19 \strokec18 X
\f3\fs28 \cf17 \cb3 \strokec17 \'a0+\'a0
\f4\fs26 \cf18 \cb19 \strokec18 II
\f3\fs28 \cf17 \cb3 \strokec17 . The number twenty seven is written as\'a0
\f4\fs26 \cf18 \cb19 \strokec18 XXVII
\f3\fs28 \cf17 \cb3 \strokec17 , which is\'a0
\f4\fs26 \cf18 \cb19 \strokec18 XX
\f3\fs28 \cf17 \cb3 \strokec17 \'a0+\'a0
\f4\fs26 \cf18 \cb19 \strokec18 V
\f3\fs28 \cf17 \cb3 \strokec17 \'a0+\'a0
\f4\fs26 \cf18 \cb19 \strokec18 II
\f3\fs28 \cf17 \cb3 \strokec17 .\
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not\'a0
\f4\fs26 \cf18 \cb19 \strokec18 IIII
\f3\fs28 \cf17 \cb3 \strokec17 . Instead, the number four is written as\'a0
\f4\fs26 \cf18 \cb19 \strokec18 IV
\f3\fs28 \cf17 \cb3 \strokec17 . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as\'a0
\f4\fs26 \cf18 \cb19 \strokec18 IX
\f3\fs28 \cf17 \cb3 \strokec17 . There are six instances where subtraction is used:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0
\f4\fs26 \cf18 \cb19 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec18 I
\f3\fs28 \cf17 \cb3 \strokec17 \'a0can be placed before\'a0
\f4\fs26 \cf18 \cb19 \strokec18 V
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(5) and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 X
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(10) to make 4 and 9.\'a0\cb1 \
\ls6\ilvl0
\f4\fs26 \cf18 \cb19 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec18 X
\f3\fs28 \cf17 \cb3 \strokec17 \'a0can be placed before\'a0
\f4\fs26 \cf18 \cb19 \strokec18 L
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(50) and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 C
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(100) to make 40 and 90.\'a0\cb1 \
\ls6\ilvl0
\f4\fs26 \cf18 \cb19 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec18 C
\f3\fs28 \cf17 \cb3 \strokec17 \'a0can be placed before\'a0
\f4\fs26 \cf18 \cb19 \strokec18 D
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(500) and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 M
\f3\fs28 \cf17 \cb3 \strokec17 \'a0(1000) to make 400 and 900.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0 \'a0"III"\

\f0\b Output:
\f1\b0  3\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  romanToInt = str => \{\cb1 \
\cb10   \cf6 \strokec6 if\cf4 \strokec4  (!str || str.length === \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10   \}\cb1 \
\
\cb10   \cf6 \strokec6 const\cf4 \strokec4  map = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Map\cf4 \strokec4 ([[\cf20 \strokec20 'I'\cf4 \strokec4 , \cf11 \strokec11 1\cf4 \strokec4 ], [\cf20 \strokec20 'V'\cf4 \strokec4 , \cf11 \strokec11 5\cf4 \strokec4 ], [\cf20 \strokec20 'X'\cf4 \strokec4 , \cf11 \strokec11 10\cf4 \strokec4 ], [\cf20 \strokec20 'L'\cf4 \strokec4 , \cf11 \strokec11 50\cf4 \strokec4 ], [\cf20 \strokec20 'C'\cf4 \strokec4 , \cf11 \strokec11 100\cf4 \strokec4 ], [\cf20 \strokec20 'D'\cf4 \strokec4 , \cf11 \strokec11 500\cf4 \strokec4 ], [\cf20 \strokec20 'M'\cf4 \strokec4 , \cf11 \strokec11 1000\cf4 \strokec4 ]]);\cb1 \
\
\cb10   \cf6 \strokec6 let\cf4 \strokec4  i = str.length - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  result = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i]);\cb1 \
\
\cb10   \cf6 \strokec6 while\cf4 \strokec4  (i > \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  curr = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i]);\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  prev = map.\cf6 \strokec6 get\cf4 \strokec4 (str[i - \cf11 \strokec11 1\cf4 \strokec4 ]);\cb1 \
\
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (prev >= curr) \{\cb1 \
\cb10       result += prev;\cb1 \
\cb10     \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10       result -= prev;\cb1 \
\cb10     \}\cb1 \
\
\cb10     i--;\cb1 \
\cb10   \}\cb1 \
\
\cb10   \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Excel Sheet Column Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a column title as appear in an Excel sheet, return its corresponding column number.\
For example:\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19     A -> 1\
    B -> 2\
    C -> 3\
    ...\
    Z -> 26\
    AA -> 27\
    AB -> 28 \
    ...\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  "A"\

\f0\b Output:
\f1\b0  1\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input: 
\f1\b0 "AB"\

\f0\b Output:
\f1\b0  28\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  titleToNumber = str => \{\cb1 \
\cb10   \cf6 \strokec6 const\cf4 \strokec4  letterToNumber = char => char.charCodeAt(\cf11 \strokec11 0\cf4 \strokec4 ) - \cf11 \strokec11 64\cf4 \strokec4 ;\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  [...str]\cb1 \
\cb10     .reverse()\cb1 \
\cb10     .map((char, i) => letterToNumber(char) * \cf13 \strokec13 Math\cf4 \strokec4 .pow(\cf11 \strokec11 26\cf4 \strokec4 , i))\cb1 \
\cb10     .reduce((acc, cur) => acc + cur, \cf11 \strokec11 0\cf4 \strokec4 );\cb1 \
\cb10 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // First Unique Character
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Examples:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19 s = "leetcode"\
return 0.\
\
s = "loveleetcode",\
return 2.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  firstUniqChar = str => \{\cb1 \
\cb10    \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \cb5 \outl0\strokewidth0 let\cf4 \cb10 \outl0\strokewidth0 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < str.length; i++)\{\cb1 \
\cb10        \cf6 \strokec6 if\cf4 \strokec4  (str.indexOf(str[i]) === str.lastIndexOf(str[i]))\{\cb1 \
\cb10           \cf6 \strokec6 return\cf4 \strokec4  i;\cb1 \
\cb10       \} \cb1 \
\cb10    \}\cb1 \
\cb10    \cf6 \strokec6 return\cf4 \strokec4  -\cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Pascal\'92s Triangle
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given a non-negative integer\'a0
\f5\i numRows
\f3\i0 , generate the first\'a0
\f5\i numRows
\f3\i0 \'a0of Pascal's triangle.\
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb1 \pard\pardeftab720\sa280\partightenfactor0
\cf17 \uc0\u8232 
\fs22\fsmilli11200 \cb3 In Pascal's triangle, each number is the sum of the two numbers directly above it.
\fs28 \
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  5\

\f0\b Output:
\f1\b0 \
[\
     [1],\
    [1,1],\
   [1,2,1],\
  [1,3,3,1],\
 [1,4,6,4,1]\
]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  generate = numRows => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (numRows === \cf11 \strokec11 0\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  [];\cb1 \
\
\cb10     \cf6 \strokec6 const\cf4 \strokec4  result = [];\cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < numRows; i++) \{\cb1 \
\cb10         \cf6 \strokec6 let\cf4 \strokec4  currRow = [];\cb1 \
\cb10         \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  j = \cf11 \strokec11 0\cf4 \strokec4 ; j <= i; j++) \{\cb1 \
\cb10             \cf6 \strokec6 if\cf4 \strokec4  (j === \cf11 \strokec11 0\cf4 \strokec4  || j === i)\{\cb1 \
\cb10                 currRow.push(\cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10             \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10                 currRow.push(result[i - \cf11 \strokec11 1\cf4 \strokec4 ][j - \cf11 \strokec11 1\cf4 \strokec4 ] + result[i - \cf11 \strokec11 1\cf4 \strokec4 ][j]);\cb1 \
\cb10             \}\cb1 \
\cb10         \}\cb1 \
\cb10         result.push(currRow);\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Missing Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an array containing\'a0
\f5\i n
\f3\i0 \'a0distinct numbers taken from\'a0
\f4\fs26 \cf18 \cb19 \strokec18 0, 1, 2, ..., n
\f3\fs28 \cf17 \cb3 \strokec17 , find the one that is missing from the array.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [3,0,1]\

\f0\b Output:
\f1\b0  2\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  [9,6,4,2,3,5,7,0,1]\

\f0\b Output:
\f1\b0  8\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  missingNumber = nums => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  numsLength = nums.length;\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  expectedSum = (numsLength * (numsLength + \cf11 \strokec11 1\cf4 \strokec4 )) / \cf11 \strokec11 2\cf4 \strokec4 ;\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  sum = nums.reduce((acc, cur) => acc += cur, \cf11 \strokec11 0\cf4 \strokec4 );\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  expectedSum - sum;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Intersection of Two Arrays
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two arrays, write a function to compute their intersection.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input: 
\f1\b0 nums1 = [1,2,2,1], nums2 = [2,2]\

\f0\b Output: 
\f1\b0 [2,2]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input: 
\f1\b0 nums1 = [4,9,5], nums2 = [9,4,9,8,4]\

\f0\b Output: 
\f1\b0 [4,9]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  intersect = (nums1, nums2) => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  hash = \{\}, result = []\cb1 \
\cb10     \cb1 \
\cb10     nums2.forEach(num => \{\cb1 \
\cb10         hash[num] ? hash[num]++ : hash[num] = \cf11 \strokec11 1\cf4 \cb1 \strokec4 \
\cb10     \})\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < nums1.length; i++)\{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (hash[nums1[i]] > \cf11 \strokec11 0\cf4 \strokec4 )\{\cb1 \
\cb10             result.push(nums1[i])\cb1 \
\cb10             hash[nums1[i]]--\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  result\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Happy Number
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Write an algorithm to determine if a number\'a0
\f4\fs26 \cf18 \cb19 \strokec18 n
\f3\fs28 \cf17 \cb3 \strokec17 \'a0is "happy".\
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it\'a0
\f6\b loops endlessly in a cycle
\f3\b0 \'a0which does not include 1. Those numbers for which this process\'a0
\f6\b ends in 1
\f3\b0 \'a0are happy numbers.\
Return True if\'a0
\f4\fs26 \cf18 \cb19 \strokec18 n
\f3\fs28 \cf17 \cb3 \strokec17 \'a0is a happy number, and False if not.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:\'a0
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  19\

\f0\b Output:
\f1\b0  true\

\f0\b Explanation: \

\f1\b0 1
\fs19\fsmilli9750 2
\fs26  + 9
\fs19\fsmilli9750 2
\fs26  = 82\
8
\fs19\fsmilli9750 2
\fs26  + 2
\fs19\fsmilli9750 2
\fs26  = 68\
6
\fs19\fsmilli9750 2
\fs26  + 8
\fs19\fsmilli9750 2
\fs26  = 100\
1
\fs19\fsmilli9750 2
\fs26  + 0
\fs19\fsmilli9750 2
\fs26  + 0
\fs19\fsmilli9750 2
\fs26  = 1\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isHappy = num => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  seen = \{\}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4  (num != \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (num \cf6 \strokec6 in\cf4 \strokec4  seen) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4  \cb1 \
\cb10         \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10             seen[num] = num\cb1 \
\cb10             num = num.toString().split(\cf20 \strokec20 ''\cf4 \strokec4 ).reduce((acc, cur) => acc + (cur * cur), \cf11 \strokec11 0\cf4 \strokec4 )\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4  \cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Number of 1 Bits (Hamming Weight)
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Write a function that takes an unsigned integer and return\'a0the number of '1'\'a0bits it has (also known as the\'a0{\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Hamming_weight"}}{\fldrslt \cf21 \strokec21 Hamming weight}}).\
\'a0\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  00000000000000000000000000001011\

\f0\b Output:
\f1\b0  3\

\f0\b Explanation: 
\f1\b0 The input binary string 
\f0\b 00000000000000000000000000001011
\f1\b0 \'a0has a total of three '1' bits.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  hammingWeight = num => \{\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  num.toString(\cf11 \strokec11 2\cf4 \strokec4 ).replace(\cf24 \strokec24 /0/\cf6 \strokec6 g\cf4 \strokec4 , \cf20 \strokec20 ''\cf4 \strokec4 ).length;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Power of 3
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isPowerOfThree = num => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (num <= \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (num === \cf11 \strokec11 1\cf4 \strokec4 ) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4  (num % \cf11 \strokec11 3\cf4 \strokec4  === \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10         num /= \cf11 \strokec11 3\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  num === \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Linked List Cycle
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  hasCycle = head => \{\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  fast = head;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  slow = head;\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 while\cf4 \strokec4  (fast && fast.next) \{\cb1 \
\cb10     fast = fast.next.next;\cb1 \
\cb10     slow = slow.next;\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (fast === slow) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Palindrome Linked List
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  isPalindrome = head => \{\cb1 \
\cb5     \cf6 let\cf4  fast = head;\
	\cf6 \cb5 let \cf4 \cb5 slow = head;\
	\cf6 \cb5 let \cf4 \cb5 last = \cf6 null\cf4 ;\
\cb1 \
\cb5     \cf6 while\cf4 (fast && fast.next) [fast, slow] = [fast.next.next, slow.next]; \cf12 // get middle node\cf4 \cb1 \
\cb5     \cf6 while\cf4 (slow) [slow.next, last, slow] = [last, slow, slow.next]; \cf12 //reverse right half link list\cf4 \cb1 \
\cb5     \cf6 while\cf4 (last && last.val === head.val) [last, head] = [last.next, head.next]; \cf12 // check \cf4 \cb1 \
\cb5     \cf6 return\cf4  !last;\cb1 \
\cb5 \}\cb1 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Intersection of Two Linked Lists
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  getIntersectionNode = (headA, headB) => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (!headA || !headB) \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 null\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 var\cf4 \strokec4  curA = headA;\cb1 \
\cb10     \cf6 \strokec6 var\cf4 \strokec4  curB = headB;\cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4  (curA != curB) \{\cb1 \
\cb10         curA = curA == \cf6 \strokec6 null\cf4 \strokec4  ? headB : curA.next;\cb1 \
\cb10         curB = curB == \cf6 \strokec6 null\cf4 \strokec4  ? headA : curB.next;\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  curA;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Count Primes
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  countPrimes = num => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  hash = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Array\cf4 \strokec4 (num).fill(\cf6 \strokec6 true\cf4 \strokec4 );\cb1 \
\cb10     hash[\cf11 \strokec11 0\cf4 \strokec4 ] = \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     hash[\cf11 \strokec11 1\cf4 \strokec4 ] = \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 2\cf4 \strokec4 ; i*i < num; i++) \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (hash[i]) \{\cb1 \
\cb10             \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  j=i*i; j < num; j+=i)\{\cb1 \
\cb10                 hash[j] = \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10             \}\cb1 \
\cb10         \}\cb1 \
\cb10     \}\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  hash.filter((val)=>val).length;\cb1 \
\cb10 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Palindrome
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  isPalindrome = str => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (str === \cf20 \strokec20 ""\cf4 \strokec4 ) \{\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf22 \strokec22 // 1. Remove non-alphanumeric chars from the string\cf4 \cb1 \strokec4 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  alphanum = str.toLowerCase().replace(\cf24 \strokec24 /[\\W]/\cf6 \strokec6 g\cf4 \strokec4 , \cf20 \strokec20 ""\cf4 \strokec4 );\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  front = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  back = alphanum.length - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4  (front < back) \{\cb1 \
\cb10         \cf6 \strokec6 const\cf4 \strokec4  frontChar = alphanum[front];\cb1 \
\cb10         \cf6 \strokec6 const\cf4 \strokec4  backChar = alphanum[back];\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4  (frontChar != backChar) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10         \}\cb1 \
\cb10         front++;\cb1 \
\cb10         back--;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Valid Palindrome II
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  validPalindrome = (str, corrections = \cf11 \strokec11 1\cf4 \strokec4 ) => \{\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  front = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  back = str.length - \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 while\cf4 \strokec4  (front < back) \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (str[front] === str[back]) \{\cb1 \
\cb10       front++;\cb1 \
\cb10       back--;\cb1 \
\cb10       \cf6 \strokec6 continue\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (corrections === \cf11 \strokec11 0\cf4 \strokec4 ) \{\cb1 \
\cb10       \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 false\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  validPalindrome(str.slice(front, back), \cf11 \strokec11 0\cf4 \strokec4 ) \cb1 \
\cb10       || validPalindrome(str.slice(front + \cf11 \strokec11 1\cf4 \strokec4 , back + \cf11 \strokec11 1\cf4 \strokec4 ), \cf11 \strokec11 0\cf4 \strokec4 );\cb1 \
\cb10   \}\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  \cf6 \strokec6 true\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Reverse Bits
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  reverseBits = num => \{\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  ret = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\
\cb10   \cf6 \strokec6 while\cf4 \strokec4 (num)\{\cb1 \
\cb10       i++;\cb1 \
\cb10       ret = (ret<<\cf11 \strokec11 1\cf4 \strokec4 ) | (num&\cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10       num=(num>>>\cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10   \}\cb1 \
\cb10   \cb1 \
\cb10   \cf6 \strokec6 if\cf4 \strokec4 (i<\cf11 \strokec11 32\cf4 \strokec4 )\{\cb1 \
\cb10       ret = ret << (\cf11 \strokec11 32\cf4 \strokec4 -i);\cb1 \
\cb10   \}\cb1 \
\
\cb10   \cf6 \strokec6 return\cf4 \strokec4  ret >>> \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Factorial Trailing Zeroes
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an integer\'a0
\f5\i n
\f3\i0 , return the number of trailing zeroes in\'a0
\f5\i n
\f3\i0 !.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  3\

\f0\b Output:
\f1\b0  0\

\f0\b Explanation:
\f1\b0 \'a03! = 6, no trailing zero.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  5\

\f0\b Output:
\f1\b0  1\

\f0\b Explanation:
\f1\b0 \'a05! = 120, one trailing zero.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  trailingZeroes = num => \{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (num < \cf11 \strokec11 5\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  \cf13 \strokec13 Math\cf4 \strokec4 .floor(num / \cf11 \strokec11 5\cf4 \strokec4 ) + trailingZeroes(num / \cf11 \strokec11 5\cf4 \strokec4 );\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Rotate Array
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given an array, rotate the array to the right by\'a0
\f5\i k
\f3\i0 \'a0steps, where\'a0
\f5\i k
\f3\i0 \'a0is non-negative.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  nums = [1,2,3,4,5,6,7], k = 3\

\f0\b Output:
\f1\b0  [5,6,7,1,2,3,4]\

\f0\b Explanation:
\f1\b0 \
rotate 1 steps to the right: [7,1,2,3,4,5,6]\
rotate 2 steps to the right: [6,7,1,2,3,4,5]\
rotate 3 steps to the right: [5,6,7,1,2,3,4]\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  nums = [-1,-100,3,99], k = 2\

\f0\b Output:
\f1\b0  [3,99,-1,-100]\

\f0\b Explanation:
\f1\b0  \
rotate 1 steps to the right: [99,-1,-100,3]\
rotate 2 steps to the right: [3,99,-1,-100]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  rotate = (nums, k) => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  length = nums.length;\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  result = [...nums];\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 for\cf4 \strokec4  (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < length; i++) \{\cb1 \
\cb10         \cf6 \strokec6 let\cf4 \strokec4  index = (i + k) % length;\cb1 \
\cb10         nums[index] = result[i];\cb1 \
\cb10     \};\cb1 \
\
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Binary Tree InOrder Traversal
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  inOrderTraversal = (root, result = []) => \{\cb1 \
\cb10   \cf6 \strokec6 if\cf4 \strokec4  (root) \{    \cb1 \
\cb10     inOrderTraversal(root.left, result);\cb1 \
\cb10     result.push(root.val);\cb1 \
\cb10     inOrderTraversal(root.right, result);\cb1 \
\cb10   \}\cb1 \
\cb10     \cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  result;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Get Sum (Cannot use + or -)
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  getSum = (num1, num2) => \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  carry;\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 while\cf4 \strokec4 (num2) \{\cb1 \
\cb10         carry = num1 & num2;\cb1 \
\cb10         num1 ^= num2;\cb1 \
\cb10         num2 = carry << \cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\cb10     \}\cb1 \
\cb10     \cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  num1;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Backspace String Compare
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two\'a0strings\'a0
\f4\fs26 \cf18 \cb19 \strokec18 S
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 T
\f3\fs28 \cf17 \cb3 \strokec17 ,\'a0return if they are equal when both are typed into empty text editors.\'a0
\f4\fs26 \cf18 \cb19 \strokec18 #
\f3\fs28 \cf17 \cb3 \strokec17 \'a0means a backspace character.\
Note that after\'a0backspacing an empty text, the text will continue empty.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \cb1 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input: 
\f1\b0 S = "ab#c", T = "ad#c"\

\f0\b Output: 
\f1\b0 true\

\f0\b Explanation
\f1\b0 : Both S and T become "ac".\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  backspaceCompare = (\cf13 \strokec13 S\cf4 \strokec4 , \cf13 \strokec13 T\cf4 \strokec4 ) => \{\cb1 \
\cb10     \cf6 \strokec6 const\cf4 \strokec4  buildString = str => \cf13 \strokec13 Array\cf4 \strokec4 .\cf6 \strokec6 from\cf4 \strokec4 (str).reduce((acc, cur) => \{\cb1 \
\cb10         \cf6 \strokec6 if\cf4 \strokec4 (cur === \cf20 \strokec20 '#'\cf4 \strokec4 ) \{\cb1 \
\cb10             \cf6 \strokec6 return\cf4 \strokec4  acc.slice(\cf11 \strokec11 0\cf4 \strokec4 , acc.length - \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10         \}\cb1 \
\cb10         \cf6 \strokec6 return\cf4 \strokec4  [...acc, cur];\cb1 \
\cb10     \}, []).join(\cf20 \strokec20 ''\cf4 \strokec4 );\
\cb1 \
\cb10     \cf6 \strokec6 return\cf4 \strokec4  buildString(\cf13 \strokec13 S\cf4 \strokec4 ) === buildString(\cf13 \strokec13 T\cf4 \strokec4 )\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find Peak Element\
\pard\pardeftab720\sa280\partightenfactor0

\f3\b0 \cf17 \outl0\strokewidth0 \strokec17 A peak element is an element that is greater than its neighbors.\
Given an input array\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 , where\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums[i] \uc0\u8800  nums[i+1]
\f3\fs28 \cf17 \cb3 \strokec17 , find a peak element and return its index.\
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\
You may imagine that\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums[-1] = nums[n] = -\uc0\u8734 
\f3\fs28 \cf17 \cb3 \strokec17 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example 1:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  
\f0\b nums
\f1\b0  = [1,2,3,1]\

\f0\b Output:
\f1\b0  2\

\f0\b Explanation:
\f1\b0  3 is a peak element and your function should return the index number 2.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Example 2:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 Input:
\f1\b0  
\f0\b nums
\f1\b0  = [1,2,1,3,5,6,4]\

\f0\b Output:
\f1\b0  1 or 5 \

\f0\b Explanation:
\f1\b0  Your function can return either index number 1 where the peak element is 2, \
\'a0            or index number 5 where the peak element is 6.\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b\fs28 \cf17 \cb3 Follow up:
\f3\b0 \'a0Your solution should be in logarithmic complexity.
\f1 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  findPeakElement = nums => \{\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  left = \cf11 \strokec11 0\cf4 \strokec4 ;\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  right = nums.length -\cf11 \strokec11 1\cf4 \strokec4 ;\cb1 \
\
\cb10   \cf6 \strokec6 while\cf4 \strokec4 (left + \cf11 \strokec11 1\cf4 \strokec4 < right) \{\cb1 \
\cb10     \cf6 \strokec6 let\cf4 \strokec4  middle = \cf13 \strokec13 Math\cf4 \strokec4 .floor(left + (right-left)/\cf11 \strokec11 2\cf4 \strokec4 );\cb1 \
\
\cb10     \cf6 \strokec6 if\cf4 \strokec4  (nums[middle] > nums[middle-\cf11 \strokec11 1\cf4 \strokec4 ] \cb1 \
\cb10       && nums[middle] > nums[middle+\cf11 \strokec11 1\cf4 \strokec4 ] ) \cb1 \
\cb10     \{\cb1 \
\cb10       \cf6 \strokec6 return\cf4 \strokec4  middle;\cb1 \
\cb10     \} \cf6 \strokec6 else\cf4 \strokec4  \cf6 \strokec6 if\cf4 \strokec4  (nums[middle] > nums[middle-\cf11 \strokec11 1\cf4 \strokec4 ]) \{\cb1 \
\cb10       left = middle;\cb1 \
\cb10     \} \cf6 \strokec6 else\cf4 \strokec4  \{\cb1 \
\cb10       right = middle;\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 return\cf4 \strokec4  nums[left] > nums[right] ? left : right;\cb1 \
\cb10 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Find the Difference
\f1\b0 \cf4 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two strings\'a0
\f8\i\b s
\f3\i0\b0 \'a0and\'a0
\f8\i\b t
\f3\i0\b0 \'a0which consist of only lowercase letters.\
String\'a0
\f8\i\b t
\f3\i0\b0 \'a0is generated by random shuffling string\'a0
\f8\i\b s
\f3\i0\b0 \'a0and then add one more letter at a random position.\
Find the letter that was added in\'a0
\f8\i\b t
\f3\i0\b0 .\
\pard\pardeftab720\sa280\partightenfactor0

\f6\b \cf17 Example:
\f3\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs26 \cf17 \cb19 Input:\
s = "abcd"\
t = "abcde"\
\
Output:\
e\
\
Explanation:\
'e' is the letter that was added.\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf4 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb10 \outl0\strokewidth0 \strokec6 const\cf4 \strokec4  findTheDifference = (s, t) => \{\cb1 \
\cb10   \cf6 \strokec6 let\cf4 \strokec4  map = \cf6 \strokec6 new\cf4 \strokec4  \cf13 \strokec13 Map\cf4 \strokec4 ();\cb1 \
\
\cb10   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < t.length; i++)\{\cb1 \
\cb10     map.\cf6 \strokec6 set\cf4 \strokec4 (t[i], (map.\cf6 \strokec6 get\cf4 \strokec4 (t[i]) || \cf11 \strokec11 0\cf4 \strokec4 ) + \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  i = \cf11 \strokec11 0\cf4 \strokec4 ; i < s.length; i++)\{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4 (map.\cf6 \strokec6 get\cf4 \strokec4 (s[i])) \{\cb1 \
\cb10     map.\cf6 \strokec6 set\cf4 \strokec4 (s[i], (map.\cf6 \strokec6 get\cf4 \strokec4 (s[i])) - \cf11 \strokec11 1\cf4 \strokec4 );\cb1 \
\cb10     \}\cb1 \
\cb10   \}\cb1 \
\cb10   \cf6 \strokec6 for\cf4 \strokec4 (\cf6 \strokec6 let\cf4 \strokec4  [key, val] \cf6 \strokec6 of\cf4 \strokec4  map)\{\cb1 \
\cb10     \cf6 \strokec6 if\cf4 \strokec4 (val === \cf11 \strokec11 1\cf4 \strokec4 ) \cf6 \strokec6 return\cf4 \strokec4  key;\cb1 \
\cb10   \}\cb1 \
\cb10 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \cb3 // Coming Soon
\f1\b0 \cf4 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 const\cf4  functionName = () => \{\cb1 \
\
\cb5 \};\cb1 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \outl0\strokewidth0 \
}