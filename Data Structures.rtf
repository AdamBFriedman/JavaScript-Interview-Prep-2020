{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica;
\f3\fmodern\fcharset0 Courier;\f4\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red14\green110\blue109;\red19\green120\blue72;\red255\green255\blue254;\red154\green154\blue154;
\red0\green0\blue255;\red0\green0\blue255;\red255\green255\blue254;\red49\green49\blue50;\red14\green110\blue109;
\red191\green28\blue37;\red19\green120\blue72;\red49\green49\blue50;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;
\cssrgb\c1680\c19835\c100000;\cssrgb\c1680\c19835\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c25098\c25098\c25490;\cssrgb\c0\c50196\c50196;
\cssrgb\c80392\c19216\c19216;\cssrgb\c3529\c53333\c35294;\cssrgb\c25098\c25098\c25490;\cssrgb\c0\c0\c0\c83922;}
\margl1440\margr1440\vieww15720\viewh17380\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// STACK (LIFO)\

\f1\b0\fs28 \cf4 \
\cf5 class\cf4  \cf6 Stack\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .storage = \{\}\
    \cf5 this\cf4 .size = \cf7 0\cf4 \
  \}\
\
  push(element) \{\
    \cf5 this\cf4 .size++\
    \cf5 this\cf4 .storage[\cf5 this\cf4 .size] = element\
  \}\
\
  pop() \{\
	if (this.size === 0) return undefined\
    \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
    \cf5 this\cf4 .size--\
    \cf5 return\cf4  removed\
  \}\
\
  peek() \{\
    \cf5 return\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .size]\
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// QUEUE (FIFO)
\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb8 \expnd0\expndtw0\kerning0
class\cf4  \cf6 Queue\cf4  \{\cb1 \
\cb8   \cf5 constructor\cf4 () \{\cb1 \
\cb8     \cf5 this\cf4 .storage = \{\}\cb1 \
\cb8     \cf5 this\cf4 .head = \cf7 0\cf4 \cb1 \
\cb8     \cf5 this\cf4 .tail = \cf7 0\cf4 \cb1 \
\cb8   \}\cb1 \
\
\cb8   enqueue(element) \{\cb1 \
\cb8     \cf5 this\cf4 .storage[\cf5 this\cf4 .tail] = element\cb1 \
\cb8     \cf5 this\cf4 .tail++\cb1 \
\cb8   \}\cb1 \
\
\cb8   dequeue() \{\cb1 \
\cb8     \cf5 let\cf4  removed = \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 delete\cf4  \cf5 this\cf4 .storage[\cf5 this\cf4 .head]\cb1 \
\cb8     \cf5 this\cf4 .head++\cb1 \
\cb8     \cf5 return\cf4  removed\cb1 \
\cb8   \}\cb1 \
\cb8 \}\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \cb3 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// Priority Queue (FIFO)
\f2\b0 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 function PriorityQueue () \{\
    var collection = [];\
    this.printCollection = function() \{\
      (console.log(collection));\
    \};\
    this.enqueue = function(element)\{\
        if (this.isEmpty())\{ \
            collection.push(element);\
        \} else \{\
            var added = false;\
            for (var i=0; i<collection.length; i++)\{\
                 if (element[1] < collection[i][1])\{ //checking priorities\
                    collection.splice(i,0,element);\
                    added = true;\
                    break;\
                \}\
            \}\
            if (!added)\{\
                collection.push(element);\
            \}\
        \}\
    \};\
    this.dequeue = function() \{\
        var value = collection.shift();\
        return value[0];\
    \};\
    this.front = function() \{\
        return collection[0];\
    \};\
    this.size = function() \{\
        return collection.length; \
    \};\
    this.isEmpty = function() \{\
        return (collection.length === 0); \
    \};\
\}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// DOUBLY LINKED LIST
\f1\b0\fs28 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 class\cf4  \cf6 LinkedList\cf4  \{\
  \cf5 constructor\cf4  () \{\
    \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
  \}\
\
  \cf9 // add to the end of the list / tail\cf4 \
  append(value) \{\
    \cf9 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldTail = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldTail.next = \cf5 this\cf4 .tail\
      \cf5 this\cf4 .tail.prev = oldTail\
    \}\
  \}\
\
  \cf9 //add to beginning of list / head\cf4 \
  prepend(value) \{\
    \cf9 // if list is empty\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  oldHead = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head = \cf5 new\cf4  \cf6 Node\cf4 (value)\
      oldHead.prev = \cf5 this\cf4 .head\
      \cf5 this\cf4 .head.next = oldHead\
    \}\
  \}\
\
  deleteHead() \{\
    \cf9 // if list is empty (no head)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .head) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf9 // if linkedlist has >= 1 node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedHead = \cf5 this\cf4 .head\
      \cf9 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .tail = \cf5 null\cf4 \
      \}\
      \cf9 //if list has >1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .head = \cf5 this\cf4 .head.next\
        \cf5 this\cf4 .head.prev = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedHead.value\
    \}\
  \}\
\
  deleteTail() \{\
    \cf9 // if list is empty (no tail)\cf4 \
    \cf5 if\cf4  (!\cf5 this\cf4 .tail) \{\
      \cf5 return\cf4  \cf5 null\cf4 \
    \}\
    \cf9 // if linkedlist has >= one node\cf4 \
    \cf5 else\cf4  \{\
      \cf5 let\cf4  removedTail = \cf5 this\cf4 .tail\
      \cf9 // if list has only 1 node left\cf4 \
      \cf5 if\cf4  (\cf5 this\cf4 .head === \cf5 this\cf4 .tail) \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .head = \cf5 null\cf4 \
      \}\
      \cf9 //if list has >1 node\cf4 \
      \cf5 else\cf4  \{\
        \cf5 this\cf4 .tail = \cf5 this\cf4 .tail.prev\
        \cf5 this\cf4 .tail.next = \cf5 null\cf4 \
      \}\
      \cf5 return\cf4  removedTail.value\
    \}\
  \}\
\
  search(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .head\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  currentNode\
      \}\
      currentNode = currentNode.next\
    \}\
\
    \cf5 return\cf4  \cf5 null\cf4 \
  \}\
\
reverse() \{\
    \cf10 if\cf4  (!\cf10 this\cf4 .head) \{\
      \cf10 return\cf4  null;\
    \}\
\
    \cf10 let\cf4  currentNode = 
\f0\b this
\f1\b0 .head;\
    \cf10 this\cf4 .tail = currentNode;\
\
    \cf10 while\cf4  (currentNode) \{\
      \cf10 let
\f0\b  
\f1\b0 \cf4 prev = currentNode.prev;\
      currentNode.prev = currentNode.next;\
      currentNode.next = prev;\
\
      \cf10 if\cf4  (currentNode.prev) \{\
        currentNode = currentNode.prev;\
      \} \cf10 else\cf4  \{\
        \cf10 this.\cf4 head = currentNode;\
        \cf10 break\cf4 ;\
      \}\
    \}\
\}\
\
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4  (value, prev, next) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .next = next || \cf5 null\cf4 \
    \cf5 this\cf4 .prev = prev || \cf5 null\cf4 \
  \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0

\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// HASH TABLE (store keys and values)
\f1\b0\fs28 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 const\cf4  hash = (key, size) => \{\
  \cf5 let\cf4  hashedKey = \cf7 0\cf4 \
  \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; i < key.length; i++) \{\
    hashedKey += key.charCodeAt(i)\
  \}\
  \cf5 return\cf4  hashedKey % size\
\}\
\
\cf5 class\cf4  \cf6 HashTable\cf4  \{\
  \cf5 constructor\cf4 () \{\
    \cf5 this\cf4 .size = \cf7 20\cf4 \
    \cf5 this\cf4 .buckets = \cf6 Array\cf4 (\cf5 this\cf4 .size) \
\
    \cf9 // populate each bucket with a Map()\cf4 \
    \cf5 for\cf4  (\cf5 let\cf4  i = \cf7 0\cf4 ; \cf5 this\cf4 .buckets.length; i++) \{\
      \cf5 this\cf4 .buckets[i] = \cf5 new\cf4  \cf6 Map\cf4 ()\
    \}\
  \}\
\
  insert(key, value) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size) \
    \cf5 this\cf4 .buckets[idx].\cf5 set\cf4 (key, value)\
  \}\
\
  remove(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 let\cf4  deleted = \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key)\
    \cf5 this\cf4 .buckets[idx].\cf5 delete\cf4 (key)\
    \cf5 return\cf4  deleted \
  \}\
\
  search(key) \{\
    \cf5 let\cf4  idx = hash(key, \cf5 this\cf4 .size)\
    \cf5 return\cf4  \cf5 this\cf4 .buckets[idx].\cf5 get\cf4 (key)\
  \}\
\}
\f2\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b \cf2 \expnd0\expndtw0\kerning0
// BINARY SEARCH TREE (Access and process large amounts of ordered data)
\f1\b0\fs28 \cf4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf5 class\cf4  \cf6 Node\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .value = value\
    \cf5 this\cf4 .left = \cf5 null\cf4 \
    \cf5 this\cf4 .right = \cf5 null\cf4 \
  \}\
\}\
\
\cf5 class\cf4  \cf6 BST\cf4  \{\
  \cf5 constructor\cf4 (value) \{\
    \cf5 this\cf4 .root = \cf5 new\cf4  \cf6 Node\cf4 (value)\
    \cf5 this\cf4 .count = \cf7 1\cf4 \
  \}\
\
  size() \{\
    \cf5 return\cf4  \cf5 this\cf4 .count\
  \}\
\
  insert(value) \{\
    \cf5 this\cf4 .count++\
\
    \cf5 let\cf4  newNode = \cf5 new\cf4  \cf6 Node\cf4 (value)\
\
    \cf5 const\cf4  searchTree = node => \{\
      \cf9 // if value < node.value, go left\cf4 \
      \cf5 if\cf4  (value < node.value) \{\
        \cf9 // if no left child, append new node\cf4 \
        \cf5 if\cf4  (!node.left) \{\
          node.left = newNode\
        \} \
        \cf9 // if left child, look left again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.left)\
        \}\
      \}\
      \cf9 // if value > node.value, go right\cf4 \
      \cf5 else\cf4  \{\
        \cf9 // if no right child, append new node\cf4 \
        \cf5 if\cf4  (!node.right) \{\
          node.right = newNode\
        \}\
        \cf9 // if right child, look right again\cf4 \
        \cf5 else\cf4  \{\
          searchTree(node.right)\
        \}\
      \}\
    \}\
\
    searchTree(\cf5 this\cf4 .root)\
  \}\
\
  min() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf9 // continue traversing left until no more children\cf4 \
    \cf5 while\cf4  (currentNode.left) \{\
      currentNode = currentNode.left\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  max() \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf9 // continue traversing right until no more children\cf4 \
    \cf5 while\cf4  (currentNode.right) \{\
      currentNode = currentNode.right\
    \}\
\
    \cf5 return\cf4  currentNode.value\
  \}\
\
  contains(value) \{\
    \cf5 let\cf4  currentNode = \cf5 this\cf4 .root\
\
    \cf5 while\cf4  (currentNode) \{\
      \cf5 if\cf4  (value === currentNode.value) \{\
        \cf5 return\cf4  \cf5 true\cf4 \
      \} \cf11 else\cf4  \cf5 if\cf4  (value < currentNode.value) \{\
        currentNode = currentNode.left\
      \} \cf5 else\cf4  \{\
        currentNode = currentNode.right\
      \}\
    \}\
\
    \cf5 return\cf4  \cf5 false\cf4 \
  \}\
\
  \cf9 // depth first search - branch by branch\cf4 \
\
  \cf9 // in-order\cf4 \
  \cf9 // left, root, right\cf4 \
  \cf9 // 2, 3, 12, 15, 28, 36, 39\cf4 \
  dfsInOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result\
  \}\
\
  \cf9 // pre-order\cf4 \
  \cf9 // root, left, right\cf4 \
  \cf9 // 15, 3, 2, 12, 36, 28, 39\cf4 \
  dfsPreOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result    \
  \}\
\
  \cf9 // post-order\cf4 \
  \cf9 // left, right, root\cf4 \
  \cf9 // 2, 12, 3, 28, 39, 36, 15\cf4 \
  dfsPostOrder() \{\
    \cf5 let\cf4  result = []\
\
    \cf5 const\cf4  traverse = node => \{\
      \cf9 // if left child exists, go left again\cf4 \
      \cf5 if\cf4  (node.left) traverse(node.left)      \
      \cf9 // if right child exists, go right again\cf4 \
      \cf5 if\cf4  (node.right) traverse(node.right)\
      \cf9 // capture root node value\cf4 \
      result.push(node.value)\
    \}\
\
    traverse(\cf5 this\cf4 .root)\
\
    \cf5 return\cf4  result   \
  \}\
\
  \cf9 // breadth first search - level by level\cf4 \
\
  \cf9 // use a queue!\cf4 \
  \cf9 // 15, 3, 36, 2, 12, 28, 39\cf4 \
  \cb12 \outl0\strokewidth0 bfs() \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12     \cf5 \strokec5 let\cf4 \strokec4  result = []\cb1 \
\cb12     \cf5 \strokec5 let\cf4 \strokec4  queue = []\cb1 \
\
\cb12     queue.push(\cf5 \strokec5 this\cf4 \strokec4 .root)\cb1 \
\
\cb12     \cf5 \strokec5 while\cf4 \strokec4 (queue.length) \{\cb1 \
\cb12       \cf5 \strokec5 let\cf4 \strokec4  currentNode = queue.shift()\cb1 \
\
\cb12       result.push(currentNode.value)\cb1 \
\
\cb12       \cf5 \strokec5 if\cf4 \strokec4  (currentNode.left) queue.push(currentNode.left)\cb1 \
\cb12       \cf5 \strokec5 if\cf4 \strokec4  (currentNode.right) queue.push(currentNode.right)\cb1 \
\cb12     \}\cb1 \
\cb12     \cf5 \strokec5 return\cf4 \strokec4  result\cb1 \
\cb12   \}\cb1 \
\cb12 \}\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // MIN HEAP (Used primarily for its sort method O(n log n))
\f2\b0\fs30 \cf13 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb12 \outl0\strokewidth0 \strokec5 class\cf4 \strokec4  \cf14 \strokec14 MinHeap\cf4 \strokec4  \{\cb1 \
\cb12   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .heap = [\cf5 \strokec5 null\cf4 \strokec4 ];\cb1 \
\cb12   \}\cb1 \
\
\cb12   insert(num) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.push(num);\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf16 \strokec16 2\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  idx = \cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf16 \strokec16 1\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[idx] < \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf14 \strokec14 Math\cf4 \strokec4 .floor(idx/\cf16 \strokec16 2\cf4 \strokec4 )]) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (idx >= \cf16 \strokec16 1\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf14 \strokec14 Math\cf4 \strokec4 .floor(idx/\cf16 \strokec16 2\cf4 \strokec4 )], \cf5 \strokec5 this\cf4 \strokec4 .heap[idx]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[idx], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf14 \strokec14 Math\cf4 \strokec4 .floor(idx/\cf16 \strokec16 2\cf4 \strokec4 )]];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf14 \strokec14 Math\cf4 \strokec4 .floor(idx/\cf16 \strokec16 2\cf4 \strokec4 ) > \cf16 \strokec16 1\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 idx = \cf14 \strokec14 Math\cf4 \strokec4 .floor(idx/\cf16 \strokec16 2\cf4 \strokec4 );\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \cb1 \strokec4 \
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \strokec4 remove() \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  smallest = \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 1\cf4 \strokec4 ];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf16 \strokec16 2\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 1\cf4 \strokec4 ] = \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf16 \strokec16 1\cf4 \strokec4 ];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.splice(\cf5 \strokec5 this\cf4 \strokec4 .heap.length - \cf16 \strokec16 1\cf4 \strokec4 );\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length == \cf16 \strokec16 3\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 1\cf4 \strokec4 ] > \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 2\cf4 \strokec4 ]) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 1\cf4 \strokec4 ], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 2\cf4 \strokec4 ]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 2\cf4 \strokec4 ], \cf5 \strokec5 this\cf4 \strokec4 .heap[\cf16 \strokec16 1\cf4 \strokec4 ]];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  smallest;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  i = \cf16 \strokec16 1\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  left = \cf16 \strokec16 2\cf4 \strokec4  * i;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  right = \cf16 \strokec16 2\cf4 \strokec4  * i + \cf16 \strokec16 1\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[i] >= \cf5 \strokec5 this\cf4 \strokec4 .heap[left] || \cf5 \strokec5 this\cf4 \strokec4 .heap[i] >= \cf5 \strokec5 this\cf4 \strokec4 .heap[right]) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[left] < \cf5 \strokec5 this\cf4 \strokec4 .heap[right]) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[i], \cf5 \strokec5 this\cf4 \strokec4 .heap[left]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[left], \cf5 \strokec5 this\cf4 \strokec4 .heap[i]];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 i = \cf16 \strokec16 2\cf4 \strokec4  * i\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 [\cf5 \strokec5 this\cf4 \strokec4 .heap[i], \cf5 \strokec5 this\cf4 \strokec4 .heap[right]] = [\cf5 \strokec5 this\cf4 \strokec4 .heap[right], \cf5 \strokec5 this\cf4 \strokec4 .heap[i]];\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 i = \cf16 \strokec16 2\cf4 \strokec4  * i + \cf16 \strokec16 1\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 left = \cf16 \strokec16 2\cf4 \strokec4  * i;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 right = \cf16 \strokec16 2\cf4 \strokec4  * i + \cf16 \strokec16 1\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap[left] == \cf5 \strokec5 undefined\cf4 \strokec4  || \cf5 \strokec5 this\cf4 \strokec4 .heap[right] == \cf5 \strokec5 undefined\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length == \cf16 \strokec16 2\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 this\cf4 \strokec4 .heap.splice(\cf16 \strokec16 1\cf4 \strokec4 , \cf16 \strokec16 1\cf4 \strokec4 );\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf4 \strokec4 \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 null\cf4 \strokec4 ;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  smallest;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12   \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \strokec4 sort() \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 let\cf4 \strokec4  result = \cf5 \strokec5 new\cf4 \strokec4  \cf14 \strokec14 Array\cf4 \strokec4 ();\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 while\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .heap.length > \cf16 \strokec16 1\cf4 \strokec4 ) \{\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\'a0\'a0\cf4 \strokec4 result.push(\cf5 \strokec5 this\cf4 \strokec4 .remove());\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf4 \strokec4 \};\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  result;\cb1 \
\cf15 \cb12 \strokec15 \'a0\'a0\cf4 \strokec4 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \}\cb1 \
\
\pard\pardeftab720\sl340\partightenfactor0

\f3\fs26 \cf4 \outl0\strokewidth0 \
\pard\pardeftab720\sl340\partightenfactor0

\f2\fs30 \cf13 \cb3 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 // SET
\f2\b0\fs30 \cf13 \
\pard\pardeftab720\sl340\partightenfactor0
\cf13 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf5 \cb12 \outl0\strokewidth0 \strokec5 class\cf4 \strokec4  \cf14 \strokec14 Set\cf4 \strokec4  \{\cb1 \
\cf5 \cb12 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb12   \cf5 \strokec5 this\cf4 \strokec4 .collection = [];\cb1 \
\cb12 \}\cb1 \
\
\cb12   has(element) \{\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .collection.indexOf(element) !== -\cf16 \strokec16 1\cf4 \strokec4 );\cb1 \
\cb12 \};\cb1 \
\
\cb12   values() \{\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .collection;\cb1 \
\cb12 \};\cb1 \
\
\cb12   add(element) \{\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (!\cf5 \strokec5 this\cf4 \strokec4 .has(element)) \{\cb1 \
\cb12 \'a0\'a0  \cf5 \strokec5 this\cf4 \strokec4 .collection.push(element);\cb1 \
\cb12 \'a0\'a0  \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb12 \'a0\'a0\}\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 false\cf4 \cb1 \strokec4 \
\cb12 \};\cb1 \
\
\cb12   remove(element) \{\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .has(element)) \{\cb1 \
\cb12 \'a0\'a0  index = \cf5 \strokec5 this\cf4 \strokec4 .collection.indexOf(element);\cb1 \
\cb12 \'a0\'a0  \cf5 \strokec5 this\cf4 \strokec4 .collection.splice(index, \cf16 \strokec16 1\cf4 \strokec4 );\cb1 \
\cb12 \'a0\'a0  \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb12 \'a0\'a0\}\cb1 \
\cb12 \'a0\'a0\cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 false\cf4 \cb1 \strokec4 \
\cb12 \};\cb1 \
\
\cb12   size () \{\cb1 \
\cb12     \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .collection.length;\cb1 \
\cb12 \}\cb1 \
\
\cb12 \}\cb1 \
\pard\pardeftab720\sl340\partightenfactor0

\f2\fs30 \cf13 \cb3 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf4 \cb1 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // Graph (used for BFS - social networks, GPS, flight paths)\
\pard\pardeftab720\sl500\sa200\partightenfactor0

\f2\b0\fs30 \cf17 \outl0\strokewidth0 \strokec17 Nearly all graph problems will somehow use a grid or network in the problem, but sometimes these will be well disguised. Secondly, if you are required to find a path of any sort, it is usually a graph problem as well. Some common keywords associated with graph problems are: vertices, nodes, edges, connections, connectivity, paths, cycles and direction. An example of a description of a simple problem that exhibits some of these characteristics is:\
"Bob has become lost in his neighborhood. He needs to get from his current position back to his home. Bob\'92s neighborhood is a 2 dimensional grid, that starts at (0, 0) and (width \'96 1, height \'96 1). There are empty spaces upon which bob can walk with no difficulty, and houses, which Bob cannot pass through. Bob may only move horizontally or vertically by one square at a time.\
Bob\'92s initial position will be represented by a \'91B\'92 and the house location will be represented by an \'91H\'92. Empty squares on the grid are represented by \'91.\'92 and houses are represented by \'91X\'92. Find the minimum number of steps it takes Bob to get back home, but if it is not possible for Bob to return home, return -1.\
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf5 \cb12 \strokec5 class\cf4 \strokec4  \cf14 \strokec14 Graph\cf4 \strokec4  \{\cb1 \
\cb12   \cf5 \strokec5 constructor\cf4 \strokec4 () \{\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .storage = \{\};\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .size = \cf16 \strokec16 0\cf4 \strokec4 ;\cb1 \
\cb12   \}\cb1 \
\
\cb12   add(value) \{\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .storage[value] = \{\};\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .size++;\cb1 \
\cb12   \}\cb1 \
\
\cb12   addConnection(fr, to) \{\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .storage[fr][to] = \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .storage[to][fr] = \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb12   \}\cb1 \
\
\cb12   removeConnection(fr, to) \{\cb1 \
\cb12     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[fr][to]\cb1 \
\cb12     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[to][fr]\cb1 \
\cb12   \}\cb1 \
\
\cb12   contains(target) \{\cb1 \
\cb12     \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage.hasOwnProperty(target);\cb1 \
\cb12   \}\cb1 \
\
\cb12   hasConnection(fr, to) \{\cb1 \
\cb12     \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[fr].hasOwnProperty(to);\cb1 \
\cb12   \}\cb1 \
\
\cb12   remove(value) \{\cb1 \
\cb12     \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[val];\cb1 \
\cb12     \cf5 \strokec5 this\cf4 \strokec4 .count--;\cb1 \
\cb12     \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 let\cf4 \strokec4  key \cf5 \strokec5 in\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage) \{\cb1 \
\cb12       \cf5 \strokec5 if\cf4 \strokec4  (\cf5 \strokec5 this\cf4 \strokec4 .storage[key][val]) \{\cb1 \
\cb12         \cf5 \strokec5 delete\cf4 \strokec4  \cf5 \strokec5 this\cf4 \strokec4 .storage[key][val];\cb1 \
\cb12       \}\cb1 \
\cb12     \}\cb1 \
\cb12   \}\cb1 \
\cb12 \}\cb1 \
\
\
\
\pard\pardeftab720\sl282\partightenfactor0

\f4\fs23\fsmilli11880 \cf18 \cb3 \strokec18 \
}