{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 HelveticaNeue;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue255;
\red255\green255\blue254;\red0\green0\blue0;\red14\green110\blue109;\red19\green120\blue72;\red154\green154\blue154;
\red191\green28\blue37;\red144\green1\blue18;\red255\green255\blue254;\red154\green154\blue154;\red144\green1\blue18;
\red19\green120\blue72;\red14\green110\blue109;\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;
}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c100000;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c66667\c66667\c66667;
\cssrgb\c80392\c19216\c19216;\cssrgb\c63922\c8235\c8235;\cssrgb\c100000\c100000\c99608;\cssrgb\c66667\c66667\c66667;\cssrgb\c63922\c8235\c8235;
\cssrgb\c3529\c53333\c35294;\cssrgb\c0\c50196\c50196;\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14320\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Two Sum
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
let\cf6  twoSum = (nums, target) => \{\cb1 \
\cb5     \cf4 let\cf6  idx = \cf4 new\cf6  \cf7 Map\cf6 ();\cb1 \
\cb5     \cf4 let\cf6  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf4 let\cf6  complement = target - num;\cb1 \
\
\cb5       \cf4 if\cf6  (idx.has(complement)) \{\cb1 \
\cb5         result[\cf8 0\cf6 ] = idx.\cf4 get\cf6 (complement);\cb1 \
\cb5         result[\cf8 1\cf6 ] = i;\cb1 \
\
\cb5         \cf4 return\cf6  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       idx.\cf4 set\cf6 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf4 return\cf6  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 2\cf6 , \cf8 3\cf6 , \cf8 8\cf6 , \cf8 7\cf6 , \cf8 4\cf6 ], \cf8 9\cf6 ) \cf9 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // FIRST BAD VERSION (binary search)
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
let\cf6  solution = \cf4 function\cf6 (isBadVersion) \{\cb1 \
\cb5     \cf4 return\cf6  \cf4 function\cf6 (n) \{\cb1 \
\cb5         \cf4 let\cf6  left = \cf8 1\cf6 ;\cb1 \
\cb5         \cf4 let\cf6  right = n;\cb1 \
\cb5         \cb1 \
\cb5         \cf4 while\cf6  (left < right) \{\cb1 \
\cb5             \cf4 let\cf6  mid = left + \cf7 Math\cf6 .floor((right - left) / \cf8 2\cf6 );\cb1 \
\cb5             \cf4 if\cf6  (!isBadVersion(mid)) \{\cb1 \
\cb5                 left = mid + \cf8 1\cf6 ;\cb1 \
\cb5             \} \cf4 else\cf6  \{\cb1 \
\cb5                 right = mid;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\
\cb5         \cf4 return\cf6  left;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Sqrt(x) (binary search)
\f2\b0\fs28 \cf6 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  mySqrt = num => \{\cf10 \'a0\cf6 \cb1 \
\cb5   \cf4 if\cf6  (num <= \cf8 1\cf6 ) \{\cb1 \
\cb5     \cf4 return\cf6  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 let\cf6  left = \cf8 1\cf6 ;\cb1 \
\cb5   \cf4 let\cf6  right = num;\cb1 \
\
\cb5   \cf4 while\cf6  (left < right) \{\cb1 \
\cb5     \cf4 let\cf6  mid = left + \cf7 Math\cf6 .floor((right - left) / \cf8 2\cf6 );\cb1 \
\
\cb5    \'a0\cf4 if\cf6  (mid * mid === num) \cf4 return\cf6  mid;\cb1 \
\cb5     \cf4 if\cf6  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf4 if\cf6  (mid * mid < num) left = mid + \cf8 1\cf6 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 return\cf6  left;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // HOUSE ROBBER (dynamic programming)
\f2\b0\fs28 \cf6 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  rob = nums => \{\cb1 \
\cb5     \cf4 if\cf6  (nums === \cf4 null\cf6  || nums.length === \cf8 0\cf6 ) \{ \cf9 // if there are no houses, the total is zero\cf6 \cb1 \
\cb5         \cf4 return\cf6  \cf8 0\cf6 ;\cb1 \
\cb5     \} \cf4 else\cf6  \cf4 if\cf6  (nums.length == \cf8 1\cf6 ) \{\cb1 \
\cb5         \cf4 return\cf6  nums[\cf8 0\cf6 ]; \cf9 // if there is only one house, return its value\cf6 \cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf4 let\cf6  runningTotal = [];\cb1 \
\cb5      \cf9 /* the first index will be the same value as the first house since there are no decisions to make at this point */\cf6 \cb1 \
\cb5     runningTotal[\cf8 0\cf6 ] = nums[\cf8 0\cf6 ],\cb1 \
\cb5     \cf9 /* the second index will be the greater value of the first house or the second house */\cf6 \cb1 \
\cb5     runningTotal[\cf8 1\cf6 ] = \cf7 Math\cf6 .max(nums[\cf8 0\cf6 ], nums[\cf8 1\cf6 ]);\cb1 \
\
\cb5     \cf9 /* start at index 2 since we have already made our 0th and 1st decisions (which correspond to our first and second houses) */\cf6 \cb1 \
\cb5     \cf4 for\cf6  (\cf4 let\cf6  i = \cf8 2\cf6 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf9 /* for each index, we choose the greater of (the current house's value plus the total from two houses ago) or (the total through the last house)  */\cf6 \cb1 \
\cb5         runningTotal[i] = \cf7 Math\cf6 .max(nums[i] + runningTotal[i - \cf8 2\cf6 ], runningTotal[i - \cf8 1\cf6 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf9 // return the last value in the array. this will be the optimal solution\cf6 \cb1 \
\cb5     \cf4 return\cf6  runningTotal[runningTotal.length - \cf8 1\cf6 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Steps to Reach Zero
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  numberOfSteps = num => \{\cb1 \
\cb5     \cf4 let\cf6  count = \cf8 0\cf6 \cb1 \
\
\cb5     \cf4 while\cf6  (num > \cf8 0\cf6 ) \{\cb1 \
\cb5         \cf4 if\cf6  (num % \cf8 2\cf6  === \cf8 1\cf6 ) \{\cb1 \
\cb5             num = num - \cf8 1\cf6 \cb1 \
\cb5             count ++\cb1 \
\cb5         \} \cf4 else\cf6  \{\cb1 \
\cb5         num = num / \cf8 2\cf6 \cb1 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf4 return\cf6  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Number of Islands (Backtracking)
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  numIslands = grid => \{\cb1 \
\cb5   \cf4 const\cf6  height = grid.length;\cb1 \
\cb5   \cf4 const\cf6  width = height && grid[\cf8 0\cf6 ].length;\cb1 \
\cb5   \cf4 let\cf6  count = \cf8 0\cf6 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 for\cf6  (\cf4 let\cf6  row = \cf8 0\cf6 ; row < height; row++) \{\cb1 \
\cb5     \cf4 for\cf6  (\cf4 let\cf6  col = \cf8 0\cf6 ; col < width; col++) \{\cb1 \
\cb5       \cf4 if\cf6  (grid[row][col] === \cf11 '0'\cf6 ) \cf4 continue\cf6 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf4 return\cf6  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 function\cf6  dfs(row, col) \{\cb1 \
\cb5     \cf4 if\cf6  (row < \cf8 0\cf6  || col < \cf8 0\cf6  || row === height || col === width || grid[row][col] === \cf11 '0'\cf6 ) \cf4 return\cf6 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf11 '0'\cf6 ;\cb1 \
\cb5     dfs(row-\cf8 1\cf6 , col);\cb1 \
\cb5     dfs(row+\cf8 1\cf6 , col);\cb1 \
\cb5     dfs(row, col-\cf8 1\cf6 );\cb1 \
\cb5     dfs(row, col+\cf8 1\cf6 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Largest Number in Array
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  largestNumber = nums => \{\cb1 \
\cb12   \cf4 \strokec4 const\cf6 \strokec6  finalNums = nums.map(elem => elem.toString());\cb1 \
\cb12     \cf13 \strokec13 // -1 a goes before b\cf6 \cb1 \strokec6 \
\cb12     \cf13 \strokec13 // 0  no change\cf6 \cb1 \strokec6 \
\cb12     \cf13 \strokec13 // 1  b goes before a\cf6 \cb1 \strokec6 \
\cb12     \cf4 \strokec4 const\cf6 \strokec6  compareFunc = (a, b) => \cf14 \strokec14 `\cf6 \strokec6 $\{b\}$\{a\}\cf14 \strokec14 `\cf6 \strokec6  - \cf14 \strokec14 `\cf6 \strokec6 $\{a\}$\{b\}\cf14 \strokec14 `\cf6 \cb1 \strokec6 \
\
\cb12     finalNums.sort(compareFunc);\cb1 \
\cb12     \cb1 \
\cb12     \cf4 \strokec4 if\cf6 \strokec6 (finalNums[\cf15 \strokec15 0\cf6 \strokec6 ] === \cf14 \strokec14 '0'\cf6 \strokec6 ) \cf4 \strokec4 return\cf6 \strokec6  \cf14 \strokec14 '0'\cf6 \strokec6 ;\cb1 \
\cb12     \cb1 \
\cb12     \cf4 \strokec4 return\cf6 \strokec6  finalNums.join(\cf14 \strokec14 ''\cf6 \strokec6 );\cb1 \
\cb12 \};\cb1 \
\
\
\cf16 \cb12 \strokec16 Input\cf6 \strokec6 : [\cf15 \strokec15 3\cf6 \strokec6 ,\cf15 \strokec15 30\cf6 \strokec6 ,\cf15 \strokec15 34\cf6 \strokec6 ,\cf15 \strokec15 5\cf6 \strokec6 ,\cf15 \strokec15 9\cf6 \strokec6 ]\cb1 \
\cf16 \cb12 \strokec16 Output\cf6 \strokec6 : \cf14 \strokec14 "9534330"\cf6 \cb1 \strokec6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Get All Permutations
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  getPermutations = arr => \{\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  output = [];\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  swap = (arrToSwap, indexA, indexB) => \{\cb1 \
\cb12     \cf4 \strokec4 const\cf6 \strokec6  temp = arrToSwap[indexA];\cb1 \
\cb12     arrToSwap[indexA] = arrToSwap[indexB];\cb1 \
\cb12     arrToSwap[indexB] = temp;\cb1 \
\cb12   \};\cb1 \
\
\cb12   \cf4 \strokec4 const\cf6 \strokec6  generate = (n, heapArr) => \{\cb1 \
\cb12     \cf4 \strokec4 if\cf6 \strokec6  (n === \cf15 \strokec15 1\cf6 \strokec6 ) \{\cb1 \
\cb12       output.push(heapArr.slice());\cb1 \
\cb12       \cf4 \strokec4 return\cf6 \strokec6 ;\cb1 \
\cb12     \}\cb1 \
\
\cb12     generate(n - \cf15 \strokec15 1\cf6 \strokec6 , heapArr);\cb1 \
\
\cb12     \cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  i = \cf15 \strokec15 0\cf6 \strokec6 ; i < n - \cf15 \strokec15 1\cf6 \strokec6 ; i++) \{\cb1 \
\cb12       \cf4 \strokec4 if\cf6 \strokec6  (n % \cf15 \strokec15 2\cf6 \strokec6  === \cf15 \strokec15 0\cf6 \strokec6 ) \{\cb1 \
\cb12         swap(heapArr, i, n - \cf15 \strokec15 1\cf6 \strokec6 );\cb1 \
\cb12       \} \cf4 \strokec4 else\cf6 \strokec6  \{\cb1 \
\cb12         swap(heapArr, \cf15 \strokec15 0\cf6 \strokec6 , n - \cf15 \strokec15 1\cf6 \strokec6 );\cb1 \
\cb12       \}\cb1 \
\
\cb12       generate(n - \cf15 \strokec15 1\cf6 \strokec6 , heapArr);\cb1 \
\cb12     \}\cb1 \
\cb12   \};\cb1 \
\
\cb12   generate(arr.length, arr.slice());\cb1 \
\
\cb12   \cf4 \strokec4 return\cf6 \strokec6  output;\cb1 \
\cb12 \};\cb1 \
\
\cb12 getPermutations([\cf15 \strokec15 1\cf6 \strokec6 , \cf15 \strokec15 2\cf6 \strokec6 , \cf15 \strokec15 3\cf6 \strokec6 ])\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Sum All #\'92s In Range
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  sumAll = arr => \{\cb1 \
\cb12 \'a0\'a0\cf4 \strokec4 let\cf6 \strokec6  sum = \cf15 \strokec15 0\cf6 \strokec6 ;\cb1 \
\cb12 \'a0\'a0\cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  i = \cf16 \strokec16 Math\cf6 \strokec6 .min( ...arr ); i <= \cf16 \strokec16 Math\cf6 \strokec6 .max( ...arr ); i++) \{\cb1 \
\cb12 \'a0\'a0\'a0\'a0sum += i;\cb1 \
\cb12 \'a0\'a0\}\cb1 \
\cb12 \'a0\'a0\cf4 \strokec4 return\cf6 \strokec6  sum;\cb1 \
\cb12 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Create Target Array from Two Arrays
\f2\b0\fs28 \cf6 \cb5 \
\pard\pardeftab720\sa280\partightenfactor0

\f3 \cf17 \cb3 \outl0\strokewidth0 \strokec17 Given two arrays of integers\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index
\f3\fs28 \cf17 \cb3 \strokec17 . Your task is to create\'a0
\f5\i target
\f3\i0 \'a0array under the following rules:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf17 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Initially\'a0
\f5\i target
\f3\i0 \'a0array is empty.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 From left to right read nums[i] and index[i], insert at index\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index[i]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0the value\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums[i]
\f3\fs28 \cf17 \cb3 \strokec17 \'a0in\'a0
\f5\i target
\f3\i0 \'a0array.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 Repeat the previous step until there are no elements to read in\'a0
\f4\fs26 \cf18 \cb19 \strokec18 nums
\f3\fs28 \cf17 \cb3 \strokec17 \'a0and\'a0
\f4\fs26 \cf18 \cb19 \strokec18 index.
\f3\fs28 \cf17 \cb1 \strokec17 \
\pard\pardeftab720\sa280\partightenfactor0
\cf17 \cb3 Return the\'a0
\f5\i target
\f3\i0 \'a0array.
\f2 \cf6 \cb5 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  createTargetArray = (nums, idx) => \{\cb1 \
\cb12     \cf4 \strokec4 let\cf6 \strokec6  target = []\cb1 \
\cb12     \cf4 \strokec4 for\cf6 \strokec6 (\cf4 \strokec4 let\cf6 \strokec6  num \cf4 \strokec4 in\cf6 \strokec6  nums)target.splice(idx[num], \cf15 \strokec15 0\cf6 \strokec6 , nums[num])\cb1 \
\cb12     \cf4 \strokec4 return\cf6 \strokec6  target\cb1 \
\cb12 \};\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 let\cf6 \strokec6  nums = [\cf15 \strokec15 0\cf6 \strokec6 ,\cf15 \strokec15 1\cf6 \strokec6 ,\cf15 \strokec15 2\cf6 \strokec6 ,\cf15 \strokec15 3\cf6 \strokec6 ,\cf15 \strokec15 4\cf6 \strokec6 ]\cb1 \
\cf4 \cb12 \strokec4 let\cf6 \strokec6  index = [\cf15 \strokec15 0\cf6 \strokec6 ,\cf15 \strokec15 1\cf6 \strokec6 ,\cf15 \strokec15 2\cf6 \strokec6 ,\cf15 \strokec15 2\cf6 \strokec6 ,\cf15 \strokec15 1\cf6 \strokec6 ]\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf13 \cb12 \strokec13 //Output: [0,4,1,3,2]\cf6 \cb1 \strokec6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Climb Stairs (Recursion/Fibonacci sequence)
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  climbStairs = n => \{\cb1 \
\cb12     \cf4 \strokec4 let\cf6 \strokec6  arr=[\cf15 \strokec15 1\cf6 \strokec6 , \cf15 \strokec15 2\cf6 \strokec6 , \cf15 \strokec15 3\cf6 \strokec6 ];\cb1 \
\cb12     \cf4 \strokec4 for\cf6 \strokec6 (\cf4 \strokec4 let\cf6 \strokec6  i = \cf15 \strokec15 3\cf6 \strokec6 ;i<n;i++)\{\cb1 \
\cb12         arr[i]=arr[i-\cf15 \strokec15 1\cf6 \strokec6 ] + arr[i-\cf15 \strokec15 2\cf6 \strokec6 ];\cb1 \
\cb12     \}\cb1 \
\cb12     \cf4 \strokec4 return\cf6 \strokec6  arr[n-\cf15 \strokec15 1\cf6 \strokec6 ];\cb1 \
\cb12 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Transpose Matrix 
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb12 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  transpose = arr => \{\cb1 \
\cb12     \cf4 \strokec4 if\cf6 \strokec6 (arr.length === \cf15 \strokec15 0\cf6 \strokec6 ) \cf4 \strokec4 return\cf6 \strokec6  [];\cb1 \
\cb12     \cf4 \strokec4 let\cf6 \strokec6  width = arr[\cf15 \strokec15 0\cf6 \strokec6 ].length \cb1 \
\cb12     \cf4 \strokec4 let\cf6 \strokec6  height = arr.length;\cb1 \
\cb12     \cf4 \strokec4 var\cf6 \strokec6  result = [];\cb1 \
\cb12     \cf4 \strokec4 for\cf6 \strokec6 (\cf4 \strokec4 var\cf6 \strokec6  i = \cf15 \strokec15 0\cf6 \strokec6 ; i < width; i ++) \{\cb1 \
\cb12         result[i] = [];\cb1 \
\cb12         \cf4 \strokec4 for\cf6 \strokec6 (\cf4 \strokec4 var\cf6 \strokec6  j = \cf15 \strokec15 0\cf6 \strokec6 ; j < height; j ++)\{\cb1 \
\cb12             result[i][j] = arr[j][i];\cb1 \
\cb12         \}\cb1 \
\cb12     \}\cb1 \
\cb12     \cf4 \strokec4 return\cf6 \strokec6  result;\cb1 \
\cb12 \};\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\b\fs26 \cf17 \cb19 \strokec17 Input: 
\f2\b0 [[1,2,3],[4,5,6],[7,8,9]]\

\f0\b Output: 
\f2\b0 [[1,4,7],[2,5,8],[3,6,9]]\
\pard\pardeftab720\sl420\partightenfactor0

\fs28 \cf6 \cb1 \strokec6 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Next Problem
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  functionName = arr => \{\cb1 \
\
\}\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 // Next Problem
\f2\b0\fs28 \cf6 \cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  functionName = arr => \{\cb1 \
\
\}\
\
}