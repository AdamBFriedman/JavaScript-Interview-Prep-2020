{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red255\green255\blue255;\red0\green0\blue255;
\red255\green255\blue254;\red0\green0\blue0;\red14\green110\blue109;\red19\green120\blue72;\red154\green154\blue154;
\red191\green28\blue37;\red255\green255\blue254;\red144\green1\blue18;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c100000;
\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;\cssrgb\c0\c50196\c50196;\cssrgb\c3529\c53333\c35294;\cssrgb\c66667\c66667\c66667;
\cssrgb\c80392\c19216\c19216;\cssrgb\c100000\c100000\c99608;\cssrgb\c63922\c8235\c8235;}
\margl1440\margr1440\vieww13720\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
// Two Sum
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 let\cf6 \strokec6  twoSum = (nums, target) => \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5     \cf4 \strokec4 let\cf6 \strokec6  numberIndex = \cf4 \strokec4 new\cf6 \strokec6  \cf7 \strokec7 Map\cf6 \strokec6 ();\cb1 \
\cb5     \cf4 \strokec4 let\cf6 \strokec6  result = [];\cb1 \
\
\cb5     nums.forEach((num, i) => \{\cb1 \
\cb5       \cf4 \strokec4 let\cf6 \strokec6  complement = target - num;\cb1 \
\
\cb5       \cf4 \strokec4 if\cf6 \strokec6  (numberIndex.has(complement)) \{\cb1 \
\cb5         result[\cf8 \strokec8 0\cf6 \strokec6 ] = numberIndex.\cf4 \strokec4 get\cf6 \strokec6 (complement);\cb1 \
\cb5         result[\cf8 \strokec8 1\cf6 \strokec6 ] = i;\cb1 \
\
\cb5         \cf4 \strokec4 return\cf6 \strokec6  result;\cb1 \
\cb5       \}\cb1 \
\
\cb5       numberIndex.\cf4 \strokec4 set\cf6 \strokec6 (num, i);\cb1 \
\cb5     \})\cb1 \
\
\cb5     \cf4 \strokec4 return\cf6 \strokec6  result;\cb1 \
\cb5 \};\cb1 \
\
\cb5 twoSum([\cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 8\cf6 \strokec6 , \cf8 \strokec8 7\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 ], \cf8 \strokec8 9\cf6 \strokec6 ) \cf9 \strokec9 //[0, 3]\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // FIRST BAD VERSION (binary search)
\f1\b0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 let\cf6 \strokec6  solution = \cf4 \strokec4 function\cf6 \strokec6 (isBadVersion) \{\cb1 \
\cb5     \cf4 \strokec4 return\cf6 \strokec6  \cf4 \strokec4 function\cf6 \strokec6 (n) \{\cb1 \
\cb5         \cf4 \strokec4 let\cf6 \strokec6  left = \cf8 \strokec8 1\cf6 \strokec6 ;\cb1 \
\cb5         \cf4 \strokec4 let\cf6 \strokec6  right = n;\cb1 \
\cb5         \cb1 \
\cb5         \cf4 \strokec4 while\cf6 \strokec6  (left < right) \{\cb1 \
\cb5             \cf4 \strokec4 let\cf6 \strokec6  mid = left + \cf7 \strokec7 Math\cf6 \strokec6 .floor((right - left) / \cf8 \strokec8 2\cf6 \strokec6 );\cb1 \
\cb5             \cf4 \strokec4 if\cf6 \strokec6  (!isBadVersion(mid)) \{\cb1 \
\cb5                 left = mid + \cf8 \strokec8 1\cf6 \strokec6 ;\cb1 \
\cb5             \} \cf4 \strokec4 else\cf6 \strokec6  \{\cb1 \
\cb5                 right = mid;\cb1 \
\cb5             \}\cb1 \
\cb5         \}\cb1 \
\
\cb5         \cf4 \strokec4 return\cf6 \strokec6  left;\cb1 \
\cb5     \};\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // Sqrt(x) (binary search)
\f2\b0\fs28 \cf6 \cb5 \outl0\strokewidth0 \strokec6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \strokec4 const\cf6 \strokec6  mySqrt = num => \{\cf10 \strokec10 \'a0\cf6 \cb1 \strokec6 \
\cb5   \cf4 \strokec4 if\cf6 \strokec6  (num <= \cf8 \strokec8 1\cf6 \strokec6 ) \{\cb1 \
\cb5     \cf4 \strokec4 return\cf6 \strokec6  num;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 \strokec4 let\cf6 \strokec6  left = \cf8 \strokec8 1\cf6 \strokec6 ;\cb1 \
\cb5   \cf4 \strokec4 let\cf6 \strokec6  right = num;\cb1 \
\
\cb5   \cf4 \strokec4 while\cf6 \strokec6  (left < right) \{\cb1 \
\cb5     \cf4 \strokec4 let\cf6 \strokec6  mid = left + \cf7 \strokec7 Math\cf6 \strokec6 .floor((right - left) / \cf8 \strokec8 2\cf6 \strokec6 );\cb1 \
\
\cb5    \'a0\cf4 \strokec4 if\cf6 \strokec6  (mid * mid === num) \cf4 \strokec4 return\cf6 \strokec6  mid;\cb1 \
\cb5     \cf4 \strokec4 if\cf6 \strokec6  (mid * mid > num) right = mid;\cb1 \
\cb5     \cf4 \strokec4 if\cf6 \strokec6  (mid * mid < num) left = mid + \cf8 \strokec8 1\cf6 \strokec6 ;\cb1 \
\cb5   \}\cb1 \
\
\cb5   \cf4 \strokec4 return\cf6 \strokec6  left - \cf8 \strokec8 1\cf6 \strokec6 ;\cb1 \
\cb5 \};\cb1 \
\cb5 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // HOUSE ROBBER (dynamic programming)
\f2\b0\fs28 \cf6 \cb11 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  rob = nums => \{\cb1 \
\cb5     \cf4 \strokec4 if\cf6 \strokec6  (nums === \cf4 \strokec4 null\cf6 \strokec6  || nums.length === \cf8 \strokec8 0\cf6 \strokec6 ) \{ \cf9 \strokec9 // if there are no houses, the total is zero\cf6 \cb1 \strokec6 \
\cb5         \cf4 \strokec4 return\cf6 \strokec6  \cf8 \strokec8 0\cf6 \strokec6 ;\cb1 \
\cb5     \} \cf4 \strokec4 else\cf6 \strokec6  \cf4 \strokec4 if\cf6 \strokec6  (nums.length == \cf8 \strokec8 1\cf6 \strokec6 ) \{\cb1 \
\cb5         \cf4 \strokec4 return\cf6 \strokec6  nums[\cf8 \strokec8 0\cf6 \strokec6 ]; \cf9 \strokec9 // if there is only one house, return its value\cf6 \cb1 \strokec6 \
\cb5     \}\cb1 \
\
\cb5     \cf4 \strokec4 let\cf6 \strokec6  runningTotal = [];\cb1 \
\cb5      \cf9 \strokec9 /* the first index will be the same value as the first house since there are no decisions to make at this point */\cf6 \cb1 \strokec6 \
\cb5     runningTotal[\cf8 \strokec8 0\cf6 \strokec6 ] = nums[\cf8 \strokec8 0\cf6 \strokec6 ],\cb1 \
\cb5     \cf9 \strokec9 /* the second index will be the greater value of the first house or the second house */\cf6 \cb1 \strokec6 \
\cb5     runningTotal[\cf8 \strokec8 1\cf6 \strokec6 ] = \cf7 \strokec7 Math\cf6 \strokec6 .max(nums[\cf8 \strokec8 0\cf6 \strokec6 ], nums[\cf8 \strokec8 1\cf6 \strokec6 ]);\cb1 \
\
\cb5     \cf9 \strokec9 /* start at index 2 since we already have already made our 0th and 1st decisions (which correspond to our first and second houses) */\cf6 \cb1 \strokec6 \
\cb5     \cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  i = \cf8 \strokec8 2\cf6 \strokec6 ; i < nums.length; i++) \{\cb1 \
\cb5         \cf9 \strokec9 /* for each index, we choose the greater of (the current house's value plus the total from two houses ago) or (the total through the last house)  */\cf6 \cb1 \strokec6 \
\cb5         runningTotal[i] = \cf7 \strokec7 Math\cf6 \strokec6 .max(nums[i] + runningTotal[i - \cf8 \strokec8 2\cf6 \strokec6 ], runningTotal[i - \cf8 \strokec8 1\cf6 \strokec6 ]);\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf9 \strokec9 // return the last value in the array. this will be the optimal solution\cf6 \cb1 \strokec6 \
\cb5     \cf4 \strokec4 return\cf6 \strokec6  runningTotal[runningTotal.length - \cf8 \strokec8 1\cf6 \strokec6 ];\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // Number of Steps
\f2\b0\fs28 \cf6 \cb5 \outl0\strokewidth0 \strokec6 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \
\cf4 \strokec4 const\cf6 \strokec6  numberOfSteps = (num) => \{\cb1 \
\cb5     \cf4 \strokec4 let\cf6 \strokec6  count = \cf8 \strokec8 0\cf6 \cb1 \strokec6 \
\
\cb5     \cf4 \strokec4 while\cf6 \strokec6  (num >\cf8 \strokec8 0\cf6 \strokec6 ) \{\cb1 \
\cb5         \cf4 \strokec4 if\cf6 \strokec6  (num%\cf8 \strokec8 2\cf6 \strokec6  === \cf8 \strokec8 1\cf6 \strokec6 ) \{\cb1 \
\cb5             num = num - \cf8 \strokec8 1\cf6 \cb1 \strokec6 \
\cb5             count ++\cb1 \
\cb5         \} \cf4 \strokec4 else\cf6 \strokec6  \{\cb1 \
\cb5         num = num / \cf8 \strokec8 2\cf6 \cb1 \strokec6 \
\cb5         count ++\cb1 \
\cb5         \}\cb1 \
\cb5     \}\cb1 \
\
\cb5     \cf4 \strokec4 return\cf6 \strokec6  count\cb1 \
\cb5 \};\
\
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // Number of Islands
\f2\b0\fs28 \cf6 \cb11 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb5 \outl0\strokewidth0 \strokec4 const\cf6 \strokec6  numIslands = grid => \{\cb1 \
\cb5   \cf4 \strokec4 const\cf6 \strokec6  height = grid.length;\cb1 \
\cb5   \cf4 \strokec4 const\cf6 \strokec6  width = height && grid[\cf8 \strokec8 0\cf6 \strokec6 ].length;\cb1 \
\cb5   \cf4 \strokec4 let\cf6 \strokec6  count = \cf8 \strokec8 0\cf6 \strokec6 ;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  row = \cf8 \strokec8 0\cf6 \strokec6 ; row < height; row++) \{\cb1 \
\cb5     \cf4 \strokec4 for\cf6 \strokec6  (\cf4 \strokec4 let\cf6 \strokec6  col = \cf8 \strokec8 0\cf6 \strokec6 ; col < width; col++) \{\cb1 \
\cb5       \cf4 \strokec4 if\cf6 \strokec6  (grid[row][col] === \cf12 \strokec12 '0'\cf6 \strokec6 ) \cf4 \strokec4 continue\cf6 \strokec6 ;\cb1 \
\cb5       \cb1 \
\cb5       count++;\cb1 \
\cb5       dfs(row, col);\cb1 \
\cb5     \}\cb1 \
\cb5   \}\cb1 \
\cb5   \cf4 \strokec4 return\cf6 \strokec6  count;\cb1 \
\cb5   \cb1 \
\cb5   \cf4 \strokec4 function\cf6 \strokec6  dfs(row, col) \{\cb1 \
\cb5     \cf4 \strokec4 if\cf6 \strokec6  (row < \cf8 \strokec8 0\cf6 \strokec6  || col < \cf8 \strokec8 0\cf6 \strokec6  || row === height || col === width || grid[row][col] === \cf12 \strokec12 '0'\cf6 \strokec6 ) \cf4 \strokec4 return\cf6 \strokec6 ;\cb1 \
\cb5     \cb1 \
\cb5     grid[row][col] = \cf12 \strokec12 '0'\cf6 \strokec6 ;\cb1 \
\cb5     dfs(row-\cf8 \strokec8 1\cf6 \strokec6 , col);\cb1 \
\cb5     dfs(row+\cf8 \strokec8 1\cf6 \strokec6 , col);\cb1 \
\cb5     dfs(row, col-\cf8 \strokec8 1\cf6 \strokec6 );\cb1 \
\cb5     dfs(row, col+\cf8 \strokec8 1\cf6 \strokec6 );\cb1 \
\cb5   \}\cb1 \
\cb5 \}\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \cb5 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \
\pard\pardeftab720\sl420\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \outl0\strokewidth0 // Next Problem
\f2\b0\fs28 \cf6 \cb11 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 const\cf6  functionName = () => \{\cb1 \
\
\cb11 \};\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \outl0\strokewidth0 \
\
\
\
\
\pard\pardeftab720\sl420\partightenfactor0
\cf6 \
}